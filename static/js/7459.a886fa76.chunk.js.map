{"version":3,"file":"static/js/7459.a886fa76.chunk.js","mappings":"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","sources":["../node_modules/highcharts/modules/accessibility.src.js"],"sourcesContent":["/**\n * @license Highcharts JS v11.0.1 (2023-05-08)\n *\n * Accessibility module\n *\n * (c) 2010-2021 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/accessibility', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Accessibility/Utils/HTMLUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Utility functions for accessibility module.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, win } = H;\n        const { css } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const simulatedEventTarget = win.EventTarget && new win.EventTarget() || 'none';\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         * @param {Highcharts.HTMLDOMElement} el\n         * @param {string} className\n         * @return {void}\n         */\n        function addClass(el, className) {\n            if (el.classList) {\n                el.classList.add(className);\n            }\n            else if (el.className.indexOf(className) < 0) {\n                // Note: Dumb check for class name exists, should be fine for practical\n                // use cases, but will return false positives if the element has a class\n                // that contains the className.\n                el.className += ' ' + className;\n            }\n        }\n        /**\n         * @private\n         * @param {Highcharts.HTMLDOMElement} el\n         * @param {string} className\n         * @return {void}\n         */\n        function removeClass(el, className) {\n            if (el.classList) {\n                el.classList.remove(className);\n            }\n            else {\n                // Note: Dumb logic that will break if the element has a class name that\n                // consists of className plus something else.\n                el.className = el.className.replace(new RegExp(className, 'g'), '');\n            }\n        }\n        /**\n         * Utility function to clone a mouse event for re-dispatching.\n         * @private\n         */\n        function cloneMouseEvent(e) {\n            if (typeof win.MouseEvent === 'function') {\n                return new win.MouseEvent(e.type, e);\n            }\n            // No MouseEvent support, try using initMouseEvent\n            if (doc.createEvent) {\n                const evt = doc.createEvent('MouseEvent');\n                if (evt.initMouseEvent) {\n                    evt.initMouseEvent(e.type, e.bubbles, // #10561, #12161\n                    e.cancelable, e.view || win, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n                    return evt;\n                }\n            }\n            return getFakeMouseEvent(e.type);\n        }\n        /**\n         * Utility function to clone a touch event for re-dispatching.\n         * @private\n         */\n        function cloneTouchEvent(e) {\n            const touchListToTouchArray = (l) => {\n                const touchArray = [];\n                for (let i = 0; i < l.length; ++i) {\n                    const item = l.item(i);\n                    if (item) {\n                        touchArray.push(item);\n                    }\n                }\n                return touchArray;\n            };\n            if (typeof win.TouchEvent === 'function') {\n                const newEvent = new win.TouchEvent(e.type, {\n                    touches: touchListToTouchArray(e.touches),\n                    targetTouches: touchListToTouchArray(e.targetTouches),\n                    changedTouches: touchListToTouchArray(e.changedTouches),\n                    ctrlKey: e.ctrlKey,\n                    shiftKey: e.shiftKey,\n                    altKey: e.altKey,\n                    metaKey: e.metaKey,\n                    bubbles: e.bubbles,\n                    cancelable: e.cancelable,\n                    composed: e.composed,\n                    detail: e.detail,\n                    view: e.view\n                });\n                if (e.defaultPrevented) {\n                    newEvent.preventDefault();\n                }\n                return newEvent;\n            }\n            const fakeEvt = cloneMouseEvent(e);\n            fakeEvt.touches = e.touches;\n            fakeEvt.changedTouches = e.changedTouches;\n            fakeEvt.targetTouches = e.targetTouches;\n            return fakeEvt;\n        }\n        /**\n         * @private\n         */\n        function escapeStringForHTML(str) {\n            return str\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n                .replace(/\"/g, '&quot;')\n                .replace(/'/g, '&#x27;')\n                .replace(/\\//g, '&#x2F;');\n        }\n        /**\n         * Get an element by ID\n         * @private\n         */\n        function getElement(id) {\n            return doc.getElementById(id);\n        }\n        /**\n         * Get a fake mouse event of a given type. If relatedTarget is not given,\n         * it will point to simulatedEventTarget, as an indicator that the event\n         * is fake.\n         * @private\n         */\n        function getFakeMouseEvent(type, position, relatedTarget) {\n            const pos = position || {\n                x: 0,\n                y: 0\n            };\n            if (typeof win.MouseEvent === 'function') {\n                return new win.MouseEvent(type, {\n                    bubbles: true,\n                    cancelable: true,\n                    composed: true,\n                    button: 0,\n                    buttons: 1,\n                    relatedTarget: relatedTarget || simulatedEventTarget,\n                    view: win,\n                    detail: type === 'click' ? 1 : 0,\n                    screenX: pos.x,\n                    screenY: pos.y,\n                    clientX: pos.x,\n                    clientY: pos.y\n                });\n            }\n            // No MouseEvent support, try using initMouseEvent\n            if (doc.createEvent) {\n                const evt = doc.createEvent('MouseEvent');\n                if (evt.initMouseEvent) {\n                    evt.initMouseEvent(type, true, // Bubble\n                    true, // Cancel\n                    win, // View\n                    type === 'click' ? 1 : 0, // Detail\n                    // Coords\n                    pos.x, pos.y, pos.x, pos.y, \n                    // Pressed keys\n                    false, false, false, false, 0, // button\n                    null // related target\n                    );\n                    return evt;\n                }\n            }\n            return { type: type };\n        }\n        /**\n         * Get an appropriate heading level for an element. Corresponds to the\n         * heading level below the previous heading in the DOM.\n         *\n         * Note: Only detects previous headings in the DOM that are siblings,\n         * ancestors, or previous siblings of ancestors. Headings that are nested below\n         * siblings of ancestors (cousins et.al) are not picked up. This is because it\n         * is ambiguous whether or not the nesting is for layout purposes or indicates a\n         * separate section.\n         *\n         * @private\n         * @param {Highcharts.HTMLDOMElement} [element]\n         * @return {string} The heading tag name (h1, h2 etc).\n         * If no nearest heading is found, \"p\" is returned.\n         */\n        function getHeadingTagNameForElement(element) {\n            const getIncreasedHeadingLevel = (tagName) => {\n                const headingLevel = parseInt(tagName.slice(1), 10), newLevel = Math.min(6, headingLevel + 1);\n                return 'h' + newLevel;\n            };\n            const isHeading = (tagName) => /H[1-6]/.test(tagName);\n            const getPreviousSiblingsHeading = (el) => {\n                let sibling = el;\n                while (sibling = sibling.previousSibling) { // eslint-disable-line\n                    const tagName = sibling.tagName || '';\n                    if (isHeading(tagName)) {\n                        return tagName;\n                    }\n                }\n                return '';\n            };\n            const getHeadingRecursive = (el) => {\n                const prevSiblingsHeading = getPreviousSiblingsHeading(el);\n                if (prevSiblingsHeading) {\n                    return getIncreasedHeadingLevel(prevSiblingsHeading);\n                }\n                // No previous siblings are headings, try parent node\n                const parent = el.parentElement;\n                if (!parent) {\n                    return 'p';\n                }\n                const parentTagName = parent.tagName;\n                if (isHeading(parentTagName)) {\n                    return getIncreasedHeadingLevel(parentTagName);\n                }\n                return getHeadingRecursive(parent);\n            };\n            return getHeadingRecursive(element);\n        }\n        /**\n         * Remove an element from the DOM.\n         * @private\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} [element]\n         * @return {void}\n         */\n        function removeElement(element) {\n            if (element && element.parentNode) {\n                element.parentNode.removeChild(element);\n            }\n        }\n        /**\n         * Remove all child nodes from an element.\n         * @private\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} [element]\n         * @return {void}\n         */\n        function removeChildNodes(element) {\n            while (element.lastChild) {\n                element.removeChild(element.lastChild);\n            }\n        }\n        /**\n         * Utility function. Reverses child nodes of a DOM element.\n         * @private\n         */\n        function reverseChildNodes(node) {\n            let i = node.childNodes.length;\n            while (i--) {\n                node.appendChild(node.childNodes[i]);\n            }\n        }\n        /**\n         * Used for aria-label attributes, painting on a canvas will fail if the\n         * text contains tags.\n         * @private\n         */\n        function stripHTMLTagsFromString(str) {\n            return typeof str === 'string' ?\n                str.replace(/<\\/?[^>]+(>|$)/g, '') : str;\n        }\n        /**\n         * Utility function for hiding an element visually, but still keeping it\n         * available to screen reader users.\n         * @private\n         */\n        function visuallyHideElement(element) {\n            css(element, {\n                position: 'absolute',\n                width: '1px',\n                height: '1px',\n                overflow: 'hidden',\n                whiteSpace: 'nowrap',\n                clip: 'rect(1px, 1px, 1px, 1px)',\n                marginTop: '-3px',\n                '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)',\n                filter: 'alpha(opacity=1)',\n                opacity: 0.01\n            });\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const HTMLUtilities = {\n            addClass,\n            cloneMouseEvent,\n            cloneTouchEvent,\n            escapeStringForHTML,\n            getElement,\n            getFakeMouseEvent,\n            getHeadingTagNameForElement,\n            removeChildNodes,\n            removeClass,\n            removeElement,\n            reverseChildNodes,\n            simulatedEventTarget,\n            stripHTMLTagsFromString,\n            visuallyHideElement\n        };\n\n        return HTMLUtilities;\n    });\n    _registerModule(_modules, 'Accessibility/A11yI18n.js', [_modules['Core/FormatUtilities.js'], _modules['Core/Utilities.js']], function (F, U) {\n        /* *\n         *\n         *  Accessibility module - internationalization support\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *  Author: ystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { format } = F;\n        const { getNestedProperty, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var A11yI18nComposition;\n        (function (A11yI18nComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.langFormat = langFormat;\n                }\n                return ChartClass;\n            }\n            A11yI18nComposition.compose = compose;\n            /**\n             * i18n utility function.  Format a single array or plural statement in a\n             * format string.  If the statement is not an array or plural statement,\n             * returns the statement within brackets.  Invalid array statements return\n             * an empty string.\n             *\n             * @private\n             * @function formatExtendedStatement\n             * @param {string} statement\n             * @param {Highcharts.Dictionary<*>} ctx\n             * Context to apply to the format string.\n             */\n            function formatExtendedStatement(statement, ctx) {\n                const eachStart = statement.indexOf('#each('), pluralStart = statement.indexOf('#plural('), indexStart = statement.indexOf('['), indexEnd = statement.indexOf(']');\n                let arr, result;\n                // Dealing with an each-function?\n                if (eachStart > -1) {\n                    const eachEnd = statement.slice(eachStart).indexOf(')') + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(',');\n                    let lenArg = Number(eachArguments[1]), len;\n                    result = '';\n                    arr = getNestedProperty(eachArguments[0], ctx);\n                    if (arr) {\n                        lenArg = isNaN(lenArg) ? arr.length : lenArg;\n                        len = lenArg < 0 ?\n                            arr.length + lenArg :\n                            Math.min(lenArg, arr.length); // Overshoot\n                        // Run through the array for the specified length\n                        for (let i = 0; i < len; ++i) {\n                            result += preEach + arr[i] + postEach;\n                        }\n                    }\n                    return result.length ? result : '';\n                }\n                // Dealing with a plural-function?\n                if (pluralStart > -1) {\n                    const pluralEnd = (statement.slice(pluralStart).indexOf(')') + pluralStart), pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(','), num = Number(getNestedProperty(pluralArguments[0], ctx));\n                    switch (num) {\n                        case 0:\n                            result = pick(pluralArguments[4], pluralArguments[1]);\n                            break;\n                        case 1:\n                            result = pick(pluralArguments[2], pluralArguments[1]);\n                            break;\n                        case 2:\n                            result = pick(pluralArguments[3], pluralArguments[1]);\n                            break;\n                        default:\n                            result = pluralArguments[1];\n                    }\n                    return result ? stringTrim(result) : '';\n                }\n                // Array index\n                if (indexStart > -1) {\n                    const arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd));\n                    let val;\n                    arr = getNestedProperty(arrayName, ctx);\n                    if (!isNaN(ix) && arr) {\n                        if (ix < 0) {\n                            val = arr[arr.length + ix];\n                            // Handle negative overshoot\n                            if (typeof val === 'undefined') {\n                                val = arr[0];\n                            }\n                        }\n                        else {\n                            val = arr[ix];\n                            // Handle positive overshoot\n                            if (typeof val === 'undefined') {\n                                val = arr[arr.length - 1];\n                            }\n                        }\n                    }\n                    return typeof val !== 'undefined' ? val : '';\n                }\n                // Standard substitution, delegate to format or similar\n                return '{' + statement + '}';\n            }\n            /* eslint-disable max-len */\n            /**\n             * i18n formatting function.  Extends Highcharts.format() functionality by\n             * also handling arrays and plural conditionals.  Arrays can be indexed as\n             * follows:\n             *\n             * - Format: 'This is the first index: {myArray[0]}. The last: {myArray[-1]}.'\n             *\n             * - Context: { myArray: [0, 1, 2, 3, 4, 5] }\n             *\n             * - Result: 'This is the first index: 0. The last: 5.'\n             *\n             *\n             * They can also be iterated using the #each() function.  This will repeat\n             * the contents of the bracket expression for each element.  Example:\n             *\n             * - Format: 'List contains: {#each(myArray)cm }'\n             *\n             * - Context: { myArray: [0, 1, 2] }\n             *\n             * - Result: 'List contains: 0cm 1cm 2cm '\n             *\n             *\n             * The #each() function optionally takes a length parameter.  If positive,\n             * this parameter specifies the max number of elements to iterate through.\n             * If negative, the function will subtract the number from the length of the\n             * array.  Use this to stop iterating before the array ends.  Example:\n             *\n             * - Format: 'List contains: {#each(myArray, -1) }and {myArray[-1]}.'\n             *\n             * - Context: { myArray: [0, 1, 2, 3] }\n             *\n             * - Result: 'List contains: 0, 1, 2, and 3.'\n             *\n             *\n             * Use the #plural() function to pick a string depending on whether or not a\n             * context object is 1.  Arguments are #plural(obj, plural, singular).\n             * Example:\n             *\n             * - Format: 'Has {numPoints} {#plural(numPoints, points, point}.'\n             *\n             * - Context: { numPoints: 5 }\n             *\n             * - Result: 'Has 5 points.'\n             *\n             *\n             * Optionally there are additional parameters for dual and none:\n             * #plural(obj, plural, singular, dual, none).  Example:\n             *\n             * - Format: 'Has {#plural(numPoints, many points, one point, two points,\n             *   none}.'\n             *\n             * - Context: { numPoints: 2 }\n             *\n             * - Result: 'Has two points.'\n             *\n             *\n             * The dual or none parameters will take precedence if they are supplied.\n             *\n             * @requires modules/accessibility\n             *\n             * @function Highcharts.i18nFormat\n             *\n             * @param {string} formatString\n             * The string to format.\n             *\n             * @param {Highcharts.Dictionary<*>} context\n             * Context to apply to the format string.\n             *\n             * @param {Highcharts.Chart} chart\n             * A `Chart` instance with a time object and numberFormatter, passed on to\n             * format().\n             *\n             * @return {string}\n             * The formatted string.\n             */\n            function i18nFormat(formatString, context, chart) {\n                const getFirstBracketStatement = (sourceStr, offset) => {\n                    const str = sourceStr.slice(offset || 0), startBracket = str.indexOf('{'), endBracket = str.indexOf('}');\n                    if (startBracket > -1 && endBracket > startBracket) {\n                        return {\n                            statement: str.substring(startBracket + 1, endBracket),\n                            begin: offset + startBracket + 1,\n                            end: offset + endBracket\n                        };\n                    }\n                }, tokens = [];\n                let bracketRes, constRes, cursor = 0;\n                // Tokenize format string into bracket statements and constants\n                do {\n                    bracketRes = getFirstBracketStatement(formatString, cursor);\n                    constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);\n                    // If we have constant content before this bracket statement, add it\n                    if (constRes.length) {\n                        tokens.push({\n                            value: constRes,\n                            type: 'constant'\n                        });\n                    }\n                    // Add the bracket statement\n                    if (bracketRes) {\n                        tokens.push({\n                            value: bracketRes.statement,\n                            type: 'statement'\n                        });\n                    }\n                    cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;\n                } while (bracketRes);\n                // Perform the formatting.  The formatArrayStatement function returns\n                // the statement in brackets if it is not an array statement, which\n                // means it gets picked up by format below.\n                tokens.forEach((token) => {\n                    if (token.type === 'statement') {\n                        token.value = formatExtendedStatement(token.value, context);\n                    }\n                });\n                // Join string back together and pass to format to pick up non-array\n                // statements.\n                return format(tokens.reduce((acc, cur) => acc + cur.value, ''), context, chart);\n            }\n            A11yI18nComposition.i18nFormat = i18nFormat;\n            /* eslint-enable max-len */\n            /**\n             * Apply context to a format string from lang options of the chart.\n             *\n             * @requires modules/accessibility\n             *\n             * @function Highcharts.Chart#langFormat\n             *\n             * @param {string} langKey\n             * Key (using dot notation) into lang option structure.\n             *\n             * @param {Highcharts.Dictionary<*>} context\n             * Context to apply to the format string.\n             *\n             * @return {string}\n             * The formatted string.\n             */\n            function langFormat(langKey, context) {\n                const keys = langKey.split('.');\n                let formatString = this.options.lang, i = 0;\n                for (; i < keys.length; ++i) {\n                    formatString = formatString && formatString[keys[i]];\n                }\n                return typeof formatString === 'string' ?\n                    i18nFormat(formatString, context, this) : '';\n            }\n            /**\n             * @private\n             * @function stringTrim\n             *\n             * @param {string} str\n             * The input string\n             *\n             * @return {string}\n             * The trimmed string\n             */\n            function stringTrim(str) {\n                return str.trim && str.trim() || str.replace(/^\\s+|\\s+$/g, '');\n            }\n        })(A11yI18nComposition || (A11yI18nComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return A11yI18nComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/ChartUtilities.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Utils for dealing with charts.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { stripHTMLTagsFromString: stripHTMLTags } = HU;\n        const { defined, find, fireEvent } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Fire an event on an element that is either wrapped by Highcharts,\n         * or a DOM element.\n         * @private\n         */\n        function fireEventOnWrappedOrUnwrappedElement(el, eventObject) {\n            const type = eventObject.type;\n            const hcEvents = el.hcEvents;\n            if ((doc.createEvent) &&\n                (el.dispatchEvent || el.fireEvent)) {\n                if (el.dispatchEvent) {\n                    el.dispatchEvent(eventObject);\n                }\n                else {\n                    el.fireEvent(type, eventObject);\n                }\n            }\n            else if (hcEvents && hcEvents[type]) {\n                fireEvent(el, type, eventObject);\n            }\n            else if (el.element) {\n                fireEventOnWrappedOrUnwrappedElement(el.element, eventObject);\n            }\n        }\n        /**\n         * @private\n         */\n        function getChartTitle(chart) {\n            return stripHTMLTags(chart.options.title.text ||\n                chart.langFormat('accessibility.defaultChartTitle', { chart: chart }));\n        }\n        /**\n         * Return string with the axis name/title.\n         * @private\n         */\n        function getAxisDescription(axis) {\n            return axis && (axis.userOptions && axis.userOptions.accessibility &&\n                axis.userOptions.accessibility.description ||\n                axis.axisTitle && axis.axisTitle.textStr ||\n                axis.options.id ||\n                axis.categories && 'categories' ||\n                axis.dateTime && 'Time' ||\n                'values');\n        }\n        /**\n         * Return string with text description of the axis range.\n         * @private\n         * @param {Highcharts.Axis} axis\n         * The axis to get range desc of.\n         * @return {string}\n         * A string with the range description for the axis.\n         */\n        function getAxisRangeDescription(axis) {\n            const axisOptions = axis.options || {};\n            // Handle overridden range description\n            if (axisOptions.accessibility &&\n                typeof axisOptions.accessibility.rangeDescription !== 'undefined') {\n                return axisOptions.accessibility.rangeDescription;\n            }\n            // Handle category axes\n            if (axis.categories) {\n                return getCategoryAxisRangeDesc(axis);\n            }\n            // Use time range, not from-to?\n            if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {\n                return getAxisTimeLengthDesc(axis);\n            }\n            // Just use from and to.\n            // We have the range and the unit to use, find the desc format\n            return getAxisFromToDescription(axis);\n        }\n        /**\n         * Describe the range of a category axis.\n         * @private\n         */\n        function getCategoryAxisRangeDesc(axis) {\n            const chart = axis.chart;\n            if (axis.dataMax && axis.dataMin) {\n                return chart.langFormat('accessibility.axis.rangeCategories', {\n                    chart: chart,\n                    axis: axis,\n                    numCategories: axis.dataMax - axis.dataMin + 1\n                });\n            }\n            return '';\n        }\n        /**\n         * Describe the length of the time window shown on an axis.\n         * @private\n         */\n        function getAxisTimeLengthDesc(axis) {\n            const chart = axis.chart, range = {}, min = axis.dataMin || axis.min || 0, max = axis.dataMax || axis.max || 0;\n            let rangeUnit = 'Seconds';\n            range.Seconds = (max - min) / 1000;\n            range.Minutes = range.Seconds / 60;\n            range.Hours = range.Minutes / 60;\n            range.Days = range.Hours / 24;\n            ['Minutes', 'Hours', 'Days'].forEach(function (unit) {\n                if (range[unit] > 2) {\n                    rangeUnit = unit;\n                }\n            });\n            const rangeValue = range[rangeUnit].toFixed(rangeUnit !== 'Seconds' &&\n                rangeUnit !== 'Minutes' ? 1 : 0 // Use decimals for days/hours\n            );\n            // We have the range and the unit to use, find the desc format\n            return chart.langFormat('accessibility.axis.timeRange' + rangeUnit, {\n                chart: chart,\n                axis: axis,\n                range: rangeValue.replace('.0', '')\n            });\n        }\n        /**\n         * Describe an axis from-to range.\n         * @private\n         */\n        function getAxisFromToDescription(axis) {\n            const chart = axis.chart, options = chart.options, dateRangeFormat = (options &&\n                options.accessibility &&\n                options.accessibility.screenReaderSection.axisRangeDateFormat ||\n                ''), extremes = {\n                min: axis.dataMin || axis.min || 0,\n                max: axis.dataMax || axis.max || 0\n            }, format = function (key) {\n                return axis.dateTime ?\n                    chart.time.dateFormat(dateRangeFormat, extremes[key]) :\n                    extremes[key].toString();\n            };\n            return chart.langFormat('accessibility.axis.rangeFromTo', {\n                chart: chart,\n                axis: axis,\n                rangeFrom: format('min'),\n                rangeTo: format('max')\n            });\n        }\n        /**\n         * Get the DOM element for the first point in the series.\n         * @private\n         * @param {Highcharts.Series} series\n         * The series to get element for.\n         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement|undefined}\n         * The DOM element for the point.\n         */\n        function getSeriesFirstPointElement(series) {\n            if (series.points && series.points.length) {\n                const firstPointWithGraphic = find(series.points, (p) => !!p.graphic);\n                return (firstPointWithGraphic &&\n                    firstPointWithGraphic.graphic &&\n                    firstPointWithGraphic.graphic.element);\n            }\n        }\n        /**\n         * Get the DOM element for the series that we put accessibility info on.\n         * @private\n         * @param {Highcharts.Series} series\n         * The series to get element for.\n         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement|undefined}\n         * The DOM element for the series\n         */\n        function getSeriesA11yElement(series) {\n            const firstPointEl = getSeriesFirstPointElement(series);\n            return (firstPointEl &&\n                firstPointEl.parentNode || series.graph &&\n                series.graph.element || series.group &&\n                series.group.element); // Could be tracker series depending on series type\n        }\n        /**\n         * Remove aria-hidden from element. Also unhides parents of the element, and\n         * hides siblings that are not explicitly unhidden.\n         * @private\n         */\n        function unhideChartElementFromAT(chart, element) {\n            element.setAttribute('aria-hidden', false);\n            if (element === chart.renderTo ||\n                !element.parentNode ||\n                element.parentNode === doc.body // #16126: Full screen printing\n            ) {\n                return;\n            }\n            // Hide siblings unless their hidden state is already explicitly set\n            Array.prototype.forEach.call(element.parentNode.childNodes, function (node) {\n                if (!node.hasAttribute('aria-hidden')) {\n                    node.setAttribute('aria-hidden', true);\n                }\n            });\n            // Repeat for parent\n            unhideChartElementFromAT(chart, element.parentNode);\n        }\n        /**\n         * Hide series from screen readers.\n         * @private\n         */\n        function hideSeriesFromAT(series) {\n            const seriesEl = getSeriesA11yElement(series);\n            if (seriesEl) {\n                seriesEl.setAttribute('aria-hidden', true);\n            }\n        }\n        /**\n         * Get series objects by series name.\n         * @private\n         */\n        function getSeriesFromName(chart, name) {\n            if (!name) {\n                return chart.series;\n            }\n            return (chart.series || []).filter(function (s) {\n                return s.name === name;\n            });\n        }\n        /**\n         * Get point in a series from x/y values.\n         * @private\n         */\n        function getPointFromXY(series, x, y) {\n            let i = series.length, res;\n            while (i--) {\n                res = find(series[i].points || [], function (p) {\n                    return p.x === x && p.y === y;\n                });\n                if (res) {\n                    return res;\n                }\n            }\n        }\n        /**\n         * Get relative position of point on an x/y axis from 0 to 1.\n         * @private\n         */\n        function getRelativePointAxisPosition(axis, point) {\n            if (!defined(axis.dataMin) || !defined(axis.dataMax)) {\n                return 0;\n            }\n            const axisStart = axis.toPixels(axis.dataMin), axisEnd = axis.toPixels(axis.dataMax), \n            // We have to use pixel position because of axis breaks, log axis etc.\n            positionProp = axis.coll === 'xAxis' ? 'x' : 'y', pointPos = axis.toPixels(point[positionProp] || 0);\n            return (pointPos - axisStart) / (axisEnd - axisStart);\n        }\n        /**\n         * Get relative position of point on an x/y axis from 0 to 1.\n         * @private\n         */\n        function scrollToPoint(point) {\n            const xAxis = point.series.xAxis, yAxis = point.series.yAxis, axis = (xAxis && xAxis.scrollbar ? xAxis : yAxis), scrollbar = (axis && axis.scrollbar);\n            if (scrollbar && defined(scrollbar.to) && defined(scrollbar.from)) {\n                const range = scrollbar.to - scrollbar.from;\n                const pos = getRelativePointAxisPosition(axis, point);\n                scrollbar.updatePosition(pos - range / 2, pos + range / 2);\n                fireEvent(scrollbar, 'changed', {\n                    from: scrollbar.from,\n                    to: scrollbar.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: null\n                });\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ChartUtilities = {\n            fireEventOnWrappedOrUnwrappedElement,\n            getChartTitle,\n            getAxisDescription,\n            getAxisRangeDescription,\n            getPointFromXY,\n            getSeriesFirstPointElement,\n            getSeriesFromName,\n            getSeriesA11yElement,\n            unhideChartElementFromAT,\n            hideSeriesFromAT,\n            scrollToPoint\n        };\n\n        return ChartUtilities;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/DOMElementProvider.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Class that can keep track of elements added to DOM and clean them up on\n         *  destroy.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { removeElement } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         */\n        class DOMElementProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor() {\n                this.elements = [];\n            }\n            /**\n             * Create an element and keep track of it for later removal.\n             * Same args as document.createElement\n             * @private\n             */\n            createElement() {\n                const el = doc.createElement.apply(doc, arguments);\n                this.elements.push(el);\n                return el;\n            }\n            /**\n             * Destroy all created elements, removing them from the DOM.\n             * @private\n             */\n            destroyCreatedElements() {\n                this.elements.forEach(function (element) {\n                    removeElement(element);\n                });\n                this.elements = [];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DOMElementProvider;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/EventProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Class that can keep track of events added, and clean them up on destroy.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         */\n        class EventProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor() {\n                this.eventRemovers = [];\n            }\n            /**\n             * Add an event to an element and keep track of it for later removal.\n             * Same args as Highcharts.addEvent.\n             * @private\n             */\n            addEvent() {\n                const remover = addEvent.apply(H, arguments);\n                this.eventRemovers.push(remover);\n                return remover;\n            }\n            /**\n             * Remove all added events.\n             * @private\n             */\n            removeAddedEvents() {\n                this.eventRemovers.forEach((remover) => remover());\n                this.eventRemovers = [];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return EventProvider;\n    });\n    _registerModule(_modules, 'Accessibility/AccessibilityComponent.js', [_modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (CU, DOMElementProvider, EventProvider, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component class definition\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { fireEventOnWrappedOrUnwrappedElement } = CU;\n        const { getFakeMouseEvent } = HU;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The AccessibilityComponent base class, representing a part of the chart that\n         * has accessibility logic connected to it. This class can be inherited from to\n         * create a custom accessibility component for a chart.\n         *\n         * Components should take care to destroy added elements and unregister event\n         * handlers on destroy. This is handled automatically if using this.addEvent and\n         * this.createElement.\n         *\n         * @sample highcharts/accessibility/custom-component\n         *         Custom accessibility component\n         *\n         * @requires module:modules/accessibility\n         * @class\n         * @name Highcharts.AccessibilityComponent\n         */\n        class AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.domElementProvider = void 0;\n                this.eventProvider = void 0;\n                this.keyCodes = void 0;\n                this.proxyProvider = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the class\n             * @private\n             * @param {Highcharts.Chart} chart The chart object\n             * @param {Highcharts.ProxyProvider} proxyProvider The proxy provider of the accessibility module\n             */\n            initBase(chart, proxyProvider) {\n                this.chart = chart;\n                this.eventProvider = new EventProvider();\n                this.domElementProvider = new DOMElementProvider();\n                this.proxyProvider = proxyProvider;\n                // Key code enum for common keys\n                this.keyCodes = {\n                    left: 37,\n                    right: 39,\n                    up: 38,\n                    down: 40,\n                    enter: 13,\n                    space: 32,\n                    esc: 27,\n                    tab: 9,\n                    pageUp: 33,\n                    pageDown: 34,\n                    end: 35,\n                    home: 36\n                };\n            }\n            /**\n             * Add an event to an element and keep track of it for later removal.\n             * See EventProvider for details.\n             * @private\n             */\n            addEvent(el, type, fn, options) {\n                return this.eventProvider.addEvent(el, type, fn, options);\n            }\n            /**\n             * Create an element and keep track of it for later removal.\n             * See DOMElementProvider for details.\n             * @private\n             */\n            createElement(tagName, options) {\n                return this.domElementProvider.createElement(tagName, options);\n            }\n            /**\n             * Fire a fake click event on an element. It is useful to have this on\n             * AccessibilityComponent for users of custom components.\n             */\n            fakeClickEvent(el) {\n                const fakeEvent = getFakeMouseEvent('click');\n                fireEventOnWrappedOrUnwrappedElement(el, fakeEvent);\n            }\n            /**\n             * Remove traces of the component.\n             * @private\n             */\n            destroyBase() {\n                this.domElementProvider.destroyCreatedElements();\n                this.eventProvider.removeAddedEvents();\n            }\n        }\n        extend(AccessibilityComponent.prototype, \n        /** @lends Highcharts.AccessibilityComponent */\n        {\n            /**\n             * Called on component initialization.\n             */\n            init() { },\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation: function () { },\n            /**\n             * Called on updates to the chart, including options changes.\n             * Note that this is also called on first render of chart.\n             */\n            onChartUpdate() { },\n            /**\n             * Called on every chart render.\n             */\n            onChartRender() { },\n            /**\n             * Called when accessibility is disabled or chart is destroyed.\n             */\n            destroy() { }\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AccessibilityComponent;\n    });\n    _registerModule(_modules, 'Accessibility/KeyboardNavigationHandler.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Keyboard navigation handler base class definition\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { find } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Define a keyboard navigation handler for use with a\n         * Highcharts.AccessibilityComponent instance. This functions as an abstraction\n         * layer for keyboard navigation, and defines a map of keyCodes to handler\n         * functions.\n         *\n         * @requires module:modules/accessibility\n         *\n         * @sample highcharts/accessibility/custom-component\n         *         Custom accessibility component\n         *\n         * @class\n         * @name Highcharts.KeyboardNavigationHandler\n         *\n         * @param {Highcharts.Chart} chart\n         * The chart this module should act on.\n         *\n         * @param {Highcharts.KeyboardNavigationHandlerOptionsObject} options\n         * Options for the keyboard navigation handler.\n         */\n        class KeyboardNavigationHandler {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, options) {\n                this.chart = chart;\n                this.keyCodeMap = options.keyCodeMap || [];\n                this.validate = options.validate;\n                this.init = options.init;\n                this.terminate = options.terminate;\n                // Response enum\n                this.response = {\n                    success: 1,\n                    prev: 2,\n                    next: 3,\n                    noHandler: 4,\n                    fail: 5 // Handler failed\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Find handler function(s) for key code in the keyCodeMap and run it.\n             *\n             * @function KeyboardNavigationHandler#run\n             * @param {global.KeyboardEvent} e\n             * @return {number} Returns a response code indicating whether the run was\n             *      a success/fail/unhandled, or if we should move to next/prev module.\n             */\n            run(e) {\n                const keyCode = e.which || e.keyCode;\n                let response = this.response.noHandler;\n                const handlerCodeSet = find(this.keyCodeMap, function (codeSet) {\n                    return codeSet[0].indexOf(keyCode) > -1;\n                });\n                if (handlerCodeSet) {\n                    response = handlerCodeSet[1].call(this, keyCode, e);\n                }\n                else if (keyCode === 9) {\n                    // Default tab handler, move to next/prev module\n                    response = this.response[e.shiftKey ? 'prev' : 'next'];\n                }\n                return response;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Options for the keyboard navigation handler.\n         *\n         * @interface Highcharts.KeyboardNavigationHandlerOptionsObject\n         */ /**\n        * An array containing pairs of an array of keycodes, mapped to a handler\n        * function. When the keycode is received, the handler is called with the\n        * keycode as parameter.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#keyCodeMap\n        * @type {Array<Array<Array<number>, Function>>}\n        */ /**\n        * Function to run on initialization of module.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#init\n        * @type {Function}\n        */ /**\n        * Function to run before moving to next/prev module. Receives moving direction\n        * as parameter: +1 for next, -1 for previous.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#terminate\n        * @type {Function|undefined}\n        */ /**\n        * Function to run to validate module. Should return false if module should not\n        * run, true otherwise. Receives chart as parameter.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#validate\n        * @type {Function|undefined}\n        */\n        (''); // keeps doclets above in JS file\n\n        return KeyboardNavigationHandler;\n    });\n    _registerModule(_modules, 'Accessibility/Components/ContainerComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (AccessibilityComponent, KeyboardNavigationHandler, CU, H, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for chart container.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT, getChartTitle } = CU;\n        const { doc } = H;\n        const { stripHTMLTagsFromString: stripHTMLTags } = HU;\n        /**\n         * The ContainerComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.ContainerComponent\n         */\n        class ContainerComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Called on first render/updates to the chart, including options changes.\n             */\n            onChartUpdate() {\n                this.handleSVGTitleElement();\n                this.setSVGContainerLabel();\n                this.setGraphicContainerAttrs();\n                this.setRenderToAttrs();\n                this.makeCreditsAccessible();\n            }\n            /**\n             * @private\n             */\n            handleSVGTitleElement() {\n                const chart = this.chart, titleId = 'highcharts-title-' + chart.index, titleContents = stripHTMLTags(chart.langFormat('accessibility.svgContainerTitle', {\n                    chartTitle: getChartTitle(chart)\n                }));\n                if (titleContents.length) {\n                    const titleElement = this.svgTitleElement =\n                        this.svgTitleElement || doc.createElementNS('http://www.w3.org/2000/svg', 'title');\n                    titleElement.textContent = titleContents;\n                    titleElement.id = titleId;\n                    chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);\n                }\n            }\n            /**\n             * @private\n             */\n            setSVGContainerLabel() {\n                const chart = this.chart, svgContainerLabel = chart.langFormat('accessibility.svgContainerLabel', {\n                    chartTitle: getChartTitle(chart)\n                });\n                if (chart.renderer.box && svgContainerLabel.length) {\n                    chart.renderer.box.setAttribute('aria-label', svgContainerLabel);\n                }\n            }\n            /**\n             * @private\n             */\n            setGraphicContainerAttrs() {\n                const chart = this.chart, label = chart.langFormat('accessibility.graphicContainerLabel', {\n                    chartTitle: getChartTitle(chart)\n                });\n                if (label.length) {\n                    chart.container.setAttribute('aria-label', label);\n                }\n            }\n            /**\n             * Set attributes on the chart container element.\n             * @private\n             */\n            setRenderToAttrs() {\n                const chart = this.chart, shouldHaveLandmark = chart.options.accessibility\n                    .landmarkVerbosity !== 'disabled', containerLabel = chart.langFormat('accessibility.chartContainerLabel', {\n                    title: getChartTitle(chart),\n                    chart: chart\n                });\n                if (containerLabel) {\n                    chart.renderTo.setAttribute('role', shouldHaveLandmark ? 'region' : 'group');\n                    chart.renderTo.setAttribute('aria-label', containerLabel);\n                }\n            }\n            /**\n             * @private\n             */\n            makeCreditsAccessible() {\n                const chart = this.chart, credits = chart.credits;\n                if (credits) {\n                    if (credits.textStr) {\n                        credits.element.setAttribute('aria-label', chart.langFormat('accessibility.credits', { creditsStr: stripHTMLTags(credits.textStr) }));\n                    }\n                    unhideChartElementFromAT(chart, credits.element);\n                }\n            }\n            /**\n             * Empty handler to just set focus on chart\n             * @private\n             */\n            getKeyboardNavigation() {\n                const chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [],\n                    validate: function () {\n                        return true;\n                    },\n                    init: function () {\n                        const a11y = chart.accessibility;\n                        if (a11y) {\n                            a11y.keyboardNavigation.tabindexContainer.focus();\n                        }\n                    }\n                });\n            }\n            /**\n             * Accessibility disabled/chart destroyed.\n             */\n            destroy() {\n                this.chart.renderTo.setAttribute('aria-hidden', true);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ContainerComponent;\n    });\n    _registerModule(_modules, 'Accessibility/FocusBorder.js', [_modules['Core/Renderer/SVG/SVGLabel.js'], _modules['Core/Utilities.js']], function (SVGLabel, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Extend SVG and Chart classes with focus border capabilities.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var FocusBorderComposition;\n        (function (FocusBorderComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            // Attributes that trigger a focus border update\n            const svgElementBorderUpdateTriggers = [\n                'x', 'y', 'transform', 'width', 'height', 'r', 'd', 'stroke-width'\n            ];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass, SVGElementClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.renderFocusBorder = chartRenderFocusBorder;\n                    chartProto.setFocusToElement = chartSetFocusToElement;\n                }\n                if (U.pushUnique(composedMembers, SVGElementClass)) {\n                    const svgElementProto = SVGElementClass.prototype;\n                    svgElementProto.addFocusBorder = svgElementAddFocusBorder;\n                    svgElementProto.removeFocusBorder = svgElementRemoveFocusBorder;\n                }\n            }\n            FocusBorderComposition.compose = compose;\n            /**\n             * Redraws the focus border on the currently focused element.\n             *\n             * @private\n             * @function Highcharts.Chart#renderFocusBorder\n             */\n            function chartRenderFocusBorder() {\n                const focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;\n                if (focusElement) {\n                    focusElement.removeFocusBorder();\n                    if (focusBorderOptions.enabled) {\n                        focusElement.addFocusBorder(focusBorderOptions.margin, {\n                            stroke: focusBorderOptions.style.color,\n                            strokeWidth: focusBorderOptions.style.lineWidth,\n                            r: focusBorderOptions.style.borderRadius\n                        });\n                    }\n                }\n            }\n            /**\n             * Set chart's focus to an SVGElement. Calls focus() on it, and draws the\n             * focus border. This is used by multiple components.\n             *\n             * @private\n             * @function Highcharts.Chart#setFocusToElement\n             *\n             * @param {Highcharts.SVGElement} svgElement\n             * Element to draw the border around.\n             *\n             * @param {SVGDOMElement|HTMLDOMElement} [focusElement]\n             * If supplied, it draws the border around svgElement and sets the focus to\n             * focusElement.\n             */\n            function chartSetFocusToElement(svgElement, focusElement) {\n                const focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;\n                // Set browser focus if possible\n                if (browserFocusElement &&\n                    browserFocusElement.focus) {\n                    // If there is no focusin-listener, add one to work around Edge\n                    // where Narrator is not reading out points despite calling focus().\n                    if (!(browserFocusElement.hcEvents &&\n                        browserFocusElement.hcEvents.focusin)) {\n                        addEvent(browserFocusElement, 'focusin', function () { });\n                    }\n                    browserFocusElement.focus();\n                    // Hide default focus ring\n                    if (focusBorderOptions.hideBrowserFocusOutline) {\n                        browserFocusElement.style.outline = 'none';\n                    }\n                }\n                if (this.focusElement) {\n                    this.focusElement.removeFocusBorder();\n                }\n                this.focusElement = svgElement;\n                this.renderFocusBorder();\n            }\n            /**\n             * Add hook to destroy focus border if SVG element is destroyed, unless\n             * hook already exists.\n             * @private\n             * @param el Element to add destroy hook to\n             */\n            function svgElementAddDestroyFocusBorderHook(el) {\n                if (el.focusBorderDestroyHook) {\n                    return;\n                }\n                const origDestroy = el.destroy;\n                el.destroy = function () {\n                    if (el.focusBorder && el.focusBorder.destroy) {\n                        el.focusBorder.destroy();\n                    }\n                    return origDestroy.apply(el, arguments);\n                };\n                el.focusBorderDestroyHook = origDestroy;\n            }\n            /**\n             * Add focus border functionality to SVGElements. Draws a new rect on top of\n             * element around its bounding box. This is used by multiple components.\n             *\n             * @private\n             * @function Highcharts.SVGElement#addFocusBorder\n             *\n             * @param {number} margin\n             *\n             * @param {SVGAttributes} attribs\n             */\n            function svgElementAddFocusBorder(margin, attribs) {\n                // Allow updating by just adding new border\n                if (this.focusBorder) {\n                    this.removeFocusBorder();\n                }\n                // Add the border rect\n                const bb = this.getBBox(), pad = pick(margin, 3), parent = this.parentGroup, scaleX = this.scaleX || parent && parent.scaleX, scaleY = this.scaleY || parent && parent.scaleY, oneDefined = scaleX ? !scaleY : scaleY, scaleBoth = oneDefined ? Math.abs(scaleX || scaleY || 1) :\n                    (Math.abs(scaleX || 1) + Math.abs(scaleY || 1)) / 2;\n                bb.x += this.translateX ? this.translateX : 0;\n                bb.y += this.translateY ? this.translateY : 0;\n                let borderPosX = bb.x - pad, borderPosY = bb.y - pad, borderWidth = bb.width + 2 * pad, borderHeight = bb.height + 2 * pad;\n                /**\n                 * For text elements, apply x and y offset, #11397.\n                 * @private\n                 */\n                function getTextAnchorCorrection(text) {\n                    let posXCorrection = 0, posYCorrection = 0;\n                    if (text.attr('text-anchor') === 'middle') {\n                        posXCorrection = posYCorrection = 0.5;\n                    }\n                    else if (!text.rotation) {\n                        posYCorrection = 0.75;\n                    }\n                    else {\n                        posXCorrection = 0.25;\n                    }\n                    return {\n                        x: posXCorrection,\n                        y: posYCorrection\n                    };\n                }\n                const isLabel = this instanceof SVGLabel;\n                if (this.element.nodeName === 'text' || isLabel) {\n                    const isRotated = !!this.rotation;\n                    const correction = !isLabel ? getTextAnchorCorrection(this) :\n                        {\n                            x: isRotated ? 1 : 0,\n                            y: 0\n                        };\n                    const attrX = +this.attr('x');\n                    const attrY = +this.attr('y');\n                    if (!isNaN(attrX)) {\n                        borderPosX = attrX - (bb.width * correction.x) - pad;\n                    }\n                    if (!isNaN(attrY)) {\n                        borderPosY = attrY - (bb.height * correction.y) - pad;\n                    }\n                    if (isLabel && isRotated) {\n                        const temp = borderWidth;\n                        borderWidth = borderHeight;\n                        borderHeight = temp;\n                        if (!isNaN(attrX)) {\n                            borderPosX = attrX - (bb.height * correction.x) - pad;\n                        }\n                        if (!isNaN(attrY)) {\n                            borderPosY = attrY - (bb.width * correction.y) - pad;\n                        }\n                    }\n                }\n                this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10) / scaleBoth)\n                    .addClass('highcharts-focus-border')\n                    .attr({\n                    zIndex: 99\n                })\n                    .add(parent);\n                if (!this.renderer.styledMode) {\n                    this.focusBorder.attr({\n                        stroke: attribs && attribs.stroke,\n                        'stroke-width': (attribs && attribs.strokeWidth || 0) / scaleBoth\n                    });\n                }\n                avgElementAddUpdateFocusBorderHooks(this, margin, attribs);\n                svgElementAddDestroyFocusBorderHook(this);\n            }\n            /**\n             * Add hooks to update the focus border of an element when the element\n             * size/position is updated, unless already added.\n             * @private\n             * @param el Element to add update hooks to\n             * @param updateParams Parameters to pass through to addFocusBorder when updating.\n             */\n            function avgElementAddUpdateFocusBorderHooks(el, ...updateParams) {\n                if (el.focusBorderUpdateHooks) {\n                    return;\n                }\n                el.focusBorderUpdateHooks = {};\n                svgElementBorderUpdateTriggers.forEach((trigger) => {\n                    const setterKey = trigger + 'Setter';\n                    const origSetter = el[setterKey] || el._defaultSetter;\n                    el.focusBorderUpdateHooks[setterKey] = origSetter;\n                    el[setterKey] = function () {\n                        const ret = origSetter.apply(el, arguments);\n                        el.addFocusBorder.apply(el, updateParams);\n                        return ret;\n                    };\n                });\n            }\n            /**\n             * Remove hook from SVG element added by addDestroyFocusBorderHook, if\n             * existing.\n             * @private\n             * @param el Element to remove destroy hook from\n             */\n            function svgElementRemoveDestroyFocusBorderHook(el) {\n                if (!el.focusBorderDestroyHook) {\n                    return;\n                }\n                el.destroy = el.focusBorderDestroyHook;\n                delete el.focusBorderDestroyHook;\n            }\n            /**\n             * Add focus border functionality to SVGElements. Draws a new rect on top of\n             * element around its bounding box. This is used by multiple components.\n             * @private\n             * @function Highcharts.SVGElement#removeFocusBorder\n             */\n            function svgElementRemoveFocusBorder() {\n                svgElementRemoveUpdateFocusBorderHooks(this);\n                svgElementRemoveDestroyFocusBorderHook(this);\n                if (this.focusBorder) {\n                    this.focusBorder.destroy();\n                    delete this.focusBorder;\n                }\n            }\n            /**\n             * Remove hooks from SVG element added by addUpdateFocusBorderHooks, if\n             * existing.\n             * @private\n             * @param el Element to remove update hooks from\n             */\n            function svgElementRemoveUpdateFocusBorderHooks(el) {\n                if (!el.focusBorderUpdateHooks) {\n                    return;\n                }\n                Object.keys(el.focusBorderUpdateHooks).forEach((setterKey) => {\n                    const origSetter = el.focusBorderUpdateHooks[setterKey];\n                    if (origSetter === el._defaultSetter) {\n                        delete el[setterKey];\n                    }\n                    else {\n                        el[setterKey] = origSetter;\n                    }\n                });\n                delete el.focusBorderUpdateHooks;\n            }\n        })(FocusBorderComposition || (FocusBorderComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return FocusBorderComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/Announcer.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (AST, DOMElementProvider, H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Create announcer to speak messages to screen readers and other AT.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { addClass, visuallyHideElement } = HU;\n        const { attr } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Announcer {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, type) {\n                this.chart = chart;\n                this.domElementProvider = new DOMElementProvider();\n                this.announceRegion = this.addAnnounceRegion(type);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            destroy() {\n                this.domElementProvider.destroyCreatedElements();\n            }\n            announce(message) {\n                AST.setElementHTML(this.announceRegion, message);\n                // Delete contents after a little while to avoid user finding the live\n                // region in the DOM.\n                if (this.clearAnnouncementRegionTimer) {\n                    clearTimeout(this.clearAnnouncementRegionTimer);\n                }\n                this.clearAnnouncementRegionTimer = setTimeout(() => {\n                    this.announceRegion.innerHTML = AST.emptyHTML;\n                    delete this.clearAnnouncementRegionTimer;\n                }, 1000);\n            }\n            addAnnounceRegion(type) {\n                const chartContainer = (this.chart.announcerContainer || this.createAnnouncerContainer()), div = this.domElementProvider.createElement('div');\n                attr(div, {\n                    'aria-hidden': false,\n                    'aria-live': type\n                });\n                if (this.chart.styledMode) {\n                    addClass(div, 'highcharts-visually-hidden');\n                }\n                else {\n                    visuallyHideElement(div);\n                }\n                chartContainer.appendChild(div);\n                return div;\n            }\n            createAnnouncerContainer() {\n                const chart = this.chart, container = doc.createElement('div');\n                attr(container, {\n                    'aria-hidden': false,\n                    'class': 'highcharts-announcer-container'\n                });\n                container.style.position = 'relative';\n                chart.renderTo.insertBefore(container, chart.renderTo.firstChild);\n                chart.announcerContainer = container;\n                return container;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Announcer;\n    });\n    _registerModule(_modules, 'Accessibility/Components/AnnotationsA11y.js', [_modules['Accessibility/Utils/HTMLUtilities.js']], function (HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Annotations accessibility code.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { escapeStringForHTML, stripHTMLTagsFromString } = HTMLUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get list of all annotation labels in the chart.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {Array<object>} The labels, or empty array if none.\n         */\n        function getChartAnnotationLabels(chart) {\n            const annotations = chart.annotations || [];\n            return annotations.reduce((acc, cur) => {\n                if (cur.options &&\n                    cur.options.visible !== false) {\n                    acc = acc.concat(cur.labels);\n                }\n                return acc;\n            }, []);\n        }\n        /**\n         * Get the text of an annotation label.\n         *\n         * @private\n         * @param {Object} label The annotation label object\n         * @return {string} The text in the label.\n         */\n        function getLabelText(label) {\n            return ((label.options &&\n                label.options.accessibility &&\n                label.options.accessibility.description) ||\n                (label.graphic &&\n                    label.graphic.text &&\n                    label.graphic.text.textStr) ||\n                '');\n        }\n        /**\n         * Describe an annotation label.\n         *\n         * @private\n         * @param {Object} label The annotation label object to describe\n         * @return {string} The description for the label.\n         */\n        function getAnnotationLabelDescription(label) {\n            const a11yDesc = (label.options &&\n                label.options.accessibility &&\n                label.options.accessibility.description);\n            if (a11yDesc) {\n                return a11yDesc;\n            }\n            const chart = label.chart;\n            const labelText = getLabelText(label);\n            const points = label.points;\n            const getAriaLabel = (point) => (point.graphic &&\n                point.graphic.element &&\n                point.graphic.element.getAttribute('aria-label') ||\n                '');\n            const getValueDesc = (point) => {\n                const valDesc = (point.accessibility &&\n                    point.accessibility.valueDescription ||\n                    getAriaLabel(point));\n                const seriesName = (point &&\n                    point.series.name ||\n                    '');\n                return (seriesName ? seriesName + ', ' : '') + 'data point ' + valDesc;\n            };\n            const pointValueDescriptions = points\n                .filter((p) => !!p.graphic) // Filter out mock points\n                .map(getValueDesc)\n                // Filter out points we can't describe\n                .filter((desc) => !!desc);\n            const numPoints = pointValueDescriptions.length;\n            const pointsSelector = numPoints > 1 ?\n                'MultiplePoints' : numPoints ?\n                'SinglePoint' : 'NoPoints';\n            const langFormatStr = ('accessibility.screenReaderSection.annotations.description' +\n                pointsSelector);\n            const context = {\n                annotationText: labelText,\n                annotation: label,\n                numPoints: numPoints,\n                annotationPoint: pointValueDescriptions[0],\n                additionalAnnotationPoints: pointValueDescriptions.slice(1)\n            };\n            return chart.langFormat(langFormatStr, context);\n        }\n        /**\n         * Return array of HTML strings for each annotation label in the chart.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {Array<string>} Array of strings with HTML content for each annotation label.\n         */\n        function getAnnotationListItems(chart) {\n            const labels = getChartAnnotationLabels(chart);\n            return labels.map((label) => {\n                const desc = escapeStringForHTML(stripHTMLTagsFromString(getAnnotationLabelDescription(label)));\n                return desc ? `<li>${desc}</li>` : '';\n            });\n        }\n        /**\n         * Return the annotation info for a chart as string.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {string} String with HTML content or empty string if no annotations.\n         */\n        function getAnnotationsInfoHTML(chart) {\n            const annotations = chart.annotations;\n            if (!(annotations && annotations.length)) {\n                return '';\n            }\n            const annotationItems = getAnnotationListItems(chart);\n            return `<ul style=\"list-style-type: none\">${annotationItems.join(' ')}</ul>`;\n        }\n        /**\n         * Return the texts for the annotation(s) connected to a point, or empty array\n         * if none.\n         *\n         * @private\n         * @param {Highcharts.Point} point The data point to get the annotation info from.\n         * @return {Array<string>} Annotation texts\n         */\n        function getPointAnnotationTexts(point) {\n            const labels = getChartAnnotationLabels(point.series.chart);\n            const pointLabels = labels\n                .filter((label) => label.points.indexOf(point) > -1);\n            if (!pointLabels.length) {\n                return [];\n            }\n            return pointLabels.map((label) => `${getLabelText(label)}`);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const AnnotationsA11y = {\n            getAnnotationsInfoHTML,\n            getAnnotationLabelDescription,\n            getAnnotationListItems,\n            getPointAnnotationTexts\n        };\n\n        return AnnotationsA11y;\n    });\n    _registerModule(_modules, 'Accessibility/Components/InfoRegionsComponent.js', [_modules['Accessibility/A11yI18n.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/FormatUtilities.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (A11yI18n, AccessibilityComponent, Announcer, AnnotationsA11y, AST, CU, F, H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for chart info region and table.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getAnnotationsInfoHTML } = AnnotationsA11y;\n        const { getAxisDescription, getAxisRangeDescription, getChartTitle, unhideChartElementFromAT } = CU;\n        const { format } = F;\n        const { doc } = H;\n        const { addClass, getElement, getHeadingTagNameForElement, stripHTMLTagsFromString, visuallyHideElement } = HU;\n        const { attr, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function getTableSummary(chart) {\n            return chart.langFormat('accessibility.table.tableSummary', { chart: chart });\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForMapChart(chart, formatContext) {\n            return formatContext.mapTitle ?\n                chart.langFormat('accessibility.chartTypes.mapTypeDescription', formatContext) :\n                chart.langFormat('accessibility.chartTypes.unknownMap', formatContext);\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForCombinationChart(chart, formatContext) {\n            return chart.langFormat('accessibility.chartTypes.combinationChart', formatContext);\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForEmptyChart(chart, formatContext) {\n            return chart.langFormat('accessibility.chartTypes.emptyChart', formatContext);\n        }\n        /**\n         * @private\n         */\n        function buildTypeDescriptionFromSeries(chart, types, context) {\n            const firstType = types[0], typeExplaination = chart.langFormat('accessibility.seriesTypeDescriptions.' + firstType, context), multi = chart.series && chart.series.length < 2 ? 'Single' : 'Multiple';\n            return (chart.langFormat('accessibility.chartTypes.' + firstType + multi, context) ||\n                chart.langFormat('accessibility.chartTypes.default' + multi, context)) + (typeExplaination ? ' ' + typeExplaination : '');\n        }\n        /**\n         * Return simplified explaination of chart type. Some types will not be\n         * familiar to most users, but in those cases we try to add an explaination\n         * of the type.\n         *\n         * @private\n         * @function Highcharts.Chart#getTypeDescription\n         * @param {Array<string>} types The series types in this chart.\n         * @return {string} The text description of the chart type.\n         */\n        function getTypeDescription(chart, types) {\n            const firstType = types[0], firstSeries = chart.series && chart.series[0] || {}, mapTitle = chart.mapView && chart.mapView.geoMap &&\n                chart.mapView.geoMap.title, formatContext = {\n                numSeries: chart.series.length,\n                numPoints: firstSeries.points && firstSeries.points.length,\n                chart,\n                mapTitle\n            };\n            if (!firstType) {\n                return getTypeDescForEmptyChart(chart, formatContext);\n            }\n            if (firstType === 'map') {\n                return getTypeDescForMapChart(chart, formatContext);\n            }\n            if (chart.types.length > 1) {\n                return getTypeDescForCombinationChart(chart, formatContext);\n            }\n            return buildTypeDescriptionFromSeries(chart, types, formatContext);\n        }\n        /**\n         * @private\n         */\n        function stripEmptyHTMLTags(str) {\n            return str.replace(/<(\\w+)[^>]*?>\\s*<\\/\\1>/g, '');\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The InfoRegionsComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.InfoRegionsComponent\n         */\n        class InfoRegionsComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.announcer = void 0;\n                this.screenReaderSections = {};\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                const component = this;\n                this.initRegionsDefinitions();\n                this.addEvent(chart, 'aftergetTableAST', function (e) {\n                    component.onDataTableCreated(e);\n                });\n                this.addEvent(chart, 'afterViewData', function (e) {\n                    if (e.wasHidden) {\n                        component.dataTableDiv = e.element;\n                        // Use a small delay to give browsers & AT time to\n                        // register the new table.\n                        setTimeout(function () {\n                            component.focusDataTable();\n                        }, 300);\n                    }\n                });\n                this.announcer = new Announcer(chart, 'assertive');\n            }\n            /**\n             * @private\n             */\n            initRegionsDefinitions() {\n                const component = this;\n                this.screenReaderSections = {\n                    before: {\n                        element: null,\n                        buildContent: function (chart) {\n                            const formatter = chart.options.accessibility\n                                .screenReaderSection.beforeChartFormatter;\n                            return formatter ? formatter(chart) :\n                                component.defaultBeforeChartFormatter(chart);\n                        },\n                        insertIntoDOM: function (el, chart) {\n                            chart.renderTo.insertBefore(el, chart.renderTo.firstChild);\n                        },\n                        afterInserted: function () {\n                            if (typeof component.sonifyButtonId !== 'undefined') {\n                                component.initSonifyButton(component.sonifyButtonId);\n                            }\n                            if (typeof component.dataTableButtonId !== 'undefined') {\n                                component.initDataTableButton(component.dataTableButtonId);\n                            }\n                        }\n                    },\n                    after: {\n                        element: null,\n                        buildContent: function (chart) {\n                            const formatter = chart.options.accessibility\n                                .screenReaderSection\n                                .afterChartFormatter;\n                            return formatter ? formatter(chart) :\n                                component.defaultAfterChartFormatter();\n                        },\n                        insertIntoDOM: function (el, chart) {\n                            chart.renderTo.insertBefore(el, chart.container.nextSibling);\n                        },\n                        afterInserted: function () {\n                            if (component.chart.accessibility) {\n                                component.chart.accessibility\n                                    .keyboardNavigation.updateExitAnchor(); // #15986\n                            }\n                        }\n                    }\n                };\n            }\n            /**\n             * Called on chart render. Have to update the sections on render, in order\n             * to get a11y info from series.\n             */\n            onChartRender() {\n                const component = this;\n                this.linkedDescriptionElement = this.getLinkedDescriptionElement();\n                this.setLinkedDescriptionAttrs();\n                Object.keys(this.screenReaderSections).forEach(function (regionKey) {\n                    component.updateScreenReaderSection(regionKey);\n                });\n            }\n            /**\n             * @private\n             */\n            getLinkedDescriptionElement() {\n                const chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;\n                if (!linkedDescOption) {\n                    return;\n                }\n                if (typeof linkedDescOption !== 'string') {\n                    return linkedDescOption;\n                }\n                const query = format(linkedDescOption, this.chart), queryMatch = doc.querySelectorAll(query);\n                if (queryMatch.length === 1) {\n                    return queryMatch[0];\n                }\n            }\n            /**\n             * @private\n             */\n            setLinkedDescriptionAttrs() {\n                const el = this.linkedDescriptionElement;\n                if (el) {\n                    el.setAttribute('aria-hidden', 'true');\n                    addClass(el, 'highcharts-linked-description');\n                }\n            }\n            /**\n             * @private\n             * @param {string} regionKey\n             * The name/key of the region to update\n             */\n            updateScreenReaderSection(regionKey) {\n                const chart = this.chart;\n                const region = this.screenReaderSections[regionKey];\n                const content = region.buildContent(chart);\n                const sectionDiv = region.element = (region.element || this.createElement('div'));\n                const hiddenDiv = (sectionDiv.firstChild || this.createElement('div'));\n                if (content) {\n                    this.setScreenReaderSectionAttribs(sectionDiv, regionKey);\n                    AST.setElementHTML(hiddenDiv, content);\n                    sectionDiv.appendChild(hiddenDiv);\n                    region.insertIntoDOM(sectionDiv, chart);\n                    if (chart.styledMode) {\n                        addClass(hiddenDiv, 'highcharts-visually-hidden');\n                    }\n                    else {\n                        visuallyHideElement(hiddenDiv);\n                    }\n                    unhideChartElementFromAT(chart, hiddenDiv);\n                    if (region.afterInserted) {\n                        region.afterInserted();\n                    }\n                }\n                else {\n                    if (sectionDiv.parentNode) {\n                        sectionDiv.parentNode.removeChild(sectionDiv);\n                    }\n                    region.element = null;\n                }\n            }\n            /**\n             * Apply a11y attributes to a screen reader info section\n             * @private\n             * @param {Highcharts.HTMLDOMElement} sectionDiv The section element\n             * @param {string} regionKey Name/key of the region we are setting attrs for\n             */\n            setScreenReaderSectionAttribs(sectionDiv, regionKey) {\n                const chart = this.chart, labelText = chart.langFormat('accessibility.screenReaderSection.' + regionKey +\n                    'RegionLabel', { chart: chart, chartTitle: getChartTitle(chart) }), sectionId = `highcharts-screen-reader-region-${regionKey}-${chart.index}`;\n                attr(sectionDiv, {\n                    id: sectionId,\n                    'aria-label': labelText || void 0\n                });\n                // Sections are wrapped to be positioned relatively to chart in case\n                // elements inside are tabbed to.\n                sectionDiv.style.position = 'relative';\n                if (labelText) {\n                    sectionDiv.setAttribute('role', chart.options.accessibility.landmarkVerbosity === 'all' ?\n                        'region' : 'group');\n                }\n            }\n            /**\n             * @private\n             */\n            defaultBeforeChartFormatter() {\n                const chart = this.chart, format = chart.options.accessibility.screenReaderSection\n                    .beforeChartFormat;\n                if (!format) {\n                    return '';\n                }\n                const axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = (chart.sonify &&\n                    chart.options.sonification &&\n                    chart.options.sonification.enabled), sonifyButtonId = 'highcharts-a11y-sonify-data-btn-' +\n                    chart.index, dataTableButtonId = 'hc-linkto-highcharts-data-table-' +\n                    chart.index, annotationsList = getAnnotationsInfoHTML(chart), annotationsTitleStr = chart.langFormat('accessibility.screenReaderSection.annotations.heading', { chart: chart }), context = {\n                    headingTagName: getHeadingTagNameForElement(chart.renderTo),\n                    chartTitle: getChartTitle(chart),\n                    typeDescription: this.getTypeDescriptionText(),\n                    chartSubtitle: this.getSubtitleText(),\n                    chartLongdesc: this.getLongdescText(),\n                    xAxisDescription: axesDesc.xAxis,\n                    yAxisDescription: axesDesc.yAxis,\n                    playAsSoundButton: shouldHaveSonifyBtn ?\n                        this.getSonifyButtonText(sonifyButtonId) : '',\n                    viewTableButton: chart.getCSV ?\n                        this.getDataTableButtonText(dataTableButtonId) : '',\n                    annotationsTitle: annotationsList ? annotationsTitleStr : '',\n                    annotationsList: annotationsList\n                }, formattedString = A11yI18n.i18nFormat(format, context, chart);\n                this.dataTableButtonId = dataTableButtonId;\n                this.sonifyButtonId = sonifyButtonId;\n                return stripEmptyHTMLTags(formattedString);\n            }\n            /**\n             * @private\n             */\n            defaultAfterChartFormatter() {\n                const chart = this.chart;\n                const format = chart.options.accessibility.screenReaderSection\n                    .afterChartFormat;\n                if (!format) {\n                    return '';\n                }\n                const context = { endOfChartMarker: this.getEndOfChartMarkerText() };\n                const formattedString = A11yI18n.i18nFormat(format, context, chart);\n                return stripEmptyHTMLTags(formattedString);\n            }\n            /**\n             * @private\n             */\n            getLinkedDescription() {\n                const el = this.linkedDescriptionElement, content = el && el.innerHTML || '';\n                return stripHTMLTagsFromString(content);\n            }\n            /**\n             * @private\n             */\n            getLongdescText() {\n                const chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();\n                return (chartOptions.accessibility.description ||\n                    linkedDescription ||\n                    captionText ||\n                    '');\n            }\n            /**\n             * @private\n             */\n            getTypeDescriptionText() {\n                const chart = this.chart;\n                return chart.types ?\n                    chart.options.accessibility.typeDescription ||\n                        getTypeDescription(chart, chart.types) : '';\n            }\n            /**\n             * @private\n             */\n            getDataTableButtonText(buttonId) {\n                const chart = this.chart, buttonText = chart.langFormat('accessibility.table.viewAsDataTableButtonText', { chart: chart, chartTitle: getChartTitle(chart) });\n                return '<button id=\"' + buttonId + '\">' + buttonText + '</button>';\n            }\n            /**\n             * @private\n             */\n            getSonifyButtonText(buttonId) {\n                const chart = this.chart;\n                if (chart.options.sonification &&\n                    chart.options.sonification.enabled === false) {\n                    return '';\n                }\n                const buttonText = chart.langFormat('accessibility.sonification.playAsSoundButtonText', { chart: chart, chartTitle: getChartTitle(chart) });\n                return '<button id=\"' + buttonId + '\">' + buttonText + '</button>';\n            }\n            /**\n             * @private\n             */\n            getSubtitleText() {\n                const subtitle = (this.chart.options.subtitle);\n                return stripHTMLTagsFromString(subtitle && subtitle.text || '');\n            }\n            /**\n             * @private\n             */\n            getEndOfChartMarkerText() {\n                const chart = this.chart, markerText = chart.langFormat('accessibility.screenReaderSection.endOfChartMarker', { chart: chart }), id = 'highcharts-end-of-chart-marker-' + chart.index;\n                return '<div id=\"' + id + '\">' + markerText + '</div>';\n            }\n            /**\n             * @private\n             * @param {Highcharts.Dictionary<string>} e\n             */\n            onDataTableCreated(e) {\n                const chart = this.chart;\n                if (chart.options.accessibility.enabled) {\n                    if (this.viewDataTableButton) {\n                        this.viewDataTableButton.setAttribute('aria-expanded', 'true');\n                    }\n                    const attributes = e.tree.attributes || {};\n                    attributes.tabindex = -1;\n                    attributes.summary = getTableSummary(chart);\n                    e.tree.attributes = attributes;\n                }\n            }\n            /**\n             * @private\n             */\n            focusDataTable() {\n                const tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName('table')[0];\n                if (table && table.focus) {\n                    table.focus();\n                }\n            }\n            /**\n             * @private\n             * @param {string} sonifyButtonId\n             */\n            initSonifyButton(sonifyButtonId) {\n                const el = this.sonifyButton = getElement(sonifyButtonId);\n                const chart = this.chart;\n                const defaultHandler = (e) => {\n                    if (el) {\n                        el.setAttribute('aria-hidden', 'true');\n                        el.setAttribute('aria-label', '');\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    const announceMsg = chart.langFormat('accessibility.sonification.playAsSoundClickAnnouncement', { chart: chart });\n                    this.announcer.announce(announceMsg);\n                    setTimeout(() => {\n                        if (el) {\n                            el.removeAttribute('aria-hidden');\n                            el.removeAttribute('aria-label');\n                        }\n                        if (chart.sonify) {\n                            chart.sonify();\n                        }\n                    }, 1000); // Delay to let screen reader speak the button press\n                };\n                if (el && chart) {\n                    el.setAttribute('tabindex', -1);\n                    el.onclick = function (e) {\n                        const onPlayAsSoundClick = (chart.options.accessibility &&\n                            chart.options.accessibility.screenReaderSection\n                                .onPlayAsSoundClick);\n                        (onPlayAsSoundClick || defaultHandler).call(this, e, chart);\n                    };\n                }\n            }\n            /**\n             * Set attribs and handlers for default viewAsDataTable button if exists.\n             * @private\n             * @param {string} tableButtonId\n             */\n            initDataTableButton(tableButtonId) {\n                const el = this.viewDataTableButton = getElement(tableButtonId), chart = this.chart, tableId = tableButtonId.replace('hc-linkto-', '');\n                if (el) {\n                    attr(el, {\n                        tabindex: -1,\n                        'aria-expanded': !!getElement(tableId)\n                    });\n                    el.onclick = chart.options.accessibility\n                        .screenReaderSection.onViewDataTableClick ||\n                        function () {\n                            chart.viewData();\n                        };\n                }\n            }\n            /**\n             * Return object with text description of each of the chart's axes.\n             * @private\n             */\n            getAxesDescription() {\n                const chart = this.chart, shouldDescribeColl = function (collectionKey, defaultCondition) {\n                    const axes = chart[collectionKey];\n                    return axes.length > 1 || axes[0] &&\n                        pick(axes[0].options.accessibility &&\n                            axes[0].options.accessibility.enabled, defaultCondition);\n                }, hasNoMap = !!chart.types &&\n                    chart.types.indexOf('map') < 0 &&\n                    chart.types.indexOf('treemap') < 0 &&\n                    chart.types.indexOf('tilemap') < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl('xAxis', !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl('yAxis', hasCartesian && hasNoMap), desc = {};\n                if (showXAxes) {\n                    desc.xAxis = this.getAxisDescriptionText('xAxis');\n                }\n                if (showYAxes) {\n                    desc.yAxis = this.getAxisDescriptionText('yAxis');\n                }\n                return desc;\n            }\n            /**\n             * @private\n             */\n            getAxisDescriptionText(collectionKey) {\n                const chart = this.chart;\n                const axes = chart[collectionKey];\n                return chart.langFormat('accessibility.axis.' + collectionKey + 'Description' + (axes.length > 1 ? 'Plural' : 'Singular'), {\n                    chart: chart,\n                    names: axes.map(function (axis) {\n                        return getAxisDescription(axis);\n                    }),\n                    ranges: axes.map(function (axis) {\n                        return getAxisRangeDescription(axis);\n                    }),\n                    numAxes: axes.length\n                });\n            }\n            /**\n             * Remove component traces\n             */\n            destroy() {\n                if (this.announcer) {\n                    this.announcer.destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return InfoRegionsComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/MenuComponent.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (Chart, U, AccessibilityComponent, KeyboardNavigationHandler, ChartUtilities, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for exporting menu.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { attr } = U;\n        const { getChartTitle, unhideChartElementFromAT } = ChartUtilities;\n        const { getFakeMouseEvent } = HTMLUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Get the wrapped export button element of a chart.\n         * @private\n         */\n        function getExportMenuButtonElement(chart) {\n            return chart.exportSVGElements && chart.exportSVGElements[0];\n        }\n        /**\n         * @private\n         */\n        function exportingShouldHaveA11y(chart) {\n            const exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);\n            return !!(exportingOpts &&\n                exportingOpts.enabled !== false &&\n                exportingOpts.accessibility &&\n                exportingOpts.accessibility.enabled &&\n                exportButton &&\n                exportButton.element);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The MenuComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.MenuComponent\n         */\n        class MenuComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             */\n            init() {\n                const chart = this.chart, component = this;\n                this.addEvent(chart, 'exportMenuShown', function () {\n                    component.onMenuShown();\n                });\n                this.addEvent(chart, 'exportMenuHidden', function () {\n                    component.onMenuHidden();\n                });\n                this.createProxyGroup();\n            }\n            /**\n             * @private\n             */\n            onMenuHidden() {\n                const menu = this.chart.exportContextMenu;\n                if (menu) {\n                    menu.setAttribute('aria-hidden', 'true');\n                }\n                this.setExportButtonExpandedState('false');\n            }\n            /**\n             * @private\n             */\n            onMenuShown() {\n                const chart = this.chart, menu = chart.exportContextMenu;\n                if (menu) {\n                    this.addAccessibleContextMenuAttribs();\n                    unhideChartElementFromAT(chart, menu);\n                }\n                this.setExportButtonExpandedState('true');\n            }\n            /**\n             * @private\n             * @param {string} stateStr\n             */\n            setExportButtonExpandedState(stateStr) {\n                if (this.exportButtonProxy) {\n                    this.exportButtonProxy.buttonElement.setAttribute('aria-expanded', stateStr);\n                }\n            }\n            /**\n             * Called on each render of the chart. We need to update positioning of the\n             * proxy overlay.\n             */\n            onChartRender() {\n                const chart = this.chart, focusEl = chart.focusElement, a11y = chart.accessibility;\n                this.proxyProvider.clearGroup('chartMenu');\n                this.proxyMenuButton();\n                if (this.exportButtonProxy &&\n                    focusEl &&\n                    focusEl === chart.exportingGroup) {\n                    if (focusEl.focusBorder) {\n                        chart.setFocusToElement(focusEl, this.exportButtonProxy.buttonElement);\n                    }\n                    else if (a11y) {\n                        a11y.keyboardNavigation.tabindexContainer.focus();\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            proxyMenuButton() {\n                const chart = this.chart;\n                const proxyProvider = this.proxyProvider;\n                const buttonEl = getExportMenuButtonElement(chart);\n                if (exportingShouldHaveA11y(chart) && buttonEl) {\n                    this.exportButtonProxy = proxyProvider.addProxyElement('chartMenu', { click: buttonEl }, {\n                        'aria-label': chart.langFormat('accessibility.exporting.menuButtonLabel', {\n                            chart: chart,\n                            chartTitle: getChartTitle(chart)\n                        }),\n                        'aria-expanded': false,\n                        title: chart.options.lang.contextButtonTitle || null\n                    });\n                }\n            }\n            /**\n             * @private\n             */\n            createProxyGroup() {\n                const chart = this.chart;\n                if (chart && this.proxyProvider) {\n                    this.proxyProvider.addGroup('chartMenu', 'div');\n                }\n            }\n            /**\n             * @private\n             */\n            addAccessibleContextMenuAttribs() {\n                const chart = this.chart, exportList = chart.exportDivElements;\n                if (exportList && exportList.length) {\n                    // Set tabindex on the menu items to allow focusing by script\n                    // Set role to give screen readers a chance to pick up the contents\n                    exportList.forEach((item) => {\n                        if (item) {\n                            if (item.tagName === 'LI' &&\n                                !(item.children && item.children.length)) {\n                                item.setAttribute('tabindex', -1);\n                            }\n                            else {\n                                item.setAttribute('aria-hidden', 'true');\n                            }\n                        }\n                    });\n                    // Set accessibility properties on parent div\n                    const parentDiv = (exportList[0] && exportList[0].parentNode);\n                    if (parentDiv) {\n                        attr(parentDiv, {\n                            'aria-hidden': void 0,\n                            'aria-label': chart.langFormat('accessibility.exporting.chartMenuLabel', { chart }),\n                            role: 'list' // Needed for webkit/VO\n                        });\n                    }\n                }\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                const keys = this.keyCodes, chart = this.chart, component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        // Arrow prev handler\n                        [\n                            [keys.left, keys.up],\n                            function () {\n                                return component.onKbdPrevious(this);\n                            }\n                        ],\n                        // Arrow next handler\n                        [\n                            [keys.right, keys.down],\n                            function () {\n                                return component.onKbdNext(this);\n                            }\n                        ],\n                        // Click handler\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onKbdClick(this);\n                            }\n                        ]\n                    ],\n                    // Only run exporting navigation if exporting support exists and is\n                    // enabled on chart\n                    validate: function () {\n                        return !!chart.exporting &&\n                            chart.options.exporting.enabled !== false &&\n                            chart.options.exporting.accessibility.enabled !==\n                                false;\n                    },\n                    // Focus export menu button\n                    init: function () {\n                        const proxy = component.exportButtonProxy;\n                        const svgEl = component.chart.exportingGroup;\n                        if (proxy && svgEl) {\n                            chart.setFocusToElement(svgEl, proxy.buttonElement);\n                        }\n                    },\n                    // Hide the menu\n                    terminate: function () {\n                        chart.hideExportMenu();\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdPrevious(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const a11yOptions = chart.options.accessibility;\n                const response = keyboardNavigationHandler.response;\n                // Try to highlight prev item in list. Highlighting e.g.\n                // separators will fail.\n                let i = chart.highlightedExportItemIx || 0;\n                while (i--) {\n                    if (chart.highlightExportItem(i)) {\n                        return response.success;\n                    }\n                }\n                // We failed, so wrap around or move to prev module\n                if (a11yOptions.keyboardNavigation.wrapAround) {\n                    chart.highlightLastExportItem();\n                    return response.success;\n                }\n                return response.prev;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdNext(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const a11yOptions = chart.options.accessibility;\n                const response = keyboardNavigationHandler.response;\n                // Try to highlight next item in list. Highlighting e.g.\n                // separators will fail.\n                for (let i = (chart.highlightedExportItemIx || 0) + 1; i < chart.exportDivElements.length; ++i) {\n                    if (chart.highlightExportItem(i)) {\n                        return response.success;\n                    }\n                }\n                // We failed, so wrap around or move to next module\n                if (a11yOptions.keyboardNavigation.wrapAround) {\n                    chart.highlightExportItem(0);\n                    return response.success;\n                }\n                return response.next;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdClick(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx];\n                const exportButtonElement = getExportMenuButtonElement(chart).element;\n                if (chart.openMenu) {\n                    this.fakeClickEvent(curHighlightedItem);\n                }\n                else {\n                    this.fakeClickEvent(exportButtonElement);\n                    chart.highlightExportItem(0);\n                }\n                return keyboardNavigationHandler.response.success;\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (MenuComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = Chart.prototype;\n                    chartProto.hideExportMenu = chartHideExportMenu;\n                    chartProto.highlightExportItem = chartHighlightExportItem;\n                    chartProto.highlightLastExportItem = chartHighlightLastExportItem;\n                    chartProto.showExportMenu = chartShowExportMenu;\n                }\n            }\n            MenuComponent.compose = compose;\n            /**\n             * Show the export menu and focus the first item (if exists).\n             *\n             * @private\n             * @function Highcharts.Chart#showExportMenu\n             */\n            function chartShowExportMenu() {\n                const exportButton = getExportMenuButtonElement(this);\n                if (exportButton) {\n                    const el = exportButton.element;\n                    if (el.onclick) {\n                        el.onclick(getFakeMouseEvent('click'));\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.Chart#hideExportMenu\n             */\n            function chartHideExportMenu() {\n                const chart = this, exportList = chart.exportDivElements;\n                if (exportList && chart.exportContextMenu && chart.openMenu) {\n                    // Reset hover states etc.\n                    exportList.forEach((el) => {\n                        if (el &&\n                            el.className === 'highcharts-menu-item' &&\n                            el.onmouseout) {\n                            el.onmouseout(getFakeMouseEvent('mouseout'));\n                        }\n                    });\n                    chart.highlightedExportItemIx = 0;\n                    // Hide the menu div\n                    chart.exportContextMenu.hideMenu();\n                    // Make sure the chart has focus and can capture keyboard events\n                    chart.container.focus();\n                }\n            }\n            /**\n             * Highlight export menu item by index.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightExportItem\n             */\n            function chartHighlightExportItem(ix) {\n                const listItem = this.exportDivElements && this.exportDivElements[ix];\n                const curHighlighted = this.exportDivElements &&\n                    this.exportDivElements[this.highlightedExportItemIx];\n                if (listItem &&\n                    listItem.tagName === 'LI' &&\n                    !(listItem.children && listItem.children.length)) {\n                    // Test if we have focus support for SVG elements\n                    const hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName('g')[0] || {}).focus;\n                    // Only focus if we can set focus back to the elements after\n                    // destroying the menu (#7422)\n                    if (listItem.focus && hasSVGFocusSupport) {\n                        listItem.focus();\n                    }\n                    if (curHighlighted && curHighlighted.onmouseout) {\n                        curHighlighted.onmouseout(getFakeMouseEvent('mouseout'));\n                    }\n                    if (listItem.onmouseover) {\n                        listItem.onmouseover(getFakeMouseEvent('mouseover'));\n                    }\n                    this.highlightedExportItemIx = ix;\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Try to highlight the last valid export menu item.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightLastExportItem\n             */\n            function chartHighlightLastExportItem() {\n                const chart = this;\n                if (chart.exportDivElements) {\n                    let i = chart.exportDivElements.length;\n                    while (i--) {\n                        if (chart.highlightExportItem(i)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n        })(MenuComponent || (MenuComponent = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MenuComponent;\n    });\n    _registerModule(_modules, 'Accessibility/KeyboardNavigation.js', [_modules['Core/Globals.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, MenuComponent, U, EventProvider, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Main keyboard navigation handling.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, win } = H;\n        const { addEvent, fireEvent } = U;\n        const { getElement, simulatedEventTarget } = HTMLUtilities;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The KeyboardNavigation class, containing the overall keyboard navigation\n         * logic for the chart.\n         *\n         * @requires module:modules/accessibility\n         *\n         * @private\n         * @class\n         * @param {Highcharts.Chart} chart\n         *        Chart object\n         * @param {Object} components\n         *        Map of component names to AccessibilityComponent objects.\n         * @name Highcharts.KeyboardNavigation\n         */\n        class KeyboardNavigation {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, components) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.components = void 0;\n                this.currentModuleIx = NaN;\n                this.eventProvider = void 0;\n                this.exitAnchor = void 0;\n                this.modules = [];\n                this.tabindexContainer = void 0;\n                this.init(chart, components);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the class\n             * @private\n             * @param {Highcharts.Chart} chart\n             *        Chart object\n             * @param {Object} components\n             *        Map of component names to AccessibilityComponent objects.\n             */\n            init(chart, components) {\n                const ep = this.eventProvider = new EventProvider();\n                this.chart = chart;\n                this.components = components;\n                this.modules = [];\n                this.currentModuleIx = 0;\n                this.update();\n                ep.addEvent(this.tabindexContainer, 'keydown', (e) => this.onKeydown(e));\n                ep.addEvent(this.tabindexContainer, 'focus', (e) => this.onFocus(e));\n                ['mouseup', 'touchend'].forEach((eventName) => ep.addEvent(doc, eventName, (e) => this.onMouseUp(e)));\n                ['mousedown', 'touchstart'].forEach((eventName) => ep.addEvent(chart.renderTo, eventName, () => {\n                    this.isClickingChart = true;\n                }));\n            }\n            /**\n             * Update the modules for the keyboard navigation.\n             * @param {Array<string>} [order]\n             *        Array specifying the tab order of the components.\n             */\n            update(order) {\n                const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;\n                this.updateContainerTabindex();\n                if (keyboardOptions &&\n                    keyboardOptions.enabled &&\n                    order &&\n                    order.length) {\n                    // We (still) have keyboard navigation. Update module list\n                    this.modules = order.reduce(function (modules, componentName) {\n                        const navModules = components[componentName]\n                            .getKeyboardNavigation();\n                        return modules.concat(navModules);\n                    }, []);\n                    this.updateExitAnchor();\n                }\n                else {\n                    this.modules = [];\n                    this.currentModuleIx = 0;\n                    this.removeExitAnchor();\n                }\n            }\n            /**\n             * We use an exit anchor to move focus out of chart whenever we want, by\n             * setting focus to this div and not preventing the default tab action. We\n             * also use this when users come back into the chart by tabbing back, in\n             * order to navigate from the end of the chart.\n             * @private\n             */\n            updateExitAnchor() {\n                const endMarkerId = `highcharts-end-of-chart-marker-${this.chart.index}`, endMarker = getElement(endMarkerId);\n                this.removeExitAnchor();\n                if (endMarker) {\n                    this.makeElementAnExitAnchor(endMarker);\n                    this.exitAnchor = endMarker;\n                }\n                else {\n                    this.createExitAnchor();\n                }\n            }\n            /**\n             * Move to prev/next module.\n             * @private\n             * @param {number} direction\n             * Direction to move. +1 for next, -1 for prev.\n             * @return {boolean}\n             * True if there was a valid module in direction.\n             */\n            move(direction) {\n                const curModule = this.modules && this.modules[this.currentModuleIx];\n                if (curModule && curModule.terminate) {\n                    curModule.terminate(direction);\n                }\n                // Remove existing focus border if any\n                if (this.chart.focusElement) {\n                    this.chart.focusElement.removeFocusBorder();\n                }\n                this.currentModuleIx += direction;\n                const newModule = this.modules && this.modules[this.currentModuleIx];\n                if (newModule) {\n                    if (newModule.validate && !newModule.validate()) {\n                        return this.move(direction); // Invalid module, recurse\n                    }\n                    if (newModule.init) {\n                        newModule.init(direction); // Valid module, init it\n                        return true;\n                    }\n                }\n                // No module\n                this.currentModuleIx = 0; // Reset counter\n                // Set focus to chart or exit anchor depending on direction\n                this.exiting = true;\n                if (direction > 0) {\n                    this.exitAnchor && this.exitAnchor.focus();\n                }\n                else {\n                    this.tabindexContainer.focus();\n                }\n                return false;\n            }\n            /**\n             * Function to run on container focus\n             * @private\n             * @param {global.FocusEvent} e Browser focus event.\n             */\n            onFocus(e) {\n                const chart = this.chart, focusComesFromChart = (e.relatedTarget &&\n                    chart.container.contains(e.relatedTarget)), a11yOptions = chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, enabled = keyboardOptions && keyboardOptions.enabled;\n                // Init keyboard nav if tabbing into chart\n                if (enabled &&\n                    !this.exiting &&\n                    !this.tabbingInBackwards &&\n                    !this.isClickingChart &&\n                    !focusComesFromChart) {\n                    const ix = this.getFirstValidModuleIx();\n                    if (ix !== null) {\n                        this.currentModuleIx = ix;\n                        this.modules[ix].init(1);\n                    }\n                }\n                this.exiting = false;\n            }\n            /**\n             * Reset chart navigation state if we mouse click and it's not already\n             * reset. Reset fully if outside the chart, otherwise just hide focus\n             * indicator.\n             * @private\n             */\n            onMouseUp(e) {\n                delete this.isClickingChart;\n                if (!this.keyboardReset &&\n                    e.relatedTarget !== simulatedEventTarget) {\n                    const chart = this.chart;\n                    if (!e.target ||\n                        !chart.container.contains(e.target)) {\n                        const curMod = this.modules &&\n                            this.modules[this.currentModuleIx || 0];\n                        if (curMod && curMod.terminate) {\n                            curMod.terminate();\n                        }\n                        this.currentModuleIx = 0;\n                    }\n                    if (chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                        delete chart.focusElement;\n                    }\n                    this.keyboardReset = true;\n                }\n            }\n            /**\n             * Function to run on keydown\n             * @private\n             * @param {global.KeyboardEvent} ev Browser keydown event.\n             */\n            onKeydown(ev) {\n                const e = ev || win.event, curNavModule = (this.modules &&\n                    this.modules.length &&\n                    this.modules[this.currentModuleIx]);\n                let preventDefault;\n                // Used for resetting nav state when clicking outside chart\n                this.keyboardReset = false;\n                // Used for sending focus out of the chart by the modules.\n                this.exiting = false;\n                // If there is a nav module for the current index, run it.\n                // Otherwise, we are outside of the chart in some direction.\n                if (curNavModule) {\n                    const response = curNavModule.run(e);\n                    if (response === curNavModule.response.success) {\n                        preventDefault = true;\n                    }\n                    else if (response === curNavModule.response.prev) {\n                        preventDefault = this.move(-1);\n                    }\n                    else if (response === curNavModule.response.next) {\n                        preventDefault = this.move(1);\n                    }\n                    if (preventDefault) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                }\n            }\n            /**\n             * Chart container should have tabindex if navigation is enabled.\n             * @private\n             */\n            updateContainerTabindex() {\n                const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;\n                let tabindexContainer;\n                if (chart.renderTo.hasAttribute('tabindex')) {\n                    container.removeAttribute('tabindex');\n                    tabindexContainer = chart.renderTo;\n                }\n                else {\n                    tabindexContainer = container;\n                }\n                this.tabindexContainer = tabindexContainer;\n                const curTabindex = tabindexContainer.getAttribute('tabindex');\n                if (shouldHaveTabindex && !curTabindex) {\n                    tabindexContainer.setAttribute('tabindex', '0');\n                }\n                else if (!shouldHaveTabindex) {\n                    chart.container.removeAttribute('tabindex');\n                }\n            }\n            /**\n             * Add new exit anchor to the chart.\n             * @private\n             */\n            createExitAnchor() {\n                const chart = this.chart, exitAnchor = this.exitAnchor = doc.createElement('div');\n                chart.renderTo.appendChild(exitAnchor);\n                this.makeElementAnExitAnchor(exitAnchor);\n            }\n            /**\n             * Add attributes and events to an element to make it function as an\n             * exit anchor.\n             * @private\n             */\n            makeElementAnExitAnchor(el) {\n                const chartTabindex = this.tabindexContainer.getAttribute('tabindex') || 0;\n                el.setAttribute('class', 'highcharts-exit-anchor');\n                el.setAttribute('tabindex', chartTabindex);\n                el.setAttribute('aria-hidden', false);\n                // Handle focus\n                this.addExitAnchorEventsToEl(el);\n            }\n            /**\n             * Destroy the exit anchor and remove from DOM.\n             * @private\n             */\n            removeExitAnchor() {\n                if (this.exitAnchor && this.exitAnchor.parentNode) {\n                    this.exitAnchor.parentNode.removeChild(this.exitAnchor);\n                    delete this.exitAnchor;\n                }\n            }\n            /**\n             * Add focus handler to exit anchor element.\n             * @private\n             */\n            addExitAnchorEventsToEl(element) {\n                const chart = this.chart, keyboardNavigation = this;\n                this.eventProvider.addEvent(element, 'focus', function (ev) {\n                    const e = ev || win.event, focusComesFromChart = (e.relatedTarget &&\n                        chart.container.contains(e.relatedTarget)), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);\n                    if (chart.focusElement) {\n                        delete chart.focusElement;\n                    }\n                    if (comingInBackwards) {\n                        // Focus the container instead\n                        keyboardNavigation.tabbingInBackwards = true;\n                        keyboardNavigation.tabindexContainer.focus();\n                        delete keyboardNavigation.tabbingInBackwards;\n                        e.preventDefault();\n                        // Move to last valid keyboard nav module\n                        // Note the we don't run it, just set the index\n                        if (keyboardNavigation.modules &&\n                            keyboardNavigation.modules.length) {\n                            keyboardNavigation.currentModuleIx =\n                                keyboardNavigation.modules.length - 1;\n                            const curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];\n                            // Validate the module\n                            if (curModule &&\n                                curModule.validate && !curModule.validate()) {\n                                // Invalid. Try moving backwards to find next valid.\n                                keyboardNavigation.move(-1);\n                            }\n                            else if (curModule) {\n                                // We have a valid module, init it\n                                curModule.init(-1);\n                            }\n                        }\n                    }\n                    else {\n                        // Don't skip the next focus, we only skip once.\n                        keyboardNavigation.exiting = false;\n                    }\n                });\n            }\n            /**\n             * Get the ix of the first module that either does not require validation or\n             * validates positively.\n             * @private\n             */\n            getFirstValidModuleIx() {\n                const len = this.modules.length;\n                for (let i = 0; i < len; ++i) {\n                    const mod = this.modules[i];\n                    if (!mod.validate || mod.validate()) {\n                        return i;\n                    }\n                }\n                return null;\n            }\n            /**\n             * Remove all traces of keyboard navigation.\n             * @private\n             */\n            destroy() {\n                this.removeExitAnchor();\n                this.eventProvider.removeAddedEvents();\n                this.chart.container.removeAttribute('tabindex');\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (KeyboardNavigation) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Construction\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Composition function.\n             * @private\n             */\n            function compose(ChartClass) {\n                MenuComponent.compose(ChartClass);\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.dismissPopupContent = chartDismissPopupContent;\n                }\n                if (U.pushUnique(composedMembers, doc)) {\n                    addEvent(doc, 'keydown', documentOnKeydown);\n                }\n                return ChartClass;\n            }\n            KeyboardNavigation.compose = compose;\n            /**\n             * Dismiss popup content in chart, including export menu and tooltip.\n             * @private\n             */\n            function chartDismissPopupContent() {\n                const chart = this;\n                fireEvent(this, 'dismissPopupContent', {}, function () {\n                    if (chart.tooltip) {\n                        chart.tooltip.hide(0);\n                    }\n                    chart.hideExportMenu();\n                });\n            }\n            /**\n             * Add event listener to document to detect ESC key press and dismiss\n             * hover/popup content.\n             * @private\n             */\n            function documentOnKeydown(e) {\n                const keycode = e.which || e.keyCode;\n                const esc = 27;\n                if (keycode === esc && H.charts) {\n                    H.charts.forEach((chart) => {\n                        if (chart && chart.dismissPopupContent) {\n                            chart.dismissPopupContent();\n                        }\n                    });\n                }\n            }\n        })(KeyboardNavigation || (KeyboardNavigation = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return KeyboardNavigation;\n    });\n    _registerModule(_modules, 'Accessibility/Components/LegendComponent.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Legend/Legend.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (A, H, Legend, U, AccessibilityComponent, KeyboardNavigationHandler, CU, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for chart legend.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { doc } = H;\n        const { addEvent, fireEvent, isNumber, pick, syncTimeout } = U;\n        const { getChartTitle } = CU;\n        const { stripHTMLTagsFromString: stripHTMLTags, addClass, removeClass } = HU;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function scrollLegendToItem(legend, itemIx) {\n            const itemPage = (legend.allItems[itemIx].legendItem || {}).pageIx, curPage = legend.currentPage;\n            if (typeof itemPage !== 'undefined' && itemPage + 1 !== curPage) {\n                legend.scroll(1 + itemPage - curPage);\n            }\n        }\n        /**\n         * @private\n         */\n        function shouldDoLegendA11y(chart) {\n            const items = chart.legend && chart.legend.allItems, legendA11yOptions = (chart.options.legend.accessibility || {}), unsupportedColorAxis = chart.colorAxis && chart.colorAxis.some((c) => !c.dataClasses || !c.dataClasses.length);\n            return !!(items && items.length &&\n                !unsupportedColorAxis &&\n                legendA11yOptions.enabled !== false);\n        }\n        /**\n         * @private\n         */\n        function setLegendItemHoverState(hoverActive, item) {\n            const legendItem = item.legendItem || {};\n            item.setState(hoverActive ? 'hover' : '', true);\n            for (const key of ['group', 'label', 'symbol']) {\n                const svgElement = legendItem[key];\n                const element = svgElement && svgElement.element || svgElement;\n                if (element) {\n                    fireEvent(element, hoverActive ? 'mouseover' : 'mouseout');\n                }\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The LegendComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.LegendComponent\n         */\n        class LegendComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.highlightedLegendItemIx = NaN;\n                this.proxyGroup = null;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const component = this;\n                this.recreateProxies();\n                // Note: Chart could create legend dynamically, so events cannot be\n                // tied to the component's chart's current legend.\n                // @todo 1. attach component to created legends\n                // @todo 2. move listeners to composition and access `this.component`\n                this.addEvent(Legend, 'afterScroll', function () {\n                    if (this.chart === component.chart) {\n                        component.proxyProvider.updateGroupProxyElementPositions('legend');\n                        component.updateLegendItemProxyVisibility();\n                        if (component.highlightedLegendItemIx > -1) {\n                            this.chart.highlightLegendItem(component.highlightedLegendItemIx);\n                        }\n                    }\n                });\n                this.addEvent(Legend, 'afterPositionItem', function (e) {\n                    if (this.chart === component.chart && this.chart.renderer) {\n                        component.updateProxyPositionForItem(e.item);\n                    }\n                });\n                this.addEvent(Legend, 'afterRender', function () {\n                    if (this.chart === component.chart &&\n                        this.chart.renderer &&\n                        component.recreateProxies()) {\n                        syncTimeout(() => component.proxyProvider\n                            .updateGroupProxyElementPositions('legend'), animObject(pick(this.chart.renderer.globalAnimation, true)).duration);\n                    }\n                });\n            }\n            /**\n             * Update visibility of legend items when using paged legend\n             * @private\n             */\n            updateLegendItemProxyVisibility() {\n                const chart = this.chart;\n                const legend = chart.legend;\n                const items = legend.allItems || [];\n                const curPage = legend.currentPage || 1;\n                const clipHeight = legend.clipHeight || 0;\n                let legendItem;\n                items.forEach((item) => {\n                    if (item.a11yProxyElement) {\n                        const hasPages = legend.pages && legend.pages.length;\n                        const proxyEl = item.a11yProxyElement.element;\n                        let hide = false;\n                        legendItem = item.legendItem || {};\n                        if (hasPages) {\n                            const itemPage = legendItem.pageIx || 0;\n                            const y = legendItem.y || 0;\n                            const h = legendItem.label ?\n                                Math.round(legendItem.label.getBBox().height) :\n                                0;\n                            hide = y + h - legend.pages[itemPage] > clipHeight ||\n                                itemPage !== curPage - 1;\n                        }\n                        if (hide) {\n                            if (chart.styledMode) {\n                                addClass(proxyEl, 'highcharts-a11y-invisible');\n                            }\n                            else {\n                                proxyEl.style.visibility = 'hidden';\n                            }\n                        }\n                        else {\n                            removeClass(proxyEl, 'highcharts-a11y-invisible');\n                            proxyEl.style.visibility = '';\n                        }\n                    }\n                });\n            }\n            /**\n             * @private\n             */\n            onChartRender() {\n                if (!shouldDoLegendA11y(this.chart)) {\n                    this.removeProxies();\n                }\n            }\n            /**\n             * @private\n             */\n            highlightAdjacentLegendPage(direction) {\n                const chart = this.chart;\n                const legend = chart.legend;\n                const curPageIx = legend.currentPage || 1;\n                const newPageIx = curPageIx + direction;\n                const pages = legend.pages || [];\n                if (newPageIx > 0 && newPageIx <= pages.length) {\n                    let i = 0, res;\n                    for (const item of legend.allItems) {\n                        if (((item.legendItem || {}).pageIx || 0) + 1 === newPageIx) {\n                            res = chart.highlightLegendItem(i);\n                            if (res) {\n                                this.highlightedLegendItemIx = i;\n                            }\n                        }\n                        ++i;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            updateProxyPositionForItem(item) {\n                if (item.a11yProxyElement) {\n                    item.a11yProxyElement.refreshPosition();\n                }\n            }\n            /**\n             * Returns false if legend a11y is disabled and proxies were not created,\n             * true otherwise.\n             * @private\n             */\n            recreateProxies() {\n                const focusedElement = doc.activeElement;\n                const proxyGroup = this.proxyGroup;\n                const shouldRestoreFocus = focusedElement && proxyGroup &&\n                    proxyGroup.contains(focusedElement);\n                this.removeProxies();\n                if (shouldDoLegendA11y(this.chart)) {\n                    this.addLegendProxyGroup();\n                    this.proxyLegendItems();\n                    this.updateLegendItemProxyVisibility();\n                    this.updateLegendTitle();\n                    if (shouldRestoreFocus) {\n                        this.chart.highlightLegendItem(this.highlightedLegendItemIx);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * @private\n             */\n            removeProxies() {\n                this.proxyProvider.removeGroup('legend');\n            }\n            /**\n             * @private\n             */\n            updateLegendTitle() {\n                const chart = this.chart;\n                const legendTitle = stripHTMLTags((chart.legend &&\n                    chart.legend.options.title &&\n                    chart.legend.options.title.text ||\n                    '').replace(/<br ?\\/?>/g, ' '));\n                const legendLabel = chart.langFormat('accessibility.legend.legendLabel' + (legendTitle ? '' : 'NoTitle'), {\n                    chart,\n                    legendTitle,\n                    chartTitle: getChartTitle(chart)\n                });\n                this.proxyProvider.updateGroupAttrs('legend', {\n                    'aria-label': legendLabel\n                });\n            }\n            /**\n             * @private\n             */\n            addLegendProxyGroup() {\n                const a11yOptions = this.chart.options.accessibility;\n                const groupRole = a11yOptions.landmarkVerbosity === 'all' ?\n                    'region' : null;\n                this.proxyGroup = this.proxyProvider.addGroup('legend', 'ul', {\n                    // Filled by updateLegendTitle, to keep up to date without\n                    // recreating group\n                    'aria-label': '_placeholder_',\n                    role: groupRole\n                });\n            }\n            /**\n             * @private\n             */\n            proxyLegendItems() {\n                const component = this, items = (this.chart.legend || {}).allItems || [];\n                let legendItem;\n                items.forEach((item) => {\n                    legendItem = item.legendItem || {};\n                    if (legendItem.label && legendItem.label.element) {\n                        component.proxyLegendItem(item);\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n             */\n            proxyLegendItem(item) {\n                const legendItem = item.legendItem || {};\n                if (!legendItem.label || !legendItem.group) {\n                    return;\n                }\n                const itemLabel = this.chart.langFormat('accessibility.legend.legendItem', {\n                    chart: this.chart,\n                    itemName: stripHTMLTags(item.name),\n                    item\n                });\n                const attribs = {\n                    tabindex: -1,\n                    'aria-pressed': item.visible,\n                    'aria-label': itemLabel\n                };\n                // Considers useHTML\n                const proxyPositioningElement = legendItem.group.div ?\n                    legendItem.label :\n                    legendItem.group;\n                item.a11yProxyElement = this.proxyProvider.addProxyElement('legend', {\n                    click: legendItem.label,\n                    visual: proxyPositioningElement.element\n                }, attribs);\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                const keys = this.keyCodes, component = this, chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.left, keys.right, keys.up, keys.down],\n                            function (keyCode) {\n                                return component.onKbdArrowKey(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onKbdClick(this);\n                            }\n                        ],\n                        [\n                            [keys.pageDown, keys.pageUp],\n                            function (keyCode) {\n                                const direction = keyCode === keys.pageDown ? 1 : -1;\n                                component.highlightAdjacentLegendPage(direction);\n                                return this.response.success;\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return component.shouldHaveLegendNavigation();\n                    },\n                    init: function () {\n                        chart.highlightLegendItem(0);\n                        component.highlightedLegendItemIx = 0;\n                    },\n                    terminate: function () {\n                        component.highlightedLegendItemIx = -1;\n                        chart.legend.allItems.forEach((item) => setLegendItemHoverState(false, item));\n                    }\n                });\n            }\n            /**\n             * Arrow key navigation\n             * @private\n             */\n            onKbdArrowKey(keyboardNavigationHandler, keyCode) {\n                const keys = this.keyCodes, response = keyboardNavigationHandler.response, chart = this.chart, a11yOptions = chart.options.accessibility, numItems = chart.legend.allItems.length, direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1;\n                const res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);\n                if (res) {\n                    this.highlightedLegendItemIx += direction;\n                    return response.success;\n                }\n                if (numItems > 1 &&\n                    a11yOptions.keyboardNavigation.wrapAround) {\n                    keyboardNavigationHandler.init(direction);\n                    return response.success;\n                }\n                return response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdClick(keyboardNavigationHandler) {\n                const legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];\n                if (legendItem && legendItem.a11yProxyElement) {\n                    legendItem.a11yProxyElement.click();\n                }\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             */\n            shouldHaveLegendNavigation() {\n                if (!shouldDoLegendA11y(this.chart)) {\n                    return false;\n                }\n                const chart = this.chart, legendOptions = chart.options.legend || {}, legendA11yOptions = (legendOptions.accessibility || {});\n                return !!(chart.legend.display &&\n                    legendA11yOptions.keyboardNavigation &&\n                    legendA11yOptions.keyboardNavigation.enabled);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (LegendComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Highlight legend item by index.\n             * @private\n             */\n            function chartHighlightLegendItem(ix) {\n                const items = this.legend.allItems;\n                const oldIx = this.accessibility &&\n                    this.accessibility.components.legend.highlightedLegendItemIx;\n                const itemToHighlight = items[ix], legendItem = itemToHighlight.legendItem || {};\n                if (itemToHighlight) {\n                    if (isNumber(oldIx) && items[oldIx]) {\n                        setLegendItemHoverState(false, items[oldIx]);\n                    }\n                    scrollLegendToItem(this.legend, ix);\n                    const legendItemProp = legendItem.label;\n                    const proxyBtn = itemToHighlight.a11yProxyElement &&\n                        itemToHighlight.a11yProxyElement.buttonElement;\n                    if (legendItemProp && legendItemProp.element && proxyBtn) {\n                        this.setFocusToElement(legendItemProp, proxyBtn);\n                    }\n                    setLegendItemHoverState(true, itemToHighlight);\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, LegendClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightLegendItem = chartHighlightLegendItem;\n                }\n                if (U.pushUnique(composedMembers, LegendClass)) {\n                    addEvent(LegendClass, 'afterColorizeItem', legendOnAfterColorizeItem);\n                }\n            }\n            LegendComponent.compose = compose;\n            /**\n             * Keep track of pressed state for legend items.\n             * @private\n             */\n            function legendOnAfterColorizeItem(e) {\n                const chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e.item;\n                if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {\n                    legendItem.a11yProxyElement.buttonElement.setAttribute('aria-pressed', e.visible ? 'true' : 'false');\n                }\n            }\n        })(LegendComponent || (LegendComponent = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return LegendComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesDescriber.js', [_modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/FormatUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (AnnotationsA11y, ChartUtilities, F, HTMLUtilities, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Place desriptions on a series and its points.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getPointAnnotationTexts } = AnnotationsA11y;\n        const { getAxisDescription, getSeriesFirstPointElement, getSeriesA11yElement, unhideChartElementFromAT } = ChartUtilities;\n        const { format, numberFormat } = F;\n        const { reverseChildNodes, stripHTMLTagsFromString: stripHTMLTags } = HTMLUtilities;\n        const { find, isNumber, pick, defined } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function findFirstPointWithGraphic(point) {\n            const sourcePointIndex = point.index;\n            if (!point.series || !point.series.data || !defined(sourcePointIndex)) {\n                return null;\n            }\n            return find(point.series.data, function (p) {\n                return !!(p &&\n                    typeof p.index !== 'undefined' &&\n                    p.index > sourcePointIndex &&\n                    p.graphic &&\n                    p.graphic.element);\n            }) || null;\n        }\n        /**\n         * Whether or not we should add a mock point element in\n         * order to describe a point that has no graphic.\n         * @private\n         */\n        function shouldAddMockPoint(point) {\n            // Note: Sunburst series use isNull for hidden points on drilldown.\n            // Ignore these.\n            const series = point.series, chart = series && series.chart, isSunburst = series && series.is('sunburst'), isNull = point.isNull, shouldDescribeNull = chart &&\n                chart\n                    .options.accessibility.point.describeNull;\n            return isNull && !isSunburst && shouldDescribeNull;\n        }\n        /**\n         * @private\n         */\n        function makeMockElement(point, pos) {\n            const renderer = point.series.chart.renderer, mock = renderer.rect(pos.x, pos.y, 1, 1);\n            mock.attr({\n                'class': 'highcharts-a11y-mock-point',\n                fill: 'none',\n                opacity: 0,\n                'fill-opacity': 0,\n                'stroke-opacity': 0\n            });\n            return mock;\n        }\n        /**\n         * @private\n         */\n        function addMockPointElement(point) {\n            const series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ?\n                firstGraphic.parentGroup :\n                series.graph || series.group, mockPos = firstPointWithGraphic ? {\n                x: pick(point.plotX, firstPointWithGraphic.plotX, 0),\n                y: pick(point.plotY, firstPointWithGraphic.plotY, 0)\n            } : {\n                x: pick(point.plotX, 0),\n                y: pick(point.plotY, 0)\n            }, mockElement = makeMockElement(point, mockPos);\n            if (parentGroup && parentGroup.element) {\n                point.graphic = mockElement;\n                point.hasMockGraphic = true;\n                mockElement.add(parentGroup);\n                // Move to correct pos in DOM\n                parentGroup.element.insertBefore(mockElement.element, firstGraphic ? firstGraphic.element : null);\n                return mockElement.element;\n            }\n        }\n        /**\n         * @private\n         */\n        function hasMorePointsThanDescriptionThreshold(series) {\n            const chartA11yOptions = series.chart.options.accessibility, threshold = (chartA11yOptions.series.pointDescriptionEnabledThreshold);\n            return !!(threshold !== false &&\n                series.points &&\n                series.points.length >= threshold);\n        }\n        /**\n         * @private\n         */\n        function shouldSetScreenReaderPropsOnPoints(series) {\n            const seriesA11yOptions = series.options.accessibility || {};\n            return !hasMorePointsThanDescriptionThreshold(series) &&\n                !seriesA11yOptions.exposeAsGroupOnly;\n        }\n        /**\n         * @private\n         */\n        function shouldSetKeyboardNavPropsOnPoints(series) {\n            const chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;\n            return !!(series.points && (series.points.length <\n                seriesNavOptions.pointNavigationEnabledThreshold ||\n                seriesNavOptions.pointNavigationEnabledThreshold === false));\n        }\n        /**\n         * @private\n         */\n        function shouldDescribeSeriesElement(series) {\n            const chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;\n            return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption ||\n                exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));\n        }\n        /**\n         * @private\n         */\n        function pointNumberToString(point, value) {\n            const series = point.series, chart = series.chart, a11yPointOptions = chart.options.accessibility.point || {}, seriesA11yPointOptions = series.options.accessibility &&\n                series.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, lang = chart.options.lang;\n            if (isNumber(value)) {\n                return numberFormat(value, seriesA11yPointOptions.valueDecimals ||\n                    a11yPointOptions.valueDecimals ||\n                    tooltipOptions.valueDecimals ||\n                    -1, lang.decimalPoint, lang.accessibility.thousandsSep || lang.thousandsSep);\n            }\n            return value;\n        }\n        /**\n         * @private\n         */\n        function getSeriesDescriptionText(series) {\n            const seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;\n            return descOpt && series.chart.langFormat('accessibility.series.description', {\n                description: descOpt,\n                series: series\n            }) || '';\n        }\n        /**\n         * @private\n         */\n        function getSeriesAxisDescriptionText(series, axisCollection) {\n            const axis = series[axisCollection];\n            return series.chart.langFormat('accessibility.series.' + axisCollection + 'Description', {\n                name: getAxisDescription(axis),\n                series: series\n            });\n        }\n        /**\n         * Get accessible time description for a point on a datetime axis.\n         *\n         * @private\n         */\n        function getPointA11yTimeDescription(point) {\n            const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility &&\n                series.options.accessibility.point || {}, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;\n            if (dateXAxis) {\n                const tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat = seriesA11yOptions.dateFormatter &&\n                    seriesA11yOptions.dateFormatter(point) ||\n                    a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) ||\n                    seriesA11yOptions.dateFormat ||\n                    a11yOptions.dateFormat ||\n                    tooltipDateFormat;\n                return chart.time.dateFormat(dateFormat, point.x || 0, void 0);\n            }\n        }\n        /**\n         * @private\n         */\n        function getPointXDescription(point) {\n            const timeDesc = getPointA11yTimeDescription(point), xAxis = point.series.xAxis || {}, pointCategory = xAxis.categories && defined(point.category) &&\n                ('' + point.category).replace('<br/>', ' '), canUseId = defined(point.id) &&\n                ('' + point.id).indexOf('highcharts-') < 0, fallback = 'x, ' + point.x;\n            return point.name || timeDesc || pointCategory ||\n                (canUseId ? point.id : fallback);\n        }\n        /**\n         * @private\n         */\n        function getPointArrayMapValueDescription(point, prefix, suffix) {\n            const pre = prefix || '', suf = suffix || '', keyToValStr = function (key) {\n                const num = pointNumberToString(point, pick(point[key], point.options[key]));\n                return num !== void 0 ?\n                    key + ': ' + pre + num + suf :\n                    num;\n            }, pointArrayMap = point.series.pointArrayMap;\n            return pointArrayMap.reduce(function (desc, key) {\n                const propDesc = keyToValStr(key);\n                return propDesc ?\n                    (desc + (desc.length ? ', ' : '') + propDesc) :\n                    desc;\n            }, '');\n        }\n        /**\n         * @private\n         */\n        function getPointValue(point) {\n            const series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, seriesA11yPointOpts = series.chart.options.accessibility &&\n                series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = seriesA11yPointOpts.valuePrefix ||\n                a11yPointOpts.valuePrefix ||\n                tooltipOptions.valuePrefix ||\n                '', valueSuffix = seriesA11yPointOpts.valueSuffix ||\n                a11yPointOpts.valueSuffix ||\n                tooltipOptions.valueSuffix ||\n                '', fallbackKey = (typeof point.value !==\n                'undefined' ?\n                'value' : 'y'), fallbackDesc = pointNumberToString(point, point[fallbackKey]);\n            if (point.isNull) {\n                return series.chart.langFormat('accessibility.series.nullPointValue', {\n                    point: point\n                });\n            }\n            if (series.pointArrayMap) {\n                return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);\n            }\n            return valuePrefix + fallbackDesc + valueSuffix;\n        }\n        /**\n         * Return the description for the annotation(s) connected to a point, or\n         * empty string if none.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         * The data point to get the annotation info from.\n         * @return {string}\n         * Annotation description\n         */\n        function getPointAnnotationDescription(point) {\n            const chart = point.series.chart;\n            const langKey = 'accessibility.series.pointAnnotationsDescription';\n            const annotations = getPointAnnotationTexts(point);\n            const context = { point, annotations };\n            return annotations.length ? chart.langFormat(langKey, context) : '';\n        }\n        /**\n         * Return string with information about point.\n         * @private\n         */\n        function getPointValueDescription(point) {\n            const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility, seriesValueDescFormat = seriesA11yOptions && seriesA11yOptions.point &&\n                seriesA11yOptions.point.valueDescriptionFormat, pointValueDescriptionFormat = seriesValueDescFormat ||\n                chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick(series.xAxis &&\n                series.xAxis.options.accessibility &&\n                series.xAxis.options.accessibility.enabled, !chart.angular && series.type !== 'flowmap'), xDesc = showXDescription ? getPointXDescription(point) : '', context = {\n                point: point,\n                index: defined(point.index) ? (point.index + 1) : '',\n                xDescription: xDesc,\n                value: getPointValue(point),\n                separator: showXDescription ? ', ' : ''\n            };\n            return format(pointValueDescriptionFormat, context, chart);\n        }\n        /**\n         * Return string with information about point.\n         * @private\n         */\n        function defaultPointDescriptionFormatter(point) {\n            const series = point.series, shouldExposeSeriesName = series.chart.series.length > 1 ||\n                series.options.name, valText = getPointValueDescription(point), description = point.options && point.options.accessibility &&\n                point.options.accessibility.description, userDescText = description ? ' ' + description : '', seriesNameText = shouldExposeSeriesName ? ' ' + series.name + '.' : '', annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? ' ' + annotationsDesc : '';\n            point.accessibility = point.accessibility || {};\n            point.accessibility.valueDescription = valText;\n            return valText + userDescText + seriesNameText + pointAnnotationsText;\n        }\n        /**\n         * Set a11y props on a point element\n         * @private\n         * @param {Highcharts.Point} point\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} pointElement\n         */\n        function setPointScreenReaderAttribs(point, pointElement) {\n            const series = point.series, a11yPointOptions = series.chart.options.accessibility.point || {}, seriesPointA11yOptions = series.options.accessibility &&\n                series.options.accessibility.point || {}, label = stripHTMLTags(seriesPointA11yOptions.descriptionFormatter &&\n                seriesPointA11yOptions.descriptionFormatter(point) ||\n                a11yPointOptions.descriptionFormatter &&\n                    a11yPointOptions.descriptionFormatter(point) ||\n                defaultPointDescriptionFormatter(point));\n            pointElement.setAttribute('role', 'img');\n            pointElement.setAttribute('aria-label', label);\n        }\n        /**\n         * Add accessible info to individual point elements of a series\n         * @private\n         * @param {Highcharts.Series} series\n         */\n        function describePointsInSeries(series) {\n            const setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series), shouldDescribeNullPoints = series.chart.options.accessibility\n                .point.describeNull;\n            if (setScreenReaderProps || setKeyboardProps) {\n                series.points.forEach((point) => {\n                    const pointEl = point.graphic && point.graphic.element ||\n                        shouldAddMockPoint(point) && addMockPointElement(point), pointA11yDisabled = (point.options &&\n                        point.options.accessibility &&\n                        point.options.accessibility.enabled === false);\n                    if (pointEl) {\n                        if (point.isNull && !shouldDescribeNullPoints) {\n                            pointEl.setAttribute('aria-hidden', true);\n                            return;\n                        }\n                        // We always set tabindex, as long as we are setting props.\n                        // When setting tabindex, also remove default outline to\n                        // avoid ugly border on click.\n                        pointEl.setAttribute('tabindex', '-1');\n                        if (!series.chart.styledMode) {\n                            pointEl.style.outline = 'none';\n                        }\n                        if (setScreenReaderProps && !pointA11yDisabled) {\n                            setPointScreenReaderAttribs(point, pointEl);\n                        }\n                        else {\n                            pointEl.setAttribute('aria-hidden', true);\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Return string with information about series.\n         * @private\n         */\n        function defaultSeriesDescriptionFormatter(series) {\n            const chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function (coll) {\n                return chart[coll] && chart[coll].length > 1 && series[coll];\n            }, seriesNumber = series.index + 1, xAxisInfo = getSeriesAxisDescriptionText(series, 'xAxis'), yAxisInfo = getSeriesAxisDescriptionText(series, 'yAxis'), summaryContext = {\n                seriesNumber,\n                series,\n                chart\n            }, combinationSuffix = chartTypes.length > 1 ? 'Combination' : '', summary = chart.langFormat('accessibility.series.summary.' + series.type + combinationSuffix, summaryContext) || chart.langFormat('accessibility.series.summary.default' + combinationSuffix, summaryContext), axisDescription = (shouldDescribeAxis('yAxis') ? ' ' + yAxisInfo + '.' : '') + (shouldDescribeAxis('xAxis') ? ' ' + xAxisInfo + '.' : ''), formatStr = pick(series.options.accessibility &&\n                series.options.accessibility.descriptionFormat, chart.options.accessibility.series.descriptionFormat, '');\n            return format(formatStr, {\n                seriesDescription: summary,\n                authorDescription: (description ? ' ' + description : ''),\n                axisDescription,\n                series,\n                chart,\n                seriesNumber\n            }, void 0);\n        }\n        /**\n         * Set a11y props on a series element\n         * @private\n         * @param {Highcharts.Series} series\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} seriesElement\n         */\n        function describeSeriesElement(series, seriesElement) {\n            const seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;\n            // Handle role attribute\n            if (seriesA11yOptions.exposeAsGroupOnly) {\n                seriesElement.setAttribute('role', 'img');\n            }\n            else if (landmarkVerbosity === 'all') {\n                seriesElement.setAttribute('role', 'region');\n            }\n            else {\n                seriesElement.setAttribute('role', 'group');\n            }\n            seriesElement.setAttribute('tabindex', '-1');\n            if (!series.chart.styledMode) {\n                // Don't show browser outline on click, despite tabindex\n                seriesElement.style.outline = 'none';\n            }\n            seriesElement.setAttribute('aria-label', stripHTMLTags(a11yOptions.series.descriptionFormatter &&\n                a11yOptions.series.descriptionFormatter(series) ||\n                defaultSeriesDescriptionFormatter(series)));\n        }\n        /**\n         * Put accessible info on series and points of a series.\n         * @param {Highcharts.Series} series The series to add info on.\n         */\n        function describeSeries(series) {\n            const chart = series.chart, firstPointEl = getSeriesFirstPointElement(series), seriesEl = getSeriesA11yElement(series), is3d = chart.is3d && chart.is3d();\n            if (seriesEl) {\n                // For some series types the order of elements do not match the\n                // order of points in series. In that case we have to reverse them\n                // in order for AT to read them out in an understandable order.\n                // Due to z-index issues we cannot do this for 3D charts.\n                if (seriesEl.lastChild === firstPointEl && !is3d) {\n                    reverseChildNodes(seriesEl);\n                }\n                describePointsInSeries(series);\n                unhideChartElementFromAT(chart, seriesEl);\n                if (shouldDescribeSeriesElement(series)) {\n                    describeSeriesElement(series, seriesEl);\n                }\n                else {\n                    seriesEl.removeAttribute('aria-label');\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const SeriesDescriber = {\n            defaultPointDescriptionFormatter,\n            defaultSeriesDescriptionFormatter,\n            describeSeries\n        };\n\n        return SeriesDescriber;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/NewDataAnnouncer.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function (H, U, Announcer, ChartUtilities, EventProvider, SeriesDescriber) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Handle announcing new data for a chart.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined } = U;\n        const { getChartTitle } = ChartUtilities;\n        const { defaultPointDescriptionFormatter, defaultSeriesDescriptionFormatter } = SeriesDescriber;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function chartHasAnnounceEnabled(chart) {\n            return !!chart.options.accessibility.announceNewData.enabled;\n        }\n        /**\n         * @private\n         */\n        function findPointInDataArray(point) {\n            const candidates = point.series.data.filter((candidate) => (point.x === candidate.x && point.y === candidate.y));\n            return candidates.length === 1 ? candidates[0] : point;\n        }\n        /**\n         * Get array of unique series from two arrays\n         * @private\n         */\n        function getUniqueSeries(arrayA, arrayB) {\n            const uniqueSeries = (arrayA || []).concat(arrayB || []).reduce((acc, cur) => {\n                acc[cur.name + cur.index] = cur;\n                return acc;\n            }, {});\n            return Object\n                .keys(uniqueSeries)\n                .map((ix) => uniqueSeries[ix]);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class NewDataAnnouncer {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Public\n                 *\n                 * */\n                this.announcer = void 0;\n                this.dirty = {\n                    allSeries: {}\n                };\n                this.eventProvider = void 0;\n                this.lastAnnouncementTime = 0;\n                this.chart = chart;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the new data announcer.\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                const announceOptions = (chart.options.accessibility.announceNewData);\n                const announceType = announceOptions.interruptUser ?\n                    'assertive' : 'polite';\n                this.lastAnnouncementTime = 0;\n                this.dirty = {\n                    allSeries: {}\n                };\n                this.eventProvider = new EventProvider();\n                this.announcer = new Announcer(chart, announceType);\n                this.addEventListeners();\n            }\n            /**\n             * Remove traces of announcer.\n             * @private\n             */\n            destroy() {\n                this.eventProvider.removeAddedEvents();\n                this.announcer.destroy();\n            }\n            /**\n             * Add event listeners for the announcer\n             * @private\n             */\n            addEventListeners() {\n                const announcer = this, chart = this.chart, e = this.eventProvider;\n                e.addEvent(chart, 'afterApplyDrilldown', function () {\n                    announcer.lastAnnouncementTime = 0;\n                });\n                e.addEvent(chart, 'afterAddSeries', function (e) {\n                    announcer.onSeriesAdded(e.series);\n                });\n                e.addEvent(chart, 'redraw', function () {\n                    announcer.announceDirtyData();\n                });\n            }\n            /**\n             * On new data series added, update dirty list.\n             * @private\n             * @param {Highcharts.Series} series\n             */\n            onSeriesAdded(series) {\n                if (chartHasAnnounceEnabled(this.chart)) {\n                    this.dirty.hasDirty = true;\n                    this.dirty.allSeries[series.name + series.index] = series;\n                    // Add it to newSeries storage unless we already have one\n                    this.dirty.newSeries = defined(this.dirty.newSeries) ?\n                        void 0 : series;\n                }\n            }\n            /**\n             * Gather what we know and announce the data to user.\n             * @private\n             */\n            announceDirtyData() {\n                const chart = this.chart, announcer = this;\n                if (chart.options.accessibility.announceNewData &&\n                    this.dirty.hasDirty) {\n                    let newPoint = this.dirty.newPoint;\n                    // If we have a single new point, see if we can find it in the\n                    // data array. Otherwise we can only pass through options to\n                    // the description builder, and it is a bit sparse in info.\n                    if (newPoint) {\n                        newPoint = findPointInDataArray(newPoint);\n                    }\n                    this.queueAnnouncement(Object\n                        .keys(this.dirty.allSeries)\n                        .map((ix) => announcer.dirty.allSeries[ix]), this.dirty.newSeries, newPoint);\n                    // Reset\n                    this.dirty = {\n                        allSeries: {}\n                    };\n                }\n            }\n            /**\n             * Announce to user that there is new data.\n             * @private\n             * @param {Array<Highcharts.Series>} dirtySeries\n             *          Array of series with new data.\n             * @param {Highcharts.Series} [newSeries]\n             *          If a single new series was added, a reference to this series.\n             * @param {Highcharts.Point} [newPoint]\n             *          If a single point was added, a reference to this point.\n             */\n            queueAnnouncement(dirtySeries, newSeries, newPoint) {\n                const chart = this.chart;\n                const annOptions = chart.options.accessibility.announceNewData;\n                if (annOptions.enabled) {\n                    const now = +new Date();\n                    const dTime = now - this.lastAnnouncementTime;\n                    const time = Math.max(0, annOptions.minAnnounceInterval - dTime);\n                    // Add series from previously queued announcement.\n                    const allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);\n                    // Build message and announce\n                    const message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);\n                    if (message) {\n                        // Is there already one queued?\n                        if (this.queuedAnnouncement) {\n                            clearTimeout(this.queuedAnnouncementTimer);\n                        }\n                        // Build the announcement\n                        this.queuedAnnouncement = {\n                            time: now,\n                            message: message,\n                            series: allSeries\n                        };\n                        // Queue the announcement\n                        this.queuedAnnouncementTimer = setTimeout(() => {\n                            if (this && this.announcer) {\n                                this.lastAnnouncementTime = +new Date();\n                                this.announcer.announce(this.queuedAnnouncement.message);\n                                delete this.queuedAnnouncement;\n                                delete this.queuedAnnouncementTimer;\n                            }\n                        }, time);\n                    }\n                }\n            }\n            /**\n             * Get announcement message for new data.\n             * @private\n             * @param {Array<Highcharts.Series>} dirtySeries\n             *          Array of series with new data.\n             * @param {Highcharts.Series} [newSeries]\n             *          If a single new series was added, a reference to this series.\n             * @param {Highcharts.Point} [newPoint]\n             *          If a single point was added, a reference to this point.\n             *\n             * @return {string|null}\n             * The announcement message to give to user.\n             */\n            buildAnnouncementMessage(dirtySeries, newSeries, newPoint) {\n                const chart = this.chart, annOptions = chart.options.accessibility.announceNewData;\n                // User supplied formatter?\n                if (annOptions.announcementFormatter) {\n                    const formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);\n                    if (formatterRes !== false) {\n                        return formatterRes.length ? formatterRes : null;\n                    }\n                }\n                // Default formatter - use lang options\n                const multiple = H.charts && H.charts.length > 1 ?\n                    'Multiple' : 'Single', langKey = newSeries ? 'newSeriesAnnounce' + multiple :\n                    newPoint ? 'newPointAnnounce' + multiple : 'newDataAnnounce', chartTitle = getChartTitle(chart);\n                return chart.langFormat('accessibility.announceNewData.' + langKey, {\n                    chartTitle: chartTitle,\n                    seriesDesc: newSeries ?\n                        defaultSeriesDescriptionFormatter(newSeries) :\n                        null,\n                    pointDesc: newPoint ?\n                        defaultPointDescriptionFormatter(newPoint) :\n                        null,\n                    point: newPoint,\n                    series: newSeries\n                });\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (NewDataAnnouncer) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            NewDataAnnouncer.composedMembers = [];\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            function compose(SeriesClass) {\n                if (U.pushUnique(NewDataAnnouncer.composedMembers, SeriesClass)) {\n                    addEvent(SeriesClass, 'addPoint', seriesOnAddPoint);\n                    addEvent(SeriesClass, 'updatedData', seriesOnUpdatedData);\n                }\n            }\n            NewDataAnnouncer.compose = compose;\n            /**\n             * On new point added, update dirty list.\n             * @private\n             * @param {Highcharts.Point} point\n             */\n            function seriesOnAddPoint(e) {\n                const chart = this.chart, newDataAnnouncer = this.newDataAnnouncer;\n                if (newDataAnnouncer &&\n                    newDataAnnouncer.chart === chart &&\n                    chartHasAnnounceEnabled(chart)) {\n                    // Add it to newPoint storage unless we already have one\n                    newDataAnnouncer.dirty.newPoint = (defined(newDataAnnouncer.dirty.newPoint) ?\n                        void 0 :\n                        e.point);\n                }\n            }\n            /**\n             * On new data in the series, make sure we add it to the dirty list.\n             * @private\n             * @param {Highcharts.Series} series\n             */\n            function seriesOnUpdatedData() {\n                const chart = this.chart, newDataAnnouncer = this.newDataAnnouncer;\n                if (newDataAnnouncer &&\n                    newDataAnnouncer.chart === chart &&\n                    chartHasAnnounceEnabled(chart)) {\n                    newDataAnnouncer.dirty.hasDirty = true;\n                    newDataAnnouncer.dirty.allSeries[this.name + this.index] = this;\n                }\n            }\n        })(NewDataAnnouncer || (NewDataAnnouncer = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NewDataAnnouncer;\n    });\n    _registerModule(_modules, 'Accessibility/ProxyElement.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, U, EventProvider, ChartUtilities, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Proxy elements are used to shadow SVG elements in HTML for assistive\n         *  technology, such as screen readers or voice input software.\n         *\n         *  The ProxyElement class represents such an element, and deals with\n         *  overlay positioning and mirroring events for the target.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { attr, css, merge } = U;\n        const { fireEventOnWrappedOrUnwrappedElement } = ChartUtilities;\n        const { cloneMouseEvent, cloneTouchEvent, getFakeMouseEvent, removeElement } = HTMLUtilities;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Represents a proxy element that overlays a target and relays events\n         * to its target.\n         *\n         * @private\n         * @class\n         */\n        class ProxyElement {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, target, groupType, attributes) {\n                this.chart = chart;\n                this.target = target;\n                this.groupType = groupType;\n                const isListItem = groupType === 'ul';\n                this.eventProvider = new EventProvider();\n                const wrapperEl = isListItem ? doc.createElement('li') : null;\n                const btnEl = this.buttonElement = doc.createElement('button');\n                if (!chart.styledMode) {\n                    this.hideButtonVisually(btnEl);\n                }\n                if (wrapperEl) {\n                    if (isListItem && !chart.styledMode) {\n                        wrapperEl.style.listStyle = 'none';\n                    }\n                    wrapperEl.appendChild(btnEl);\n                    this.element = wrapperEl;\n                }\n                else {\n                    this.element = btnEl;\n                }\n                this.updateTarget(target, attributes);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Fake a click event on the target.\n             */\n            click() {\n                const pos = this.getTargetPosition();\n                pos.x += pos.width / 2;\n                pos.y += pos.height / 2;\n                const fakeEventObject = getFakeMouseEvent('click', pos);\n                fireEventOnWrappedOrUnwrappedElement(this.target.click, fakeEventObject);\n            }\n            /**\n             * Update the target to be proxied. The position and events are updated to\n             * match the new target.\n             * @param target The new target definition\n             * @param attributes New HTML attributes to apply to the button. Set an\n             * attribute to null to remove.\n             */\n            updateTarget(target, attributes) {\n                this.target = target;\n                this.updateCSSClassName();\n                const attrs = attributes || {};\n                Object.keys(attrs).forEach((a) => {\n                    if (attrs[a] === null) {\n                        delete attrs[a];\n                    }\n                });\n                attr(this.buttonElement, merge({\n                    'aria-label': this.getTargetAttr(target.click, 'aria-label')\n                }, attrs));\n                this.eventProvider.removeAddedEvents();\n                this.addProxyEventsToButton(this.buttonElement, target.click);\n                this.refreshPosition();\n            }\n            /**\n             * Refresh the position of the proxy element to match the current target\n             */\n            refreshPosition() {\n                const bBox = this.getTargetPosition();\n                css(this.buttonElement, {\n                    width: (bBox.width || 1) + 'px',\n                    height: (bBox.height || 1) + 'px',\n                    left: (Math.round(bBox.x) || 0) + 'px',\n                    top: (Math.round(bBox.y) || 0) + 'px'\n                });\n            }\n            /**\n             * Remove button from DOM, and clear events.\n             */\n            remove() {\n                this.eventProvider.removeAddedEvents();\n                removeElement(this.element);\n            }\n            // -------------------------- private ------------------------------------\n            /**\n             * Update the CSS class name to match target\n             */\n            updateCSSClassName() {\n                const stringHasNoTooltip = (s) => (s.indexOf('highcharts-no-tooltip') > -1);\n                const legend = this.chart.legend;\n                const groupDiv = legend.group && legend.group.div;\n                const noTooltipOnGroup = stringHasNoTooltip(groupDiv && groupDiv.className || '');\n                const targetClassName = this.getTargetAttr(this.target.click, 'class') || '';\n                const noTooltipOnTarget = stringHasNoTooltip(targetClassName);\n                this.buttonElement.className = noTooltipOnGroup || noTooltipOnTarget ?\n                    'highcharts-a11y-proxy-button highcharts-no-tooltip' :\n                    'highcharts-a11y-proxy-button';\n            }\n            /**\n             * Mirror events for a proxy button to a target\n             */\n            addProxyEventsToButton(button, target) {\n                [\n                    'click', 'touchstart', 'touchend', 'touchcancel', 'touchmove',\n                    'mouseover', 'mouseenter', 'mouseleave', 'mouseout'\n                ].forEach((evtType) => {\n                    const isTouchEvent = evtType.indexOf('touch') === 0;\n                    this.eventProvider.addEvent(button, evtType, (e) => {\n                        const clonedEvent = isTouchEvent ?\n                            cloneTouchEvent(e) :\n                            cloneMouseEvent(e);\n                        if (target) {\n                            fireEventOnWrappedOrUnwrappedElement(target, clonedEvent);\n                        }\n                        e.stopPropagation();\n                        // #9682, #15318: Touch scrolling didnt work when touching\n                        // proxy\n                        if (!isTouchEvent) {\n                            e.preventDefault();\n                        }\n                    }, { passive: false });\n                });\n            }\n            /**\n             * Set visually hidden style on a proxy button\n             */\n            hideButtonVisually(button) {\n                css(button, {\n                    borderWidth: 0,\n                    backgroundColor: 'transparent',\n                    cursor: 'pointer',\n                    outline: 'none',\n                    opacity: 0.001,\n                    filter: 'alpha(opacity=1)',\n                    zIndex: 999,\n                    overflow: 'hidden',\n                    padding: 0,\n                    margin: 0,\n                    display: 'block',\n                    position: 'absolute',\n                    '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)'\n                });\n            }\n            /**\n             * Get the position relative to chart container for the target\n             */\n            getTargetPosition() {\n                const clickTarget = this.target.click;\n                // We accept both DOM elements and wrapped elements as click targets.\n                const clickTargetElement = clickTarget.element ?\n                    clickTarget.element :\n                    clickTarget;\n                const posElement = this.target.visual || clickTargetElement;\n                const chartDiv = this.chart.renderTo;\n                if (chartDiv && posElement && posElement.getBoundingClientRect) {\n                    const rectEl = posElement.getBoundingClientRect(), chartPos = this.chart.pointer.getChartPosition();\n                    return {\n                        x: (rectEl.left - chartPos.left) / chartPos.scaleX,\n                        y: (rectEl.top - chartPos.top) / chartPos.scaleY,\n                        width: rectEl.right / chartPos.scaleX -\n                            rectEl.left / chartPos.scaleX,\n                        height: rectEl.bottom / chartPos.scaleY -\n                            rectEl.top / chartPos.scaleY\n                    };\n                }\n                return { x: 0, y: 0, width: 1, height: 1 };\n            }\n            /**\n             * Get an attribute value of a target\n             */\n            getTargetAttr(target, key) {\n                if (target.element) {\n                    return target.element.getAttribute(key);\n                }\n                return target.getAttribute(key);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ProxyElement;\n    });\n    _registerModule(_modules, 'Accessibility/ProxyProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/ProxyElement.js']], function (H, U, CU, DOMElementProvider, HU, ProxyElement) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Proxy elements are used to shadow SVG elements in HTML for assistive\n         *  technology, such as screen readers or voice input software.\n         *\n         *  The ProxyProvider keeps track of all proxy elements of the a11y module,\n         *  and updating their order and positioning.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { attr, css } = U;\n        const { unhideChartElementFromAT } = CU;\n        const { removeElement, removeChildNodes } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Keeps track of all proxy elements and proxy groups.\n         *\n         * @private\n         * @class\n         */\n        class ProxyProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.chart = chart;\n                this.domElementProvider = new DOMElementProvider();\n                this.groups = {};\n                this.groupOrder = [];\n                this.beforeChartProxyPosContainer = this.createProxyPosContainer('before');\n                this.afterChartProxyPosContainer = this.createProxyPosContainer('after');\n                this.update();\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable */\n            /**\n             * Add a new proxy element to a group, proxying a target control.\n             */\n            addProxyElement(groupKey, target, attributes) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.addProxyElement: Invalid group key ' + groupKey);\n                }\n                const proxy = new ProxyElement(this.chart, target, group.type, attributes);\n                group.proxyContainerElement.appendChild(proxy.element);\n                group.proxyElements.push(proxy);\n                return proxy;\n            }\n            /**\n             * Create a group that will contain proxy elements. The group order is\n             * automatically updated according to the last group order keys.\n             *\n             * Returns the added group.\n             */\n            addGroup(groupKey, groupType, attributes) {\n                const existingGroup = this.groups[groupKey];\n                if (existingGroup) {\n                    return existingGroup.groupElement;\n                }\n                const proxyContainer = this.domElementProvider.createElement(groupType);\n                // If we want to add a role to the group, and still use e.g.\n                // a list group, we need a wrapper div.\n                let groupElement;\n                if (attributes && attributes.role && groupType !== 'div') {\n                    groupElement = this.domElementProvider.createElement('div');\n                    groupElement.appendChild(proxyContainer);\n                }\n                else {\n                    groupElement = proxyContainer;\n                }\n                groupElement.className = 'highcharts-a11y-proxy-group highcharts-a11y-proxy-group-' +\n                    groupKey.replace(/\\W/g, '-');\n                this.groups[groupKey] = {\n                    proxyContainerElement: proxyContainer,\n                    groupElement,\n                    type: groupType,\n                    proxyElements: []\n                };\n                attr(groupElement, attributes || {});\n                if (groupType === 'ul') {\n                    proxyContainer.setAttribute('role', 'list'); // Needed for webkit\n                }\n                // Add the group to the end by default, and perhaps then we\n                // won't have to reorder the whole set of groups.\n                this.afterChartProxyPosContainer.appendChild(groupElement);\n                this.updateGroupOrder(this.groupOrder);\n                return groupElement;\n            }\n            /**\n             * Update HTML attributes of a group.\n             */\n            updateGroupAttrs(groupKey, attributes) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.updateGroupAttrs: Invalid group key ' + groupKey);\n                }\n                attr(group.groupElement, attributes);\n            }\n            /**\n             * Reorder the proxy groups.\n             *\n             * The group key \"series\" refers to the chart's data points / <svg> element.\n             * This is so that the keyboardNavigation.order option can be used to\n             * determine the proxy group order.\n             */\n            updateGroupOrder(groupKeys) {\n                // Store so that we can update order when a new group is created\n                this.groupOrder = groupKeys.slice();\n                // Don't unnecessarily reorder, because keyboard focus is lost\n                if (this.isDOMOrderGroupOrder()) {\n                    return;\n                }\n                const seriesIx = groupKeys.indexOf('series');\n                const beforeKeys = seriesIx > -1 ? groupKeys.slice(0, seriesIx) : groupKeys;\n                const afterKeys = seriesIx > -1 ? groupKeys.slice(seriesIx + 1) : [];\n                // Store focused element since it will be lost when reordering\n                const activeElement = doc.activeElement;\n                // Add groups to correct container\n                ['before', 'after'].forEach((pos) => {\n                    const posContainer = this[pos === 'before' ?\n                        'beforeChartProxyPosContainer' :\n                        'afterChartProxyPosContainer'];\n                    const keys = pos === 'before' ? beforeKeys : afterKeys;\n                    removeChildNodes(posContainer);\n                    keys.forEach((groupKey) => {\n                        const group = this.groups[groupKey];\n                        if (group) {\n                            posContainer.appendChild(group.groupElement);\n                        }\n                    });\n                });\n                // Attempt to restore focus after reordering, but note that this may\n                // cause screen readers re-announcing the button.\n                if ((this.beforeChartProxyPosContainer.contains(activeElement) ||\n                    this.afterChartProxyPosContainer.contains(activeElement)) &&\n                    activeElement && activeElement.focus) {\n                    activeElement.focus();\n                }\n            }\n            /**\n             * Remove all proxy elements in a group\n             */\n            clearGroup(groupKey) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.clearGroup: Invalid group key ' + groupKey);\n                }\n                removeChildNodes(group.proxyContainerElement);\n            }\n            /**\n             * Remove a group from the DOM and from the proxy provider's group list.\n             * All child elements are removed.\n             * If the group does not exist, nothing happens.\n             */\n            removeGroup(groupKey) {\n                const group = this.groups[groupKey];\n                if (group) {\n                    removeElement(group.groupElement);\n                    delete this.groups[groupKey];\n                }\n            }\n            /**\n             * Update the position and order of all proxy groups and elements\n             */\n            update() {\n                this.updatePosContainerPositions();\n                this.updateGroupOrder(this.groupOrder);\n                this.updateProxyElementPositions();\n            }\n            /**\n             * Update all proxy element positions\n             */\n            updateProxyElementPositions() {\n                Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));\n            }\n            /**\n             * Update a group's proxy elements' positions.\n             * If the group does not exist, nothing happens.\n             */\n            updateGroupProxyElementPositions(groupKey) {\n                const group = this.groups[groupKey];\n                if (group) {\n                    group.proxyElements.forEach((el) => el.refreshPosition());\n                }\n            }\n            /**\n             * Remove all added elements\n             */\n            destroy() {\n                this.domElementProvider.destroyCreatedElements();\n            }\n            // -------------------------- private ------------------------------------\n            /**\n             * Create and return a pos container element (the overall containers for\n             * the proxy groups).\n             */\n            createProxyPosContainer(classNamePostfix) {\n                const el = this.domElementProvider.createElement('div');\n                el.setAttribute('aria-hidden', 'false');\n                el.className = 'highcharts-a11y-proxy-container' + (classNamePostfix ? '-' + classNamePostfix : '');\n                css(el, {\n                    top: '0',\n                    left: '0'\n                });\n                if (!this.chart.styledMode) {\n                    el.style.whiteSpace = 'nowrap';\n                    el.style.position = 'absolute';\n                }\n                return el;\n            }\n            /**\n             * Get an array of group keys that corresponds to the current group order\n             * in the DOM.\n             */\n            getCurrentGroupOrderInDOM() {\n                const getGroupKeyFromElement = (el) => {\n                    const allGroups = Object.keys(this.groups);\n                    let i = allGroups.length;\n                    while (i--) {\n                        const groupKey = allGroups[i];\n                        const group = this.groups[groupKey];\n                        if (group && el === group.groupElement) {\n                            return groupKey;\n                        }\n                    }\n                };\n                const getChildrenGroupOrder = (el) => {\n                    const childrenOrder = [];\n                    const children = el.children;\n                    for (let i = 0; i < children.length; ++i) {\n                        const groupKey = getGroupKeyFromElement(children[i]);\n                        if (groupKey) {\n                            childrenOrder.push(groupKey);\n                        }\n                    }\n                    return childrenOrder;\n                };\n                const before = getChildrenGroupOrder(this.beforeChartProxyPosContainer);\n                const after = getChildrenGroupOrder(this.afterChartProxyPosContainer);\n                before.push('series');\n                return before.concat(after);\n            }\n            /**\n             * Check if the current DOM order matches the current group order, so that\n             * a reordering/update is unnecessary.\n             */\n            isDOMOrderGroupOrder() {\n                const domOrder = this.getCurrentGroupOrderInDOM();\n                const groupOrderWithGroups = this.groupOrder.filter((x) => x === 'series' || !!this.groups[x]);\n                let i = domOrder.length;\n                if (i !== groupOrderWithGroups.length) {\n                    return false;\n                }\n                while (i--) {\n                    if (domOrder[i] !== groupOrderWithGroups[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * Update the DOM positions of the before/after proxy\n             * positioning containers for the groups.\n             */\n            updatePosContainerPositions() {\n                const chart = this.chart;\n                // If exporting, don't add these containers to the DOM.\n                if (chart.renderer.forExport) {\n                    return;\n                }\n                const rendererSVGEl = chart.renderer.box;\n                chart.container.insertBefore(this.afterChartProxyPosContainer, rendererSVGEl.nextSibling);\n                chart.container.insertBefore(this.beforeChartProxyPosContainer, rendererSVGEl);\n                unhideChartElementFromAT(this.chart, this.afterChartProxyPosContainer);\n                unhideChartElementFromAT(this.chart, this.beforeChartProxyPosContainer);\n            }\n        }\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n\n        return ProxyProvider;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Declarations\n         *\n         * */\n        /**\n         * Language object. The language object is global and it can't be set\n         * on each chart initialization. Instead, use `Highcharts.setOptions` to\n         * set it before any chart is initialized.\n         *\n         * ```js\n         * Highcharts.setOptions({\n         *     lang: {\n         *         months: [\n         *             'Janvier', 'Fvrier', 'Mars', 'Avril',\n         *             'Mai', 'Juin', 'Juillet', 'Aot',\n         *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'\n         *         ],\n         *         weekdays: [\n         *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',\n         *             'Jeudi', 'Vendredi', 'Samedi'\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * @optionparent lang\n         */\n        const lang = {\n            /**\n             * The text for the label for the range selector buttons.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorZoom: 'Zoom',\n            /**\n             * The text for the label for the \"from\" input box in the range\n             * selector. Since v9.0, this string is empty as the label is not\n             * rendered by default.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorFrom: '',\n            /**\n             * The text for the label for the \"to\" input box in the range selector.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorTo: ''\n        };\n        /**\n         * The range selector is a tool for selecting ranges to display within\n         * the chart. It provides buttons to select preconfigured ranges in\n         * the chart, like 1 day, 1 week, 1 month etc. It also provides input\n         * boxes where min and max dates can be manually input.\n         *\n         * @product      highstock gantt\n         * @optionparent rangeSelector\n         */\n        const rangeSelector = {\n            /**\n             * Whether to enable all buttons from the start. By default buttons are\n             * only enabled if the corresponding time range exists on the X axis,\n             * but enabling all buttons allows for dynamically loading different\n             * time ranges.\n             *\n             * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/\n             *         All buttons enabled\n             *\n             * @since     2.0.3\n             */\n            allButtonsEnabled: false,\n            /**\n             * An array of configuration objects for the buttons.\n             *\n             * Defaults to:\n             * ```js\n             * buttons: [{\n             *     type: 'month',\n             *     count: 1,\n             *     text: '1m',\n             *     title: 'View 1 month'\n             * }, {\n             *     type: 'month',\n             *     count: 3,\n             *     text: '3m',\n             *     title: 'View 3 months'\n             * }, {\n             *     type: 'month',\n             *     count: 6,\n             *     text: '6m',\n             *     title: 'View 6 months'\n             * }, {\n             *     type: 'ytd',\n             *     text: 'YTD',\n             *     title: 'View year to date'\n             * }, {\n             *     type: 'year',\n             *     count: 1,\n             *     text: '1y',\n             *     title: 'View 1 year'\n             * }, {\n             *     type: 'all',\n             *     text: 'All',\n             *     title: 'View all'\n             * }]\n             * ```\n             *\n             * @sample {highstock} stock/rangeselector/datagrouping/\n             *         Data grouping by buttons\n             *\n             * @type      {Array<*>}\n             */\n            buttons: void 0,\n            /**\n             * How many units of the defined type the button should span. If `type`\n             * is \"month\" and `count` is 3, the button spans three months.\n             *\n             * @type      {number}\n             * @default   1\n             * @apioption rangeSelector.buttons.count\n             */\n            /**\n             * Fires when clicking on the rangeSelector button. One parameter,\n             * event, is passed to the function, containing common event\n             * information.\n             *\n             * ```js\n             * click: function(e) {\n             *   console.log(this);\n             * }\n             * ```\n             *\n             * Return false to stop default button's click action.\n             *\n             * @sample {highstock} stock/rangeselector/button-click/\n             *         Click event on the button\n             *\n             * @type      {Highcharts.RangeSelectorClickCallbackFunction}\n             * @apioption rangeSelector.buttons.events.click\n             */\n            /**\n             * Additional range (in milliseconds) added to the end of the calculated\n             * time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMax\n             */\n            /**\n             * Additional range (in milliseconds) added to the start of the\n             * calculated time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMin\n             */\n            /**\n             * When buttons apply dataGrouping on a series, by default zooming\n             * in/out will deselect buttons and unset dataGrouping. Enable this\n             * option to keep buttons selected when extremes change.\n             *\n             * @sample {highstock} stock/rangeselector/preserve-datagrouping/\n             *         Different preserveDataGrouping settings\n             *\n             * @type      {boolean}\n             * @default   false\n             * @since     6.1.2\n             * @apioption rangeSelector.buttons.preserveDataGrouping\n             */\n            /**\n             * A custom data grouping object for each button.\n             *\n             * @see [series.dataGrouping](#plotOptions.series.dataGrouping)\n             *\n             * @sample {highstock} stock/rangeselector/datagrouping/\n             *         Data grouping by range selector buttons\n             *\n             * @type      {*}\n             * @extends   plotOptions.series.dataGrouping\n             * @apioption rangeSelector.buttons.dataGrouping\n             */\n            /**\n             * The text for the button itself.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.text\n             */\n            /**\n             * Explanation for the button, shown as a tooltip on hover, and used by\n             * assistive technology.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.title\n             */\n            /**\n             * Defined the time span for the button. Can be one of `millisecond`,\n             * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,\n             * and `all`.\n             *\n             * @type       {Highcharts.RangeSelectorButtonTypeValue}\n             * @apioption  rangeSelector.buttons.type\n             */\n            /**\n             * The space in pixels between the buttons in the range selector.\n             */\n            buttonSpacing: 5,\n            /**\n             * Whether to collapse the range selector buttons into a dropdown when\n             * there is not enough room to show everything in a single row, instead\n             * of dividing the range selector into multiple rows.\n             * Can be one of the following:\n             *  - `always`: Always collapse\n             *  - `responsive`: Only collapse when there is not enough room\n             *  - `never`: Never collapse\n             *\n             * @sample {highstock} stock/rangeselector/dropdown/\n             *         Dropdown option\n             *\n             * @validvalue [\"always\", \"responsive\", \"never\"]\n             * @since 9.0.0\n             */\n            dropdown: 'responsive',\n            /**\n             * Enable or disable the range selector. Default to `true` for stock\n             * charts, using the `stockChart` factory.\n             *\n             * @sample {highstock} stock/rangeselector/enabled/\n             *         Disable the range selector\n             *\n             * @type {boolean|undefined}\n             * @default {highstock} true\n             */\n            enabled: void 0,\n            /**\n             * The vertical alignment of the rangeselector box. Allowed properties\n             * are `top`, `middle`, `bottom`.\n             *\n             * @sample {highstock} stock/rangeselector/vertical-align-middle/\n             *         Middle\n             * @sample {highstock} stock/rangeselector/vertical-align-bottom/\n             *         Bottom\n             *\n             * @type  {Highcharts.VerticalAlignValue}\n             * @since 6.0.0\n             */\n            verticalAlign: 'top',\n            /**\n             * A collection of attributes for the buttons. The object takes SVG\n             * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,\n             * a collection of CSS properties for the text.\n             *\n             * The object can also be extended with states, so you can set\n             * presentational options for `hover`, `select` or `disabled` button\n             * states.\n             *\n             * CSS styles for the text label.\n             *\n             * In styled mode, the buttons are styled by the\n             * `.highcharts-range-selector-buttons .highcharts-button` rule with its\n             * different states.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.SVGAttributes}\n             */\n            buttonTheme: {\n                /** @ignore */\n                width: 28,\n                /** @ignore */\n                height: 18,\n                /** @ignore */\n                padding: 2,\n                /** @ignore */\n                zIndex: 7 // #484, #852\n            },\n            /**\n             * When the rangeselector is floating, the plot area does not reserve\n             * space for it. This opens for positioning anywhere on the chart.\n             *\n             * @sample {highstock} stock/rangeselector/floating/\n             *         Placing the range selector between the plot area and the\n             *         navigator\n             *\n             * @since 6.0.0\n             */\n            floating: false,\n            /**\n             * The x offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            x: 0,\n            /**\n             * The y offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            y: 0,\n            /**\n             * Deprecated. The height of the range selector. Currently it is\n             * calculated dynamically.\n             *\n             * @deprecated\n             * @type  {number|undefined}\n             * @since 2.1.9\n             */\n            height: void 0,\n            /**\n             * The border color of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.ColorString}\n             * @since     1.3.7\n             */\n            inputBoxBorderColor: 'none',\n            /**\n             * The pixel height of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @since     1.3.7\n             */\n            inputBoxHeight: 17,\n            /**\n             * The pixel width of the date input boxes. When `undefined`, the width\n             * is fitted to the rendered content.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type   {number|undefined}\n             * @since  1.3.7\n             */\n            inputBoxWidth: void 0,\n            /**\n             * The date format in the input boxes when not selected for editing.\n             * Defaults to `%e %b %Y`.\n             *\n             * This is used to determine which type of input to show,\n             * `datetime-local`, `date` or `time` and falling back to `text` when\n             * the browser does not support the input type or the format contains\n             * milliseconds.\n             *\n             * @sample {highstock} stock/rangeselector/input-type/\n             *         Input types\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputDateFormat: '%e %b %Y',\n            /**\n             * A custom callback function to parse values entered in the input boxes\n             * and return a valid JavaScript time as milliseconds since 1970.\n             * The first argument passed is a value to parse,\n             * second is a boolean indicating use of the UTC time.\n             *\n             * This will only get called for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             * @type      {Highcharts.RangeSelectorParseCallbackFunction}\n             * @since     1.3.3\n             */\n            inputDateParser: void 0,\n            /**\n             * The date format in the input boxes when they are selected for\n             * editing. This must be a format that is recognized by JavaScript\n             * Date.parse.\n             *\n             * This will only be used for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputEditDateFormat: '%Y-%m-%d',\n            /**\n             * Enable or disable the date input boxes.\n             */\n            inputEnabled: true,\n            /**\n             * Positioning for the input boxes. Allowed properties are `align`,\n             *  `x` and `y`.\n             *\n             * @since 1.2.4\n             */\n            inputPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'right',\n                /**\n                 * X offset of the input row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the input row.\n                 */\n                y: 0\n            },\n            /**\n             * The space in pixels between the labels and the date input boxes in\n             * the range selector.\n             *\n             * @since 9.0.0\n             */\n            inputSpacing: 5,\n            /**\n             * The index of the button to appear pre-selected.\n             *\n             * @type      {number}\n             */\n            selected: void 0,\n            /**\n             * Positioning for the button row.\n             *\n             * @since 1.2.4\n             */\n            buttonPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'left',\n                /**\n                 * X offset of the button row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the button row.\n                 */\n                y: 0\n            },\n            /**\n             * CSS for the HTML inputs in the range selector.\n             *\n             * In styled mode, the inputs are styled by the\n             * `.highcharts-range-input text` rule in SVG mode, and\n             * `input.highcharts-range-selector` when active.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.CSSObject}\n             * @apioption rangeSelector.inputStyle\n             */\n            inputStyle: {\n                /** @ignore */\n                color: \"#334eff\" /* Palette.highlightColor80 */,\n                /** @ignore */\n                cursor: 'pointer',\n                /** @ignore */\n                fontSize: '0.8em'\n            },\n            /**\n             * CSS styles for the labels - the Zoom, From and To texts.\n             *\n             * In styled mode, the labels are styled by the\n             * `.highcharts-range-label` class.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.CSSObject}\n             */\n            labelStyle: {\n                /** @ignore */\n                color: \"#666666\" /* Palette.neutralColor60 */,\n                /** @ignore */\n                fontSize: '0.8em'\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorDefaults = {\n            lang,\n            rangeSelector\n        };\n\n        return RangeSelectorDefaults;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorComposition.js', [_modules['Core/Defaults.js'], _modules['Stock/RangeSelector/RangeSelectorDefaults.js'], _modules['Core/Utilities.js']], function (D, RangeSelectorDefaults, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions, setOptions } = D;\n        const { addEvent, defined, extend, find, isNumber, merge, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const chartDestroyEvents = [];\n        const composedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let RangeSelectorConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the axis min value based on the range option and the current max. For\n         * stock charts this is extended via the {@link RangeSelector} so that if the\n         * selected range is a multiple of months or years, it is compensated for\n         * various month lengths.\n         *\n         * @private\n         * @function Highcharts.Axis#minFromRange\n         * @return {number|undefined}\n         *         The new minimum value.\n         */\n        function axisMinFromRange() {\n            const rangeOptions = this.range, type = rangeOptions.type, max = this.max, time = this.chart.time, \n            // Get the true range from a start date\n            getTrueRange = function (base, count) {\n                const timeName = type === 'year' ?\n                    'FullYear' : 'Month';\n                const date = new time.Date(base);\n                const basePeriod = time.get(timeName, date);\n                time.set(timeName, date, basePeriod + count);\n                if (basePeriod === time.get(timeName, date)) {\n                    time.set('Date', date, 0); // #6537\n                }\n                return date.getTime() - base;\n            };\n            let min, range;\n            if (isNumber(rangeOptions)) {\n                min = max - rangeOptions;\n                range = rangeOptions;\n            }\n            else if (rangeOptions) {\n                min = max + getTrueRange(max, -(rangeOptions.count || 1));\n                // Let the fixedRange reflect initial settings (#5930)\n                if (this.chart) {\n                    this.chart.fixedRange = max - min;\n                }\n            }\n            const dataMin = pick(this.dataMin, Number.MIN_VALUE);\n            if (!isNumber(min)) {\n                min = dataMin;\n            }\n            if (min <= dataMin) {\n                min = dataMin;\n                if (typeof range === 'undefined') { // #4501\n                    range = getTrueRange(min, rangeOptions.count);\n                }\n                this.newMax = Math.min(min + range, pick(this.dataMax, Number.MAX_VALUE));\n            }\n            if (!isNumber(max)) {\n                min = void 0;\n            }\n            else if (!isNumber(rangeOptions) &&\n                rangeOptions &&\n                rangeOptions._offsetMin) {\n                min += rangeOptions._offsetMin;\n            }\n            return min;\n        }\n        /**\n         * @private\n         */\n        function compose(AxisClass, ChartClass, RangeSelectorClass) {\n            RangeSelectorConstructor = RangeSelectorClass;\n            if (U.pushUnique(composedMembers, AxisClass)) {\n                AxisClass.prototype.minFromRange = axisMinFromRange;\n            }\n            if (U.pushUnique(composedMembers, ChartClass)) {\n                addEvent(ChartClass, 'afterGetContainer', onChartAfterGetContainer);\n                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);\n                addEvent(ChartClass, 'destroy', onChartDestroy);\n                addEvent(ChartClass, 'getMargins', onChartGetMargins);\n                addEvent(ChartClass, 'render', onChartRender);\n                addEvent(ChartClass, 'update', onChartUpdate);\n                const chartProto = ChartClass.prototype;\n                chartProto.callbacks.push(onChartCallback);\n            }\n            if (U.pushUnique(composedMembers, setOptions)) {\n                extend(defaultOptions, { rangeSelector: RangeSelectorDefaults.rangeSelector });\n                extend(defaultOptions.lang, RangeSelectorDefaults.lang);\n            }\n        }\n        /**\n         * Initialize rangeselector for stock charts\n         * @private\n         */\n        function onChartAfterGetContainer() {\n            if (this.options.rangeSelector &&\n                this.options.rangeSelector.enabled) {\n                this.rangeSelector = new RangeSelectorConstructor(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartBeforeRender() {\n            const chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector;\n            if (rangeSelector) {\n                if (isNumber(rangeSelector.deferredYTDClick)) {\n                    rangeSelector.clickButton(rangeSelector.deferredYTDClick);\n                    delete rangeSelector.deferredYTDClick;\n                }\n                axes.forEach((axis) => {\n                    axis.updateNames();\n                    axis.setScale();\n                });\n                chart.getAxisMargins();\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartCallback(chart) {\n            let extremes, legend, alignTo, verticalAlign;\n            const rangeSelector = chart.rangeSelector, redraw = () => {\n                if (rangeSelector) {\n                    extremes = chart.xAxis[0].getExtremes();\n                    legend = chart.legend;\n                    verticalAlign = (rangeSelector &&\n                        rangeSelector.options.verticalAlign);\n                    if (isNumber(extremes.min)) {\n                        rangeSelector.render(extremes.min, extremes.max);\n                    }\n                    // Re-align the legend so that it's below the rangeselector\n                    if (legend.display &&\n                        verticalAlign === 'top' &&\n                        verticalAlign === legend.options.verticalAlign) {\n                        // Create a new alignment box for the legend.\n                        alignTo = merge(chart.spacingBox);\n                        if (legend.options.layout === 'vertical') {\n                            alignTo.y = chart.plotTop;\n                        }\n                        else {\n                            alignTo.y += rangeSelector.getHeight();\n                        }\n                        legend.group.placed = false; // Don't animate the alignment.\n                        legend.align(alignTo);\n                    }\n                }\n            };\n            if (rangeSelector) {\n                const events = find(chartDestroyEvents, (e) => e[0] === chart);\n                if (!events) {\n                    chartDestroyEvents.push([chart, [\n                            // redraw the scroller on setExtremes\n                            addEvent(chart.xAxis[0], 'afterSetExtremes', function (e) {\n                                if (rangeSelector) {\n                                    rangeSelector.render(e.min, e.max);\n                                }\n                            }),\n                            // redraw the scroller chart resize\n                            addEvent(chart, 'redraw', redraw)\n                        ]]);\n                }\n                // do it now\n                redraw();\n            }\n        }\n        /**\n         * Remove resize/afterSetExtremes at chart destroy.\n         * @private\n         */\n        function onChartDestroy() {\n            for (let i = 0, iEnd = chartDestroyEvents.length; i < iEnd; ++i) {\n                const events = chartDestroyEvents[i];\n                if (events[0] === this) {\n                    events[1].forEach((unbind) => unbind());\n                    chartDestroyEvents.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function onChartGetMargins() {\n            const rangeSelector = this.rangeSelector;\n            if (rangeSelector) {\n                const rangeSelectorHeight = rangeSelector.getHeight();\n                if (this.extraTopMargin) {\n                    this.plotTop += rangeSelectorHeight;\n                }\n                if (this.extraBottomMargin) {\n                    this.marginBottom += rangeSelectorHeight;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartRender() {\n            const chart = this, rangeSelector = chart.rangeSelector;\n            if (rangeSelector && !rangeSelector.options.floating) {\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (verticalAlign === 'bottom') {\n                    this.extraBottomMargin = true;\n                }\n                else if (verticalAlign !== 'middle') {\n                    this.extraTopMargin = true;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartUpdate(e) {\n            const chart = this, options = e.options, optionsRangeSelector = options.rangeSelector, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;\n            let rangeSelector = chart.rangeSelector;\n            if (optionsRangeSelector &&\n                optionsRangeSelector.enabled &&\n                !defined(rangeSelector) &&\n                this.options.rangeSelector) {\n                this.options.rangeSelector.enabled = true;\n                this.rangeSelector = rangeSelector = new RangeSelectorConstructor(this);\n            }\n            this.extraBottomMargin = false;\n            this.extraTopMargin = false;\n            if (rangeSelector) {\n                onChartCallback(this);\n                const verticalAlign = (optionsRangeSelector &&\n                    optionsRangeSelector.verticalAlign) || (rangeSelector.options && rangeSelector.options.verticalAlign);\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n                if (this.extraBottomMargin !== extraBottomMarginWas ||\n                    this.extraTopMargin !== extraTopMarginWas) {\n                    this.isDirtyBox = true;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorComposition = {\n            compose\n        };\n\n        return RangeSelectorComposition;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelector.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Stock/RangeSelector/RangeSelectorComposition.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function (Axis, D, H, RangeSelectorComposition, SVGElement, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { addEvent, createElement, css, defined, destroyObjectProperties, discardElement, extend, fireEvent, isNumber, merge, objectEach, pad, pick, pInt, splat } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the preferred input type based on a date format string.\n         *\n         * @private\n         * @function preferredInputType\n         */\n        function preferredInputType(format) {\n            const ms = format.indexOf('%L') !== -1;\n            if (ms) {\n                return 'text';\n            }\n            const date = ['a', 'A', 'd', 'e', 'w', 'b', 'B', 'm', 'o', 'y', 'Y']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            const time = ['H', 'k', 'I', 'l', 'M', 'S']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            if (date && time) {\n                return 'datetime-local';\n            }\n            if (date) {\n                return 'date';\n            }\n            if (time) {\n                return 'time';\n            }\n            return 'text';\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The range selector.\n         *\n         * @private\n         * @class\n         * @name Highcharts.RangeSelector\n         * @param {Highcharts.Chart} chart\n         */\n        class RangeSelector {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass, ChartClass) {\n                RangeSelectorComposition.compose(AxisClass, ChartClass, RangeSelector);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.buttons = void 0;\n                this.buttonOptions = RangeSelector.prototype.defaultButtons;\n                this.initialButtonGroupWidth = 0;\n                this.options = void 0;\n                this.chart = chart;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * The method to run when one of the buttons in the range selectors is\n             * clicked\n             *\n             * @private\n             * @function Highcharts.RangeSelector#clickButton\n             * @param {number} i\n             *        The index of the button\n             * @param {boolean} [redraw]\n             */\n            clickButton(i, redraw) {\n                const rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {}, type = rangeOptions.type, dataGrouping = rangeOptions.dataGrouping;\n                let dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568\n                baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, addOffsetMin = true;\n                // chart has no data, base series is removed\n                if (dataMin === null || dataMax === null) {\n                    return;\n                }\n                // Set the fixed range before range is altered\n                chart.fixedRange = range;\n                rangeSelector.setSelected(i);\n                // Apply dataGrouping associated to button\n                if (dataGrouping) {\n                    this.forcedDataGrouping = true;\n                    Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);\n                    this.frozenStates = rangeOptions.preserveDataGrouping;\n                }\n                // Apply range\n                if (type === 'month' || type === 'year') {\n                    if (!baseAxis) {\n                        // This is set to the user options and picked up later when the\n                        // axis is instantiated so that we know the min and max.\n                        range = rangeOptions;\n                    }\n                    else {\n                        ctx = {\n                            range: rangeOptions,\n                            max: newMax,\n                            chart: chart,\n                            dataMin: dataMin,\n                            dataMax: dataMax\n                        };\n                        newMin = baseAxis.minFromRange.call(ctx);\n                        if (isNumber(ctx.newMax)) {\n                            newMax = ctx.newMax;\n                        }\n                        // #15799: offsetMin is added in minFromRange so that it works\n                        // with pre-selected buttons as well\n                        addOffsetMin = false;\n                    }\n                    // Fixed times like minutes, hours, days\n                }\n                else if (range) {\n                    newMin = Math.max(newMax - range, dataMin);\n                    newMax = Math.min(newMin + range, dataMax);\n                    addOffsetMin = false;\n                }\n                else if (type === 'ytd') {\n                    // On user clicks on the buttons, or a delayed action running from\n                    // the beforeRender event (below), the baseAxis is defined.\n                    if (baseAxis) {\n                        // When \"ytd\" is the pre-selected button for the initial view,\n                        // its calculation is delayed and rerun in the beforeRender\n                        // event (below). When the series are initialized, but before\n                        // the chart is rendered, we have access to the xData array\n                        // (#942).\n                        if (typeof dataMax === 'undefined' ||\n                            typeof dataMin === 'undefined') {\n                            dataMin = Number.MAX_VALUE;\n                            dataMax = Number.MIN_VALUE;\n                            chart.series.forEach((series) => {\n                                // reassign it to the last item\n                                const xData = series.xData;\n                                if (xData) {\n                                    dataMin = Math.min(xData[0], dataMin);\n                                    dataMax = Math.max(xData[xData.length - 1], dataMax);\n                                }\n                            });\n                            redraw = false;\n                        }\n                        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);\n                        newMin = rangeMin = ytdExtremes.min;\n                        newMax = ytdExtremes.max;\n                        // \"ytd\" is pre-selected. We don't yet have access to processed\n                        // point and extremes data (things like pointStart and pointInterval\n                        // are missing), so we delay the process (#942)\n                    }\n                    else {\n                        rangeSelector.deferredYTDClick = i;\n                        return;\n                    }\n                }\n                else if (type === 'all' && baseAxis) {\n                    // If the navigator exist and the axis range is declared reset that\n                    // range and from now on only use the range set by a user, #14742.\n                    if (chart.navigator && chart.navigator.baseSeries[0]) {\n                        chart.navigator.baseSeries[0].xAxis.options.range = void 0;\n                    }\n                    newMin = dataMin;\n                    newMax = dataMax;\n                }\n                if (addOffsetMin && rangeOptions._offsetMin && defined(newMin)) {\n                    newMin += rangeOptions._offsetMin;\n                }\n                if (rangeOptions._offsetMax && defined(newMax)) {\n                    newMax += rangeOptions._offsetMax;\n                }\n                if (this.dropdown) {\n                    this.dropdown.selectedIndex = i + 1;\n                }\n                // Update the chart\n                if (!baseAxis) {\n                    // Axis not yet instanciated. Temporarily set min and range\n                    // options and remove them on chart load (#4317).\n                    baseXAxisOptions = splat(chart.options.xAxis)[0];\n                    rangeSetting = baseXAxisOptions.range;\n                    baseXAxisOptions.range = range;\n                    minSetting = baseXAxisOptions.min;\n                    baseXAxisOptions.min = rangeMin;\n                    addEvent(chart, 'load', function resetMinAndRange() {\n                        baseXAxisOptions.range = rangeSetting;\n                        baseXAxisOptions.min = minSetting;\n                    });\n                }\n                else {\n                    // Existing axis object. Set extremes after render time.\n                    baseAxis.setExtremes(newMin, newMax, pick(redraw, true), void 0, // auto animation\n                    {\n                        trigger: 'rangeSelectorButton',\n                        rangeSelectorButton: rangeOptions\n                    });\n                }\n                fireEvent(this, 'afterBtnClick');\n            }\n            /**\n             * Set the selected option. This method only sets the internal flag, it\n             * doesn't update the buttons or the actual zoomed range.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setSelected\n             * @param {number} [selected]\n             */\n            setSelected(selected) {\n                this.selected = this.options.selected = selected;\n            }\n            /**\n             * Initialize the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#init\n             * @param {Highcharts.Chart} chart\n             */\n            init(chart) {\n                const rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = (options.buttons || rangeSelector.defaultButtons.slice()), selectedOption = options.selected, blurInputs = function () {\n                    const minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;\n                    // #3274 in some case blur is not defined\n                    if (minInput && (minInput.blur)) {\n                        fireEvent(minInput, 'blur');\n                    }\n                    if (maxInput && (maxInput.blur)) {\n                        fireEvent(maxInput, 'blur');\n                    }\n                };\n                rangeSelector.chart = chart;\n                rangeSelector.options = options;\n                rangeSelector.buttons = [];\n                rangeSelector.buttonOptions = buttonOptions;\n                this.eventsToUnbind = [];\n                this.eventsToUnbind.push(addEvent(chart.container, 'mousedown', blurInputs));\n                this.eventsToUnbind.push(addEvent(chart, 'resize', blurInputs));\n                // Extend the buttonOptions with actual range\n                buttonOptions.forEach(rangeSelector.computeButtonRange);\n                // zoomed range based on a pre-selected button index\n                if (typeof selectedOption !== 'undefined' &&\n                    buttonOptions[selectedOption]) {\n                    this.clickButton(selectedOption, false);\n                }\n                this.eventsToUnbind.push(addEvent(chart, 'load', function () {\n                    // If a data grouping is applied to the current button, release it\n                    // when extremes change\n                    if (chart.xAxis && chart.xAxis[0]) {\n                        addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                            if (this.max - this.min !==\n                                chart.fixedRange &&\n                                e.trigger !== 'rangeSelectorButton' &&\n                                e.trigger !== 'updatedData' &&\n                                rangeSelector.forcedDataGrouping &&\n                                !rangeSelector.frozenStates) {\n                                this.setDataGrouping(false, false);\n                            }\n                        });\n                    }\n                }));\n            }\n            /**\n             * Dynamically update the range selector buttons after a new range has been\n             * set\n             *\n             * @private\n             * @function Highcharts.RangeSelector#updateButtonStates\n             */\n            updateButtonStates() {\n                const rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, // A single day in milliseconds\n                unionExtremes = (chart.scroller &&\n                    chart.scroller.getUnionExtremes()) || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;\n                let selectedExists = isNumber(selected);\n                rangeSelector.buttonOptions.forEach((rangeOptions, i) => {\n                    const range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button = buttons[i], offsetRange = rangeOptions._offsetMax -\n                        rangeOptions._offsetMin, isSelected = i === selected, \n                    // Disable buttons where the range exceeds what is allowed in\n                    // the current view\n                    isTooGreatRange = range >\n                        dataMax - dataMin, \n                    // Disable buttons where the range is smaller than the minimum\n                    // range\n                    isTooSmallRange = range < baseAxis.minRange;\n                    let state = 0, \n                    // Do not select the YTD button if not explicitly told so\n                    isYTDButNotSelected = false, \n                    // Disable the All button if we're already showing all\n                    isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;\n                    // Months and years have a variable range so we check the extremes\n                    if ((type === 'month' || type === 'year') &&\n                        (actualRange + 36e5 >=\n                            { month: 28, year: 365 }[type] * day * count - offsetRange) &&\n                        (actualRange - 36e5 <=\n                            { month: 31, year: 366 }[type] * day * count + offsetRange)) {\n                        isSameRange = true;\n                    }\n                    else if (type === 'ytd') {\n                        isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;\n                        isYTDButNotSelected = !isSelected;\n                    }\n                    else if (type === 'all') {\n                        isSameRange = (baseAxis.max - baseAxis.min >=\n                            dataMax - dataMin);\n                        isAllButAlreadyShowingAll = (!isSelected &&\n                            selectedExists &&\n                            isSameRange);\n                    }\n                    // The new zoom area happens to match the range for a button - mark\n                    // it selected. This happens when scrolling across an ordinal gap.\n                    // It can be seen in the intraday demos when selecting 1h and scroll\n                    // across the night gap.\n                    const disable = (!allButtonsEnabled &&\n                        (isTooGreatRange ||\n                            isTooSmallRange ||\n                            isAllButAlreadyShowingAll ||\n                            hasNoData));\n                    const select = ((isSelected && isSameRange) ||\n                        (isSameRange && !selectedExists && !isYTDButNotSelected) ||\n                        (isSelected && rangeSelector.frozenStates));\n                    if (disable) {\n                        state = 3;\n                    }\n                    else if (select) {\n                        selectedExists = true; // Only one button can be selected\n                        state = 2;\n                    }\n                    // If state has changed, update the button\n                    if (button.state !== state) {\n                        button.setState(state);\n                        if (dropdown) {\n                            dropdown.options[i + 1].disabled = disable;\n                            if (state === 2) {\n                                dropdown.selectedIndex = i + 1;\n                            }\n                        }\n                        // Reset (#9209)\n                        if (state === 0 && selected === i) {\n                            rangeSelector.setSelected();\n                        }\n                    }\n                });\n            }\n            /**\n             * Compute and cache the range for an individual button\n             *\n             * @private\n             * @function Highcharts.RangeSelector#computeButtonRange\n             * @param {Highcharts.RangeSelectorButtonsOptions} rangeOptions\n             */\n            computeButtonRange(rangeOptions) {\n                const type = rangeOptions.type, count = rangeOptions.count || 1, \n                // these time intervals have a fixed number of milliseconds, as\n                // opposed to month, ytd and year\n                fixedTimes = {\n                    millisecond: 1,\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 24 * 3600 * 1000,\n                    week: 7 * 24 * 3600 * 1000\n                };\n                // Store the range on the button object\n                if (fixedTimes[type]) {\n                    rangeOptions._range = fixedTimes[type] * count;\n                }\n                else if (type === 'month' || type === 'year') {\n                    rangeOptions._range = {\n                        month: 30,\n                        year: 365\n                    }[type] * 24 * 36e5 * count;\n                }\n                rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);\n                rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);\n                rangeOptions._range +=\n                    rangeOptions._offsetMax - rangeOptions._offsetMin;\n            }\n            /**\n             * Get the unix timestamp of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getInputValue\n             */\n            getInputValue(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                const options = this.chart.options\n                    .rangeSelector;\n                const time = this.chart.time;\n                if (input) {\n                    return ((input.type === 'text' && options.inputDateParser) ||\n                        this.defaultInputDateParser)(input.value, time.useUTC, time);\n                }\n                return 0;\n            }\n            /**\n             * Set the internal and displayed value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputValue\n             */\n            setInputValue(name, inputTime) {\n                const options = this.options, time = this.chart.time, input = name === 'min' ? this.minInput : this.maxInput, dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;\n                if (input) {\n                    const hcTimeAttr = input.getAttribute('data-hc-time');\n                    let updatedTime = defined(hcTimeAttr) ? Number(hcTimeAttr) : void 0;\n                    if (defined(inputTime)) {\n                        const previousTime = updatedTime;\n                        if (defined(previousTime)) {\n                            input.setAttribute('data-hc-time-previous', previousTime);\n                        }\n                        input.setAttribute('data-hc-time', inputTime);\n                        updatedTime = inputTime;\n                    }\n                    input.value = time.dateFormat((this.inputTypeFormats[input.type] ||\n                        options.inputEditDateFormat), updatedTime);\n                    if (dateBox) {\n                        dateBox.attr({\n                            text: time.dateFormat(options.inputDateFormat, updatedTime)\n                        });\n                    }\n                }\n            }\n            /**\n             * Set the min and max value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputExtremes\n             */\n            setInputExtremes(name, min, max) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    const format = this.inputTypeFormats[input.type];\n                    const time = this.chart.time;\n                    if (format) {\n                        const newMin = time.dateFormat(format, min);\n                        if (input.min !== newMin) {\n                            input.min = newMin;\n                        }\n                        const newMax = time.dateFormat(format, max);\n                        if (input.max !== newMax) {\n                            input.max = newMax;\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#showInput\n             * @param {string} name\n             */\n            showInput(name) {\n                const dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input && dateBox && this.inputGroup) {\n                    const isTextInput = input.type === 'text';\n                    const { translateX, translateY } = this.inputGroup;\n                    const { inputBoxWidth } = this.options;\n                    css(input, {\n                        width: isTextInput ?\n                            ((dateBox.width + (inputBoxWidth ? -2 : 20)) + 'px') :\n                            'auto',\n                        height: (dateBox.height - 2) + 'px',\n                        border: '2px solid silver'\n                    });\n                    if (isTextInput && inputBoxWidth) {\n                        css(input, {\n                            left: (translateX + dateBox.x) + 'px',\n                            top: translateY + 'px'\n                        });\n                        // Inputs of types date, time or datetime-local should be centered\n                        // on top of the dateBox\n                    }\n                    else {\n                        css(input, {\n                            left: Math.min(Math.round(dateBox.x +\n                                translateX -\n                                (input.offsetWidth - dateBox.width) / 2), this.chart.chartWidth - input.offsetWidth) + 'px',\n                            top: (translateY - (input.offsetHeight - dateBox.height) / 2) + 'px'\n                        });\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideInput\n             * @param {string} name\n             */\n            hideInput(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    css(input, {\n                        top: '-9999em',\n                        border: 0,\n                        width: '1px',\n                        height: '1px'\n                    });\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#defaultInputDateParser\n             */\n            defaultInputDateParser(inputDate, useUTC, time) {\n                const hasTimezone = (str) => str.length > 6 &&\n                    (str.lastIndexOf('-') === str.length - 6 ||\n                        str.lastIndexOf('+') === str.length - 6);\n                let input = inputDate.split('/').join('-').split(' ').join('T');\n                if (input.indexOf('T') === -1) {\n                    input += 'T00:00';\n                }\n                if (useUTC) {\n                    input += 'Z';\n                }\n                else if (H.isSafari && !hasTimezone(input)) {\n                    const offset = new Date(input).getTimezoneOffset() / 60;\n                    input += offset <= 0 ? `+${pad(-offset)}:00` : `-${pad(offset)}:00`;\n                }\n                let date = Date.parse(input);\n                // If the value isn't parsed directly to a value by the\n                // browser's Date.parse method, try\n                // parsing it a different way\n                if (!isNumber(date)) {\n                    const parts = inputDate.split('-');\n                    date = Date.UTC(pInt(parts[0]), pInt(parts[1]) - 1, pInt(parts[2]));\n                }\n                if (time && useUTC && isNumber(date)) {\n                    date += time.getTimezoneOffset(date);\n                }\n                return date;\n            }\n            /**\n             * Draw either the 'from' or the 'to' HTML input box of the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#drawInput\n             */\n            drawInput(name) {\n                const { chart, div, inputGroup } = this;\n                const rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang = defaultOptions.lang, isMin = name === 'min';\n                /**\n                 * @private\n                 */\n                function updateExtremes() {\n                    const { maxInput, minInput } = rangeSelector, chartAxis = chart.xAxis[0], dataAxis = chart.scroller && chart.scroller.xAxis ?\n                        chart.scroller.xAxis :\n                        chartAxis, dataMin = dataAxis.dataMin, dataMax = dataAxis.dataMax;\n                    let value = rangeSelector.getInputValue(name);\n                    if (value !== Number(input.getAttribute('data-hc-time-previous')) &&\n                        isNumber(value)) {\n                        input.setAttribute('data-hc-time-previous', value);\n                        // Validate the extremes. If it goes beyound the data min or\n                        // max, use the actual data extreme (#2438).\n                        if (isMin && maxInput && isNumber(dataMin)) {\n                            if (value > Number(maxInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value < dataMin) {\n                                value = dataMin;\n                            }\n                        }\n                        else if (minInput && isNumber(dataMax)) {\n                            if (value < Number(minInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value > dataMax) {\n                                value = dataMax;\n                            }\n                        }\n                        // Set the extremes\n                        if (typeof value !== 'undefined') { // @todo typof undefined\n                            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: 'rangeSelectorInput' });\n                        }\n                    }\n                }\n                // Create the text label\n                const text = lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'] || '';\n                const label = renderer\n                    .label(text, 0)\n                    .addClass('highcharts-range-label')\n                    .attr({\n                    padding: text ? 2 : 0,\n                    height: text ? options.inputBoxHeight : 0\n                })\n                    .add(inputGroup);\n                // Create an SVG label that shows updated date ranges and and records\n                // click events that bring in the HTML input.\n                const dateBox = renderer\n                    .label('', 0)\n                    .addClass('highcharts-range-input')\n                    .attr({\n                    padding: 2,\n                    width: options.inputBoxWidth,\n                    height: options.inputBoxHeight,\n                    'text-align': 'center'\n                })\n                    .on('click', function () {\n                    // If it is already focused, the onfocus event doesn't fire\n                    // (#3713)\n                    rangeSelector.showInput(name);\n                    rangeSelector[name + 'Input'].focus();\n                });\n                if (!chart.styledMode) {\n                    dateBox.attr({\n                        stroke: options.inputBoxBorderColor,\n                        'stroke-width': 1\n                    });\n                }\n                dateBox.add(inputGroup);\n                // Create the HTML input element. This is rendered as 1x1 pixel then set\n                // to the right size when focused.\n                const input = createElement('input', {\n                    name: name,\n                    className: 'highcharts-range-selector'\n                }, void 0, div);\n                // #14788: Setting input.type to an unsupported type throws in IE, so\n                // we need to use setAttribute instead\n                input.setAttribute('type', preferredInputType(options.inputDateFormat || '%e %b %Y'));\n                if (!chart.styledMode) {\n                    // Styles\n                    label.css(merge(chartStyle, options.labelStyle));\n                    dateBox.css(merge({\n                        color: \"#333333\" /* Palette.neutralColor80 */\n                    }, chartStyle, options.inputStyle));\n                    css(input, extend({\n                        position: 'absolute',\n                        border: 0,\n                        boxShadow: '0 0 15px rgba(0,0,0,0.3)',\n                        width: '1px',\n                        height: '1px',\n                        padding: 0,\n                        textAlign: 'center',\n                        fontSize: chartStyle.fontSize,\n                        fontFamily: chartStyle.fontFamily,\n                        top: '-9999em' // #4798\n                    }, options.inputStyle));\n                }\n                // Blow up the input box\n                input.onfocus = () => {\n                    rangeSelector.showInput(name);\n                };\n                // Hide away the input box\n                input.onblur = () => {\n                    // update extermes only when inputs are active\n                    if (input === H.doc.activeElement) { // Only when focused\n                        // Update also when no `change` event is triggered, like when\n                        // clicking inside the SVG (#4710)\n                        updateExtremes();\n                    }\n                    // #10404 - move hide and blur outside focus\n                    rangeSelector.hideInput(name);\n                    rangeSelector.setInputValue(name);\n                    input.blur(); // #4606\n                };\n                let keyDown = false;\n                // handle changes in the input boxes\n                input.onchange = () => {\n                    // Update extremes and blur input when clicking date input calendar\n                    if (!keyDown) {\n                        updateExtremes();\n                        rangeSelector.hideInput(name);\n                        input.blur();\n                    }\n                };\n                input.onkeypress = (event) => {\n                    // IE does not fire onchange on enter\n                    if (event.keyCode === 13) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeydown = (event) => {\n                    keyDown = true;\n                    // Arrow keys\n                    if (event.keyCode === 38 || event.keyCode === 40) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeyup = () => {\n                    keyDown = false;\n                };\n                return { dateBox, input, label };\n            }\n            /**\n             * Get the position of the range selector buttons and inputs. This can be\n             * overridden from outside for custom positioning.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getPosition\n             */\n            getPosition() {\n                const chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === 'top' ?\n                    chart.plotTop - chart.axisOffset[0] :\n                    0; // set offset only for varticalAlign top\n                return {\n                    buttonTop: top + options.buttonPosition.y,\n                    inputTop: top + options.inputPosition.y - 10\n                };\n            }\n            /**\n             * Get the extremes of YTD. Will choose dataMax if its value is lower than\n             * the current timestamp. Will choose dataMin if its value is higher than\n             * the timestamp for the start of current year.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getYTDExtremes\n             * @return {*}\n             * Returns min and max for the YTD\n             */\n            getYTDExtremes(dataMax, dataMin, useUTC) {\n                const time = this.chart.time, now = new time.Date(dataMax), year = time.get('FullYear', now), startOfYear = useUTC ?\n                    time.Date.UTC(year, 0, 1) : // eslint-disable-line new-cap\n                    +new time.Date(year, 0, 1), min = Math.max(dataMin, startOfYear), ts = now.getTime();\n                return {\n                    max: Math.min(dataMax || ts, ts),\n                    min\n                };\n            }\n            /**\n             * Render the range selector including the buttons and the inputs. The first\n             * time render is called, the elements are created and positioned. On\n             * subsequent calls, they are moved and updated.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#render\n             * @param {number} [min]\n             *        X axis minimum\n             * @param {number} [max]\n             *        X axis maximum\n             */\n            render(min, max) {\n                const chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, \n                // Place inputs above the container\n                inputsZIndex = pick(chartOptions.chart.style &&\n                    chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;\n                if (options.enabled === false) {\n                    return;\n                }\n                // create the elements\n                if (!rendered) {\n                    this.group = renderer.g('range-selector-group')\n                        .attr({\n                        zIndex: 7\n                    })\n                        .add();\n                    this.div = createElement('div', void 0, {\n                        position: 'relative',\n                        height: 0,\n                        zIndex: inputsZIndex\n                    });\n                    if (this.buttonOptions.length) {\n                        this.renderButtons();\n                    }\n                    // First create a wrapper outside the container in order to make\n                    // the inputs work and make export correct\n                    if (container.parentNode) {\n                        container.parentNode.insertBefore(this.div, container);\n                    }\n                    if (inputEnabled) {\n                        // Create the group to keep the inputs\n                        this.inputGroup = renderer.g('input-group').add(this.group);\n                        const minElems = this.drawInput('min');\n                        this.minDateBox = minElems.dateBox;\n                        this.minLabel = minElems.label;\n                        this.minInput = minElems.input;\n                        const maxElems = this.drawInput('max');\n                        this.maxDateBox = maxElems.dateBox;\n                        this.maxLabel = maxElems.label;\n                        this.maxInput = maxElems.input;\n                    }\n                }\n                if (inputEnabled) {\n                    // Set or reset the input values\n                    this.setInputValue('min', min);\n                    this.setInputValue('max', max);\n                    const unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chart.xAxis[0] || {};\n                    if (defined(unionExtremes.dataMin) &&\n                        defined(unionExtremes.dataMax)) {\n                        const minRange = chart.xAxis[0].minRange || 0;\n                        this.setInputExtremes('min', unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue('max')) - minRange);\n                        this.setInputExtremes('max', Math.max(unionExtremes.dataMin, this.getInputValue('min')) + minRange, unionExtremes.dataMax);\n                    }\n                    // Reflow\n                    if (this.inputGroup) {\n                        let x = 0;\n                        [\n                            this.minLabel,\n                            this.minDateBox,\n                            this.maxLabel,\n                            this.maxDateBox\n                        ].forEach((label) => {\n                            if (label) {\n                                const { width } = label.getBBox();\n                                if (width) {\n                                    label.attr({ x });\n                                    x += width + options.inputSpacing;\n                                }\n                            }\n                        });\n                    }\n                }\n                this.alignElements();\n                this.rendered = true;\n            }\n            /**\n             * Render the range buttons. This only runs the first time, later the\n             * positioning is laid out in alignElements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#renderButtons\n             */\n            renderButtons() {\n                const { buttons, chart, options } = this;\n                const lang = defaultOptions.lang;\n                const renderer = chart.renderer;\n                const buttonTheme = merge(options.buttonTheme);\n                const states = buttonTheme && buttonTheme.states;\n                // Prevent the button from resetting the width when the button state\n                // changes since we need more control over the width when collapsing\n                // the buttons\n                const width = buttonTheme.width || 28;\n                delete buttonTheme.width;\n                delete buttonTheme.states;\n                this.buttonGroup = renderer.g('range-selector-buttons').add(this.group);\n                const dropdown = this.dropdown = createElement('select', void 0, {\n                    position: 'absolute',\n                    width: '1px',\n                    height: '1px',\n                    padding: 0,\n                    border: 0,\n                    top: '-9999em',\n                    cursor: 'pointer',\n                    opacity: 0.0001\n                }, this.div);\n                // Prevent page zoom on iPhone\n                addEvent(dropdown, 'touchstart', () => {\n                    dropdown.style.fontSize = '16px';\n                });\n                // Forward events from select to button\n                [\n                    [H.isMS ? 'mouseover' : 'mouseenter'],\n                    [H.isMS ? 'mouseout' : 'mouseleave'],\n                    ['change', 'click']\n                ].forEach(([from, to]) => {\n                    addEvent(dropdown, from, () => {\n                        const button = buttons[this.currentButtonIndex()];\n                        if (button) {\n                            fireEvent(button.element, to || from);\n                        }\n                    });\n                });\n                this.zoomText = renderer\n                    .label((lang && lang.rangeSelectorZoom) || '', 0)\n                    .attr({\n                    padding: options.buttonTheme.padding,\n                    height: options.buttonTheme.height,\n                    paddingLeft: 0,\n                    paddingRight: 0\n                })\n                    .add(this.buttonGroup);\n                if (!this.chart.styledMode) {\n                    this.zoomText.css(options.labelStyle);\n                    buttonTheme['stroke-width'] = pick(buttonTheme['stroke-width'], 0);\n                }\n                createElement('option', {\n                    textContent: this.zoomText.textStr,\n                    disabled: true\n                }, void 0, dropdown);\n                this.buttonOptions.forEach((rangeOptions, i) => {\n                    createElement('option', {\n                        textContent: rangeOptions.title || rangeOptions.text\n                    }, void 0, dropdown);\n                    buttons[i] = renderer\n                        .button(rangeOptions.text, 0, 0, (e) => {\n                        // extract events from button object and call\n                        const buttonEvents = (rangeOptions.events && rangeOptions.events.click);\n                        let callDefaultEvent;\n                        if (buttonEvents) {\n                            callDefaultEvent =\n                                buttonEvents.call(rangeOptions, e);\n                        }\n                        if (callDefaultEvent !== false) {\n                            this.clickButton(i);\n                        }\n                        this.isActive = true;\n                    }, buttonTheme, states && states.hover, states && states.select, states && states.disabled)\n                        .attr({\n                        'text-align': 'center',\n                        width\n                    })\n                        .add(this.buttonGroup);\n                    if (rangeOptions.title) {\n                        buttons[i].attr('title', rangeOptions.title);\n                    }\n                });\n            }\n            /**\n             * Align the elements horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignElements\n             */\n            alignElements() {\n                const { buttonGroup, buttons, chart, group, inputGroup, options, zoomText } = this;\n                const chartOptions = chart.options;\n                const navButtonOptions = (chartOptions.exporting &&\n                    chartOptions.exporting.enabled !== false &&\n                    chartOptions.navigation &&\n                    chartOptions.navigation.buttonOptions);\n                const { buttonPosition, inputPosition, verticalAlign } = options;\n                // Get the X offset required to avoid overlapping with the exporting\n                // button. This is is used both by the buttonGroup and the inputGroup.\n                const getXOffsetForExportButton = (group, position) => {\n                    if (navButtonOptions &&\n                        this.titleCollision(chart) &&\n                        verticalAlign === 'top' &&\n                        position.align === 'right' && ((position.y -\n                        group.getBBox().height - 12) <\n                        ((navButtonOptions.y || 0) +\n                            (navButtonOptions.height || 0) +\n                            chart.spacing[0]))) {\n                        return -40;\n                    }\n                    return 0;\n                };\n                let plotLeft = chart.plotLeft;\n                if (group && buttonPosition && inputPosition) {\n                    let translateX = buttonPosition.x - chart.spacing[3];\n                    if (buttonGroup) {\n                        this.positionButtons();\n                        if (!this.initialButtonGroupWidth) {\n                            let width = 0;\n                            if (zoomText) {\n                                width += zoomText.getBBox().width + 5;\n                            }\n                            buttons.forEach((button, i) => {\n                                width += button.width;\n                                if (i !== buttons.length - 1) {\n                                    width += options.buttonSpacing;\n                                }\n                            });\n                            this.initialButtonGroupWidth = width;\n                        }\n                        plotLeft -= chart.spacing[3];\n                        this.updateButtonStates();\n                        // Detect collision between button group and exporting\n                        const xOffsetForExportButton = getXOffsetForExportButton(buttonGroup, buttonPosition);\n                        this.alignButtonGroup(xOffsetForExportButton);\n                        // Skip animation\n                        group.placed = buttonGroup.placed = chart.hasLoaded;\n                    }\n                    let xOffsetForExportButton = 0;\n                    if (inputGroup) {\n                        // Detect collision between the input group and exporting button\n                        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);\n                        if (inputPosition.align === 'left') {\n                            translateX = plotLeft;\n                        }\n                        else if (inputPosition.align === 'right') {\n                            translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);\n                        }\n                        // Update the alignment to the updated spacing box\n                        inputGroup.align({\n                            y: inputPosition.y,\n                            width: inputGroup.getBBox().width,\n                            align: inputPosition.align,\n                            // fix wrong getBBox() value on right align\n                            x: inputPosition.x + translateX - 2\n                        }, true, chart.spacingBox);\n                        // Skip animation\n                        inputGroup.placed = chart.hasLoaded;\n                    }\n                    this.handleCollision(xOffsetForExportButton);\n                    // Vertical align\n                    group.align({\n                        verticalAlign\n                    }, true, chart.spacingBox);\n                    const alignTranslateY = group.alignAttr.translateY;\n                    // Set position\n                    let groupHeight = group.getBBox().height + 20; // # 20 padding\n                    let translateY = 0;\n                    // Calculate bottom position\n                    if (verticalAlign === 'bottom') {\n                        const legendOptions = chart.legend && chart.legend.options;\n                        const legendHeight = (legendOptions &&\n                            legendOptions.verticalAlign === 'bottom' &&\n                            legendOptions.enabled &&\n                            !legendOptions.floating ?\n                            (chart.legend.legendHeight +\n                                pick(legendOptions.margin, 10)) :\n                            0);\n                        groupHeight = groupHeight + legendHeight - 20;\n                        translateY = (alignTranslateY -\n                            groupHeight -\n                            (options.floating ? 0 : options.y) -\n                            (chart.titleOffset ? chart.titleOffset[2] : 0) -\n                            10 // 10 spacing\n                        );\n                    }\n                    if (verticalAlign === 'top') {\n                        if (options.floating) {\n                            translateY = 0;\n                        }\n                        if (chart.titleOffset && chart.titleOffset[0]) {\n                            translateY = chart.titleOffset[0];\n                        }\n                        translateY += ((chart.margin[0] - chart.spacing[0]) || 0);\n                    }\n                    else if (verticalAlign === 'middle') {\n                        if (inputPosition.y === buttonPosition.y) {\n                            translateY = alignTranslateY;\n                        }\n                        else if (inputPosition.y || buttonPosition.y) {\n                            if (inputPosition.y < 0 ||\n                                buttonPosition.y < 0) {\n                                translateY -= Math.min(inputPosition.y, buttonPosition.y);\n                            }\n                            else {\n                                translateY = alignTranslateY - groupHeight;\n                            }\n                        }\n                    }\n                    group.translate(options.x, options.y + Math.floor(translateY));\n                    // Translate HTML inputs\n                    const { minInput, maxInput, dropdown } = this;\n                    if (options.inputEnabled && minInput && maxInput) {\n                        minInput.style.marginTop = group.translateY + 'px';\n                        maxInput.style.marginTop = group.translateY + 'px';\n                    }\n                    if (dropdown) {\n                        dropdown.style.marginTop = group.translateY + 'px';\n                    }\n                }\n            }\n            /**\n             * Align the button group horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignButtonGroup\n             * @param {number} xOffsetForExportButton\n             * @param {number} [width]\n             */\n            alignButtonGroup(xOffsetForExportButton, width) {\n                const { chart, options, buttonGroup, buttons } = this;\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft - chart.spacing[3];\n                let translateX = buttonPosition.x - chart.spacing[3];\n                if (buttonPosition.align === 'right') {\n                    translateX += xOffsetForExportButton - plotLeft; // #13014\n                }\n                else if (buttonPosition.align === 'center') {\n                    translateX -= plotLeft / 2;\n                }\n                if (buttonGroup) {\n                    // Align button group\n                    buttonGroup.align({\n                        y: buttonPosition.y,\n                        width: pick(width, this.initialButtonGroupWidth),\n                        align: buttonPosition.align,\n                        x: translateX\n                    }, true, chart.spacingBox);\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#positionButtons\n             */\n            positionButtons() {\n                const { buttons, chart, options, zoomText } = this;\n                const verb = chart.hasLoaded ? 'animate' : 'attr';\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft;\n                let buttonLeft = plotLeft;\n                if (zoomText && zoomText.visibility !== 'hidden') {\n                    // #8769, allow dynamically updating margins\n                    zoomText[verb]({\n                        x: pick(plotLeft + buttonPosition.x, plotLeft)\n                    });\n                    // Button start position\n                    buttonLeft += buttonPosition.x +\n                        zoomText.getBBox().width + 5;\n                }\n                for (let i = 0, iEnd = this.buttonOptions.length; i < iEnd; ++i) {\n                    if (buttons[i].visibility !== 'hidden') {\n                        buttons[i][verb]({ x: buttonLeft });\n                        // increase button position for the next button\n                        buttonLeft += buttons[i].width + options.buttonSpacing;\n                    }\n                    else {\n                        buttons[i][verb]({ x: plotLeft });\n                    }\n                }\n            }\n            /**\n             * Handle collision between the button group and the input group\n             *\n             * @private\n             * @function Highcharts.RangeSelector#handleCollision\n             *\n             * @param  {number} xOffsetForExportButton\n             *                  The X offset of the group required to make room for the\n             *                  exporting button\n             */\n            handleCollision(xOffsetForExportButton) {\n                const { chart, buttonGroup, inputGroup } = this;\n                const { buttonPosition, dropdown, inputPosition } = this.options;\n                const maxButtonWidth = () => {\n                    let buttonWidth = 0;\n                    this.buttons.forEach((button) => {\n                        const bBox = button.getBBox();\n                        if (bBox.width > buttonWidth) {\n                            buttonWidth = bBox.width;\n                        }\n                    });\n                    return buttonWidth;\n                };\n                const groupsOverlap = (buttonGroupWidth) => {\n                    if (inputGroup && buttonGroup) {\n                        const inputGroupX = (inputGroup.alignAttr.translateX +\n                            inputGroup.alignOptions.x -\n                            xOffsetForExportButton +\n                            // getBBox for detecing left margin\n                            inputGroup.getBBox().x +\n                            // 2px padding to not overlap input and label\n                            2);\n                        const inputGroupWidth = inputGroup.alignOptions.width;\n                        const buttonGroupX = buttonGroup.alignAttr.translateX +\n                            buttonGroup.getBBox().x;\n                        return (buttonGroupX + buttonGroupWidth > inputGroupX) &&\n                            (inputGroupX + inputGroupWidth > buttonGroupX) &&\n                            (buttonPosition.y <\n                                (inputPosition.y +\n                                    inputGroup.getBBox().height));\n                    }\n                    return false;\n                };\n                const moveInputsDown = () => {\n                    if (inputGroup && buttonGroup) {\n                        inputGroup.attr({\n                            translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ?\n                                0 :\n                                -xOffsetForExportButton),\n                            translateY: inputGroup.alignAttr.translateY +\n                                buttonGroup.getBBox().height + 10\n                        });\n                    }\n                };\n                if (buttonGroup) {\n                    if (dropdown === 'always') {\n                        this.collapseButtons(xOffsetForExportButton);\n                        if (groupsOverlap(maxButtonWidth())) {\n                            // Move the inputs down if there is still a collision\n                            // after collapsing the buttons\n                            moveInputsDown();\n                        }\n                        return;\n                    }\n                    if (dropdown === 'never') {\n                        this.expandButtons();\n                    }\n                }\n                // Detect collision\n                if (inputGroup && buttonGroup) {\n                    if ((inputPosition.align === buttonPosition.align) ||\n                        // 20 is minimal spacing between elements\n                        groupsOverlap(this.initialButtonGroupWidth + 20)) {\n                        if (dropdown === 'responsive') {\n                            this.collapseButtons(xOffsetForExportButton);\n                            if (groupsOverlap(maxButtonWidth())) {\n                                moveInputsDown();\n                            }\n                        }\n                        else {\n                            moveInputsDown();\n                        }\n                    }\n                    else if (dropdown === 'responsive') {\n                        this.expandButtons();\n                    }\n                }\n                else if (buttonGroup && dropdown === 'responsive') {\n                    if (this.initialButtonGroupWidth > chart.plotWidth) {\n                        this.collapseButtons(xOffsetForExportButton);\n                    }\n                    else {\n                        this.expandButtons();\n                    }\n                }\n            }\n            /**\n             * Collapse the buttons and put the select element on top.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#collapseButtons\n             * @param {number} xOffsetForExportButton\n             */\n            collapseButtons(xOffsetForExportButton) {\n                const { buttons, buttonOptions, chart, dropdown, options, zoomText } = this;\n                const userButtonTheme = (chart.userOptions.rangeSelector &&\n                    chart.userOptions.rangeSelector.buttonTheme) || {};\n                const getAttribs = (text) => ({\n                    text: text ? `${text} ` : '',\n                    width: 'auto',\n                    paddingLeft: pick(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),\n                    paddingRight: pick(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)\n                });\n                if (zoomText) {\n                    zoomText.hide();\n                }\n                let hasActiveButton = false;\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    if (button.state !== 2) {\n                        button.hide();\n                    }\n                    else {\n                        button.show();\n                        button.attr(getAttribs(rangeOptions.text));\n                        hasActiveButton = true;\n                    }\n                });\n                if (!hasActiveButton) {\n                    if (dropdown) {\n                        dropdown.selectedIndex = 0;\n                    }\n                    buttons[0].show();\n                    buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));\n                }\n                const { align } = options.buttonPosition;\n                this.positionButtons();\n                if (align === 'right' || align === 'center') {\n                    this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);\n                }\n                this.showDropdown();\n            }\n            /**\n             * Show all the buttons and hide the select element.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#expandButtons\n             */\n            expandButtons() {\n                const { buttons, buttonOptions, options, zoomText } = this;\n                this.hideDropdown();\n                if (zoomText) {\n                    zoomText.show();\n                }\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    button.show();\n                    button.attr({\n                        text: rangeOptions.text,\n                        width: options.buttonTheme.width || 28,\n                        paddingLeft: pick(options.buttonTheme.paddingLeft, 'unset'),\n                        paddingRight: pick(options.buttonTheme.paddingRight, 'unset')\n                    });\n                    if (button.state < 2) {\n                        button.setState(0);\n                    }\n                });\n                this.positionButtons();\n            }\n            /**\n             * Get the index of the visible button when the buttons are collapsed.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#currentButtonIndex\n             */\n            currentButtonIndex() {\n                const { dropdown } = this;\n                if (dropdown && dropdown.selectedIndex > 0) {\n                    return dropdown.selectedIndex - 1;\n                }\n                return 0;\n            }\n            /**\n             * Position the select element on top of the button.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#showDropdown\n             */\n            showDropdown() {\n                const { buttonGroup, buttons, chart, dropdown } = this;\n                if (buttonGroup && dropdown) {\n                    const { translateX, translateY } = buttonGroup;\n                    const bBox = buttons[this.currentButtonIndex()].getBBox();\n                    css(dropdown, {\n                        left: (chart.plotLeft + translateX) + 'px',\n                        top: (translateY + 0.5) + 'px',\n                        width: bBox.width + 'px',\n                        height: bBox.height + 'px'\n                    });\n                    this.hasVisibleDropdown = true;\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideDropdown\n             */\n            hideDropdown() {\n                const { dropdown } = this;\n                if (dropdown) {\n                    css(dropdown, {\n                        top: '-9999em',\n                        width: '1px',\n                        height: '1px'\n                    });\n                    this.hasVisibleDropdown = false;\n                }\n            }\n            /**\n             * Extracts height of range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getHeight\n             * @return {number}\n             * Returns rangeSelector height\n             */\n            getHeight() {\n                const rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y;\n                let rangeSelectorHeight = 0;\n                if (options.height) {\n                    return options.height;\n                }\n                // Align the elements before we read the height in case we're switching\n                // between wrapped and non-wrapped layout\n                this.alignElements();\n                rangeSelectorHeight = rangeSelectorGroup ?\n                    // 13px to keep back compatibility\n                    (rangeSelectorGroup.getBBox(true).height) + 13 +\n                        yPosition :\n                    0;\n                const minPosition = Math.min(inputPositionY, buttonPositionY);\n                if ((inputPositionY < 0 && buttonPositionY < 0) ||\n                    (inputPositionY > 0 && buttonPositionY > 0)) {\n                    rangeSelectorHeight += Math.abs(minPosition);\n                }\n                return rangeSelectorHeight;\n            }\n            /**\n             * Detect collision with title or subtitle\n             *\n             * @private\n             * @function Highcharts.RangeSelector#titleCollision\n             * @return {boolean}\n             * Returns collision status\n             */\n            titleCollision(chart) {\n                return !(chart.options.title.text ||\n                    chart.options.subtitle.text);\n            }\n            /**\n             * Update the range selector with new options\n             *\n             * @private\n             * @function Highcharts.RangeSelector#update\n             * @param {Highcharts.RangeSelectorOptions} options\n             */\n            update(options) {\n                const chart = this.chart;\n                merge(true, chart.options.rangeSelector, options);\n                this.destroy();\n                this.init(chart);\n                this.render();\n            }\n            /**\n             * Destroys allocated elements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#destroy\n             */\n            destroy() {\n                const rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;\n                if (rSelector.eventsToUnbind) {\n                    rSelector.eventsToUnbind.forEach((unbind) => unbind());\n                    rSelector.eventsToUnbind = void 0;\n                }\n                // Destroy elements in collections\n                destroyObjectProperties(rSelector.buttons);\n                // Clear input element events\n                if (minInput) {\n                    minInput.onfocus = minInput.onblur = minInput.onchange = null;\n                }\n                if (maxInput) {\n                    maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n                }\n                // Destroy HTML and SVG elements\n                objectEach(rSelector, function (val, key) {\n                    if (val && key !== 'chart') {\n                        if (val instanceof SVGElement) {\n                            // SVGElement\n                            val.destroy();\n                        }\n                        else if (val instanceof window.HTMLElement) {\n                            // HTML element\n                            discardElement(val);\n                        }\n                    }\n                    if (val !== RangeSelector.prototype[key]) {\n                        rSelector[key] = null;\n                    }\n                }, this);\n            }\n        }\n        extend(RangeSelector.prototype, {\n            /**\n             * The default buttons for pre-selecting time frames.\n             * @private\n             */\n            defaultButtons: [{\n                    type: 'month',\n                    count: 1,\n                    text: '1m',\n                    title: 'View 1 month'\n                }, {\n                    type: 'month',\n                    count: 3,\n                    text: '3m',\n                    title: 'View 3 months'\n                }, {\n                    type: 'month',\n                    count: 6,\n                    text: '6m',\n                    title: 'View 6 months'\n                }, {\n                    type: 'ytd',\n                    text: 'YTD',\n                    title: 'View year to date'\n                }, {\n                    type: 'year',\n                    count: 1,\n                    text: '1y',\n                    title: 'View 1 year'\n                }, {\n                    type: 'all',\n                    text: 'All',\n                    title: 'View all'\n                }],\n            /**\n             * The date formats to use when setting min, max and value on date inputs.\n             * @private\n             */\n            inputTypeFormats: {\n                'datetime-local': '%Y-%m-%dT%H:%M:%S',\n                'date': '%Y-%m-%d',\n                'time': '%H:%M:%S'\n            }\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Define the time span for the button\n         *\n         * @typedef {\"all\"|\"day\"|\"hour\"|\"millisecond\"|\"minute\"|\"month\"|\"second\"|\"week\"|\"year\"|\"ytd\"} Highcharts.RangeSelectorButtonTypeValue\n         */\n        /**\n         * Callback function to react on button clicks.\n         *\n         * @callback Highcharts.RangeSelectorClickCallbackFunction\n         *\n         * @param {global.Event} e\n         *        Event arguments.\n         *\n         * @param {boolean|undefined}\n         *        Return false to cancel the default button event.\n         */\n        /**\n         * Callback function to parse values entered in the input boxes and return a\n         * valid JavaScript time as milliseconds since 1970.\n         *\n         * @callback Highcharts.RangeSelectorParseCallbackFunction\n         *\n         * @param {string} value\n         *        Input value to parse.\n         *\n         * @return {number}\n         *         Parsed JavaScript time value.\n         */\n        (''); // keeps doclets above in JS file\n\n        return RangeSelector;\n    });\n    _registerModule(_modules, 'Accessibility/Components/RangeSelectorComponent.js', [_modules['Stock/RangeSelector/RangeSelector.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function (RangeSelector, AccessibilityComponent, ChartUtilities, Announcer, KeyboardNavigationHandler, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for the range selector.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT, getAxisRangeDescription } = ChartUtilities;\n        const { addEvent, attr } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Do we want date input navigation\n         * @private\n         */\n        function shouldRunInputNavigation(chart) {\n            return Boolean(chart.rangeSelector &&\n                chart.rangeSelector.inputGroup &&\n                chart.rangeSelector.inputGroup.element.style.visibility !== 'hidden' &&\n                chart.options.rangeSelector.inputEnabled !== false &&\n                chart.rangeSelector.minInput &&\n                chart.rangeSelector.maxInput);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The RangeSelectorComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.RangeSelectorComponent\n         */\n        class RangeSelectorComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.announcer = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                this.announcer = new Announcer(chart, 'polite');\n            }\n            /**\n             * Called on first render/updates to the chart, including options changes.\n             */\n            onChartUpdate() {\n                const chart = this.chart, component = this, rangeSelector = chart.rangeSelector;\n                if (!rangeSelector) {\n                    return;\n                }\n                this.updateSelectorVisibility();\n                this.setDropdownAttrs();\n                if (rangeSelector.buttons &&\n                    rangeSelector.buttons.length) {\n                    rangeSelector.buttons.forEach((button) => {\n                        component.setRangeButtonAttrs(button);\n                    });\n                }\n                // Make sure input boxes are accessible and focusable\n                if (rangeSelector.maxInput && rangeSelector.minInput) {\n                    ['minInput', 'maxInput'].forEach(function (key, i) {\n                        const input = rangeSelector[key];\n                        if (input) {\n                            unhideChartElementFromAT(chart, input);\n                            component.setRangeInputAttrs(input, 'accessibility.rangeSelector.' + (i ? 'max' : 'min') +\n                                'InputLabel');\n                        }\n                    });\n                }\n            }\n            /**\n             * Hide buttons from AT when showing dropdown, and vice versa.\n             * @private\n             */\n            updateSelectorVisibility() {\n                const chart = this.chart;\n                const rangeSelector = chart.rangeSelector;\n                const dropdown = (rangeSelector &&\n                    rangeSelector.dropdown);\n                const buttons = (rangeSelector &&\n                    rangeSelector.buttons ||\n                    []);\n                const hideFromAT = (el) => el.setAttribute('aria-hidden', true);\n                if (rangeSelector &&\n                    rangeSelector.hasVisibleDropdown &&\n                    dropdown) {\n                    unhideChartElementFromAT(chart, dropdown);\n                    buttons.forEach((btn) => hideFromAT(btn.element));\n                }\n                else {\n                    if (dropdown) {\n                        hideFromAT(dropdown);\n                    }\n                    buttons.forEach((btn) => unhideChartElementFromAT(chart, btn.element));\n                }\n            }\n            /**\n             * Set accessibility related attributes on dropdown element.\n             * @private\n             */\n            setDropdownAttrs() {\n                const chart = this.chart;\n                const dropdown = (chart.rangeSelector &&\n                    chart.rangeSelector.dropdown);\n                if (dropdown) {\n                    const label = chart.langFormat('accessibility.rangeSelector.dropdownLabel', { rangeTitle: chart.options.lang.rangeSelectorZoom });\n                    dropdown.setAttribute('aria-label', label);\n                    dropdown.setAttribute('tabindex', -1);\n                }\n            }\n            /**\n             * Set attrs for a range button\n             * @private\n             */\n            setRangeButtonAttrs(button) {\n                attr(button.element, {\n                    tabindex: -1,\n                    role: 'button'\n                });\n            }\n            /**\n             * Set attrs for a date input\n             * @private\n             */\n            setRangeInputAttrs(input, langKey) {\n                const chart = this.chart;\n                attr(input, {\n                    tabindex: -1,\n                    'aria-label': chart.langFormat(langKey, { chart: chart })\n                });\n            }\n            /**\n             * Handle arrow key nav\n             * @private\n             */\n            onButtonNavKbdArrowKey(keyboardNavigationHandler, keyCode) {\n                const response = keyboardNavigationHandler.response, keys = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility\n                    .keyboardNavigation.wrapAround, direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);\n                if (!didHighlight) {\n                    if (wrapAround) {\n                        keyboardNavigationHandler.init(direction);\n                        return response.success;\n                    }\n                    return response[direction > 0 ? 'next' : 'prev'];\n                }\n                return response.success;\n            }\n            /**\n             * Handle keyboard click\n             * @private\n             */\n            onButtonNavKbdClick(keyboardNavigationHandler) {\n                const response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;\n                if (!wasDisabled) {\n                    this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);\n                }\n                return response.success;\n            }\n            /**\n             * Called whenever a range selector button has been clicked, either by\n             * mouse, touch, or kbd/voice/other.\n             * @private\n             */\n            onAfterBtnClick() {\n                const chart = this.chart;\n                const axisRangeDescription = getAxisRangeDescription(chart.xAxis[0]);\n                const announcement = chart.langFormat('accessibility.rangeSelector.clickButtonAnnouncement', { chart, axisRangeDescription });\n                if (announcement) {\n                    this.announcer.announce(announcement);\n                }\n            }\n            /**\n             * Handle move between input elements with Tab key\n             * @private\n             */\n            onInputKbdMove(direction) {\n                const chart = this.chart;\n                const rangeSel = chart.rangeSelector;\n                const newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;\n                const newIxOutOfRange = newIx > 1 || newIx < 0;\n                if (newIxOutOfRange) {\n                    if (chart.accessibility) {\n                        // Ignore focus\n                        chart.accessibility.keyboardNavigation.exiting = true;\n                        chart.accessibility.keyboardNavigation.tabindexContainer\n                            .focus();\n                        return chart.accessibility.keyboardNavigation.move(direction);\n                    }\n                }\n                else if (rangeSel) {\n                    const svgEl = rangeSel[newIx ? 'maxDateBox' : 'minDateBox'];\n                    const inputEl = rangeSel[newIx ? 'maxInput' : 'minInput'];\n                    if (svgEl && inputEl) {\n                        chart.setFocusToElement(svgEl, inputEl);\n                    }\n                }\n                return true;\n            }\n            /**\n             * Init date input navigation\n             * @private\n             */\n            onInputNavInit(direction) {\n                const component = this;\n                const chart = this.chart;\n                const buttonIxToHighlight = direction > 0 ? 0 : 1;\n                const rangeSel = chart.rangeSelector;\n                const svgEl = (rangeSel &&\n                    rangeSel[buttonIxToHighlight ? 'maxDateBox' : 'minDateBox']);\n                const minInput = (rangeSel && rangeSel.minInput);\n                const maxInput = (rangeSel && rangeSel.maxInput);\n                const inputEl = buttonIxToHighlight ? maxInput : minInput;\n                chart.highlightedInputRangeIx = buttonIxToHighlight;\n                if (svgEl && minInput && maxInput) {\n                    chart.setFocusToElement(svgEl, inputEl);\n                    // Tab-press with the input focused does not propagate to chart\n                    // automatically, so we manually catch and handle it when relevant.\n                    if (this.removeInputKeydownHandler) {\n                        this.removeInputKeydownHandler();\n                    }\n                    const keydownHandler = (e) => {\n                        const isTab = (e.which || e.keyCode) === this.keyCodes.tab;\n                        if (isTab &&\n                            component.onInputKbdMove(e.shiftKey ? -1 : 1)) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                    };\n                    const minRemover = addEvent(minInput, 'keydown', keydownHandler);\n                    const maxRemover = addEvent(maxInput, 'keydown', keydownHandler);\n                    this.removeInputKeydownHandler = () => {\n                        minRemover();\n                        maxRemover();\n                    };\n                }\n            }\n            /**\n             * Terminate date input nav\n             * @private\n             */\n            onInputNavTerminate() {\n                const rangeSel = (this.chart.rangeSelector || {});\n                if (rangeSel.maxInput) {\n                    rangeSel.hideInput('max');\n                }\n                if (rangeSel.minInput) {\n                    rangeSel.hideInput('min');\n                }\n                if (this.removeInputKeydownHandler) {\n                    this.removeInputKeydownHandler();\n                    delete this.removeInputKeydownHandler;\n                }\n            }\n            /**\n             * Init range selector dropdown nav\n             * @private\n             */\n            initDropdownNav() {\n                const chart = this.chart;\n                const rangeSelector = chart.rangeSelector;\n                const dropdown = (rangeSelector && rangeSelector.dropdown);\n                if (rangeSelector && dropdown) {\n                    chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);\n                    if (this.removeDropdownKeydownHandler) {\n                        this.removeDropdownKeydownHandler();\n                    }\n                    // Tab-press with dropdown focused does not propagate to chart\n                    // automatically, so we manually catch and handle it when relevant.\n                    this.removeDropdownKeydownHandler = addEvent(dropdown, 'keydown', (e) => {\n                        const isTab = (e.which || e.keyCode) === this.keyCodes.tab, a11y = chart.accessibility;\n                        if (isTab) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                            if (a11y) {\n                                a11y.keyboardNavigation.tabindexContainer.focus();\n                                a11y.keyboardNavigation.move(e.shiftKey ? -1 : 1);\n                            }\n                        }\n                    });\n                }\n            }\n            /**\n             * Get navigation for the range selector buttons.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler} The module object.\n             */\n            getRangeSelectorButtonNavigation() {\n                const chart = this.chart;\n                const keys = this.keyCodes;\n                const component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.left, keys.right, keys.up, keys.down],\n                            function (keyCode) {\n                                return component.onButtonNavKbdArrowKey(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onButtonNavKbdClick(this);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return !!(chart.rangeSelector &&\n                            chart.rangeSelector.buttons &&\n                            chart.rangeSelector.buttons.length);\n                    },\n                    init: function (direction) {\n                        const rangeSelector = chart.rangeSelector;\n                        if (rangeSelector && rangeSelector.hasVisibleDropdown) {\n                            component.initDropdownNav();\n                        }\n                        else if (rangeSelector) {\n                            const lastButtonIx = rangeSelector.buttons.length - 1;\n                            chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);\n                        }\n                    },\n                    terminate: function () {\n                        if (component.removeDropdownKeydownHandler) {\n                            component.removeDropdownKeydownHandler();\n                            delete component.removeDropdownKeydownHandler;\n                        }\n                    }\n                });\n            }\n            /**\n             * Get navigation for the range selector input boxes.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler}\n             *         The module object.\n             */\n            getRangeSelectorInputNavigation() {\n                const chart = this.chart;\n                const component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [],\n                    validate: function () {\n                        return shouldRunInputNavigation(chart);\n                    },\n                    init: function (direction) {\n                        component.onInputNavInit(direction);\n                    },\n                    terminate: function () {\n                        component.onInputNavTerminate();\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handlers for this component.\n             * @return {Array<Highcharts.KeyboardNavigationHandler>}\n             *         List of module objects.\n             */\n            getKeyboardNavigation() {\n                return [\n                    this.getRangeSelectorButtonNavigation(),\n                    this.getRangeSelectorInputNavigation()\n                ];\n            }\n            /**\n             * Remove component traces\n             */\n            destroy() {\n                if (this.removeDropdownKeydownHandler) {\n                    this.removeDropdownKeydownHandler();\n                }\n                if (this.removeInputKeydownHandler) {\n                    this.removeInputKeydownHandler();\n                }\n                if (this.announcer) {\n                    this.announcer.destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (RangeSelectorComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Highlight range selector button by index.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightRangeSelectorButton\n             */\n            function chartHighlightRangeSelectorButton(ix) {\n                const buttons = (this.rangeSelector &&\n                    this.rangeSelector.buttons ||\n                    []);\n                const curHighlightedIx = this.highlightedRangeSelectorItemIx;\n                const curSelectedIx = (this.rangeSelector &&\n                    this.rangeSelector.selected);\n                // Deselect old\n                if (typeof curHighlightedIx !== 'undefined' &&\n                    buttons[curHighlightedIx] &&\n                    curHighlightedIx !== curSelectedIx) {\n                    buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);\n                }\n                // Select new\n                this.highlightedRangeSelectorItemIx = ix;\n                if (buttons[ix]) {\n                    this.setFocusToElement(buttons[ix].box, buttons[ix].element);\n                    if (ix !== curSelectedIx) {\n                        this.oldRangeSelectorItemState = buttons[ix].state;\n                        buttons[ix].setState(1);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Build compositions\n             * @private\n             */\n            function compose(ChartClass, RangeSelectorClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightRangeSelectorButton = (chartHighlightRangeSelectorButton);\n                }\n                if (U.pushUnique(composedMembers, RangeSelectorClass)) {\n                    addEvent(RangeSelector, 'afterBtnClick', rangeSelectorAfterBtnClick);\n                }\n            }\n            RangeSelectorComponent.compose = compose;\n            /**\n             * Range selector does not have destroy-setup for class instance events - so\n             * we set it on the class and call the component from here.\n             * @private\n             */\n            function rangeSelectorAfterBtnClick() {\n                const a11y = this.chart.accessibility;\n                if (a11y && a11y.components.rangeSelector) {\n                    return a11y.components.rangeSelector.onAfterBtnClick();\n                }\n            }\n        })(RangeSelectorComponent || (RangeSelectorComponent = {}));\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n\n        return RangeSelectorComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/ForcedMarkers.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Handle forcing series markers.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, merge } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ForcedMarkersComposition;\n        (function (ForcedMarkersComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Compositions\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(SeriesClass) {\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    addEvent(SeriesClass, 'afterSetOptions', seriesOnAfterSetOptions);\n                    addEvent(SeriesClass, 'render', seriesOnRender);\n                    addEvent(SeriesClass, 'afterRender', seriesOnAfterRender);\n                }\n            }\n            ForcedMarkersComposition.compose = compose;\n            /**\n             * @private\n             */\n            function forceZeroOpacityMarkerOptions(options) {\n                merge(true, options, {\n                    marker: {\n                        enabled: true,\n                        states: {\n                            normal: {\n                                opacity: 0\n                            }\n                        }\n                    }\n                });\n            }\n            /**\n             * @private\n             */\n            function getPointMarkerOpacity(pointOptions) {\n                return pointOptions.marker.states &&\n                    pointOptions.marker.states.normal &&\n                    pointOptions.marker.states.normal.opacity;\n            }\n            /**\n             * @private\n             */\n            function handleForcePointMarkers(series) {\n                let i = series.points.length;\n                while (i--) {\n                    const point = series.points[i];\n                    const pointOptions = point.options;\n                    const hadForcedMarker = point.hasForcedA11yMarker;\n                    delete point.hasForcedA11yMarker;\n                    if (pointOptions.marker) {\n                        const isStillForcedMarker = hadForcedMarker &&\n                            getPointMarkerOpacity(pointOptions) === 0;\n                        if (pointOptions.marker.enabled && !isStillForcedMarker) {\n                            unforcePointMarkerOptions(pointOptions);\n                            point.hasForcedA11yMarker = false;\n                        }\n                        else if (pointOptions.marker.enabled === false) {\n                            forceZeroOpacityMarkerOptions(pointOptions);\n                            point.hasForcedA11yMarker = true;\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function hasIndividualPointMarkerOptions(series) {\n                return !!(series._hasPointMarkers &&\n                    series.points &&\n                    series.points.length);\n            }\n            /**\n             * @private\n             */\n            function isWithinDescriptionThreshold(series) {\n                const a11yOptions = series.chart.options.accessibility;\n                return series.points.length <\n                    a11yOptions.series.pointDescriptionEnabledThreshold ||\n                    a11yOptions.series\n                        .pointDescriptionEnabledThreshold === false;\n            }\n            /**\n             * Process marker graphics after render\n             * @private\n             */\n            function seriesOnAfterRender() {\n                const series = this;\n                // For styled mode the rendered graphic does not reflect the style\n                // options, and we need to add/remove classes to achieve the same.\n                if (series.chart.styledMode) {\n                    if (series.markerGroup) {\n                        series.markerGroup[series.a11yMarkersForced ? 'addClass' : 'removeClass']('highcharts-a11y-markers-hidden');\n                    }\n                    // Do we need to handle individual points?\n                    if (hasIndividualPointMarkerOptions(series)) {\n                        series.points.forEach((point) => {\n                            if (point.graphic) {\n                                point.graphic[point.hasForcedA11yMarker ?\n                                    'addClass' : 'removeClass']('highcharts-a11y-marker-hidden');\n                                point.graphic[point.hasForcedA11yMarker === false ?\n                                    'addClass' :\n                                    'removeClass']('highcharts-a11y-marker-visible');\n                            }\n                        });\n                    }\n                }\n            }\n            /**\n             * Keep track of options to reset markers to if no longer forced.\n             * @private\n             */\n            function seriesOnAfterSetOptions(e) {\n                this.resetA11yMarkerOptions = merge(e.options.marker || {}, this.userOptions.marker || {});\n            }\n            /**\n             * Keep track of forcing markers.\n             * @private\n             */\n            function seriesOnRender() {\n                const series = this, options = series.options;\n                if (shouldForceMarkers(series)) {\n                    if (options.marker && options.marker.enabled === false) {\n                        series.a11yMarkersForced = true;\n                        forceZeroOpacityMarkerOptions(series.options);\n                    }\n                    if (hasIndividualPointMarkerOptions(series)) {\n                        handleForcePointMarkers(series);\n                    }\n                }\n                else if (series.a11yMarkersForced) {\n                    delete series.a11yMarkersForced;\n                    unforceSeriesMarkerOptions(series);\n                    delete series.resetA11yMarkerOptions;\n                }\n            }\n            /**\n             * @private\n             */\n            function shouldForceMarkers(series) {\n                const chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility &&\n                    series.options.accessibility.enabled) !== false;\n                return (chartA11yEnabled &&\n                    seriesA11yEnabled &&\n                    isWithinDescriptionThreshold(series));\n            }\n            /**\n             * @private\n             */\n            function unforcePointMarkerOptions(pointOptions) {\n                merge(true, pointOptions.marker, {\n                    states: {\n                        normal: {\n                            opacity: getPointMarkerOpacity(pointOptions) || 1\n                        }\n                    }\n                });\n            }\n            /**\n             * Reset markers to normal\n             * @private\n             */\n            function unforceSeriesMarkerOptions(series) {\n                const resetMarkerOptions = series.resetA11yMarkerOptions;\n                if (resetMarkerOptions) {\n                    const originalOpactiy = resetMarkerOptions.states &&\n                        resetMarkerOptions.states.normal &&\n                        resetMarkerOptions.states.normal.opacity;\n                    series.update({\n                        marker: {\n                            enabled: resetMarkerOptions.enabled,\n                            states: {\n                                normal: { opacity: originalOpactiy }\n                            }\n                        }\n                    });\n                }\n            }\n        })(ForcedMarkersComposition || (ForcedMarkersComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ForcedMarkersComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js']], function (Point, Series, SeriesRegistry, H, U, KeyboardNavigationHandler, EventProvider, ChartUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Handle keyboard navigation for series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { seriesTypes } = SeriesRegistry;\n        const { doc } = H;\n        const { defined, fireEvent } = U;\n        const { getPointFromXY, getSeriesFromName, scrollToPoint } = ChartUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Get the index of a point in a series. This is needed when using e.g. data\n         * grouping.\n         *\n         * @private\n         * @function getPointIndex\n         * @param {Highcharts.AccessibilityPoint} point\n         * The point to find index of.\n         * @return {number|undefined}\n         * The index in the series.points array of the point.\n         */\n        function getPointIndex(point) {\n            const index = point.index, points = point.series.points;\n            let i = points.length;\n            if (points[index] !== point) {\n                while (i--) {\n                    if (points[i] === point) {\n                        return i;\n                    }\n                }\n            }\n            else {\n                return index;\n            }\n        }\n        /**\n         * Determine if series navigation should be skipped\n         * @private\n         */\n        function isSkipSeries(series) {\n            const a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;\n            return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false ||\n                seriesA11yOptions.enabled === false ||\n                series.options.enableMouseTracking === false || // #8440\n                !series.visible ||\n                // Skip all points in a series where pointNavigationEnabledThreshold is\n                // reached\n                (seriesNavOptions.pointNavigationEnabledThreshold &&\n                    seriesNavOptions.pointNavigationEnabledThreshold <=\n                        series.points.length);\n        }\n        /**\n         * Determine if navigation for a point should be skipped\n         * @private\n         */\n        function isSkipPoint(point) {\n            const a11yOptions = point.series.chart.options.accessibility;\n            const pointA11yDisabled = (point.options.accessibility &&\n                point.options.accessibility.enabled === false);\n            return point.isNull &&\n                a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints ||\n                point.visible === false ||\n                point.isInside === false ||\n                pointA11yDisabled ||\n                isSkipSeries(point.series);\n        }\n        /**\n         * Get the first point that is not a skip point in this series.\n         * @private\n         */\n        function getFirstValidPointInSeries(series) {\n            const points = series.points || [], len = points.length;\n            for (let i = 0; i < len; ++i) {\n                if (!isSkipPoint(points[i])) {\n                    return points[i];\n                }\n            }\n            return null;\n        }\n        /**\n         * Get the first point that is not a skip point in this chart.\n         * @private\n         */\n        function getFirstValidPointInChart(chart) {\n            const series = chart.series || [], len = series.length;\n            for (let i = 0; i < len; ++i) {\n                if (!isSkipSeries(series[i])) {\n                    const point = getFirstValidPointInSeries(series[i]);\n                    if (point) {\n                        return point;\n                    }\n                }\n            }\n            return null;\n        }\n        /**\n         * @private\n         */\n        function highlightLastValidPointInChart(chart) {\n            const numSeries = chart.series.length;\n            let i = numSeries, res = false;\n            while (i--) {\n                chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];\n                // Highlight first valid point in the series will also\n                // look backwards. It always starts from currently\n                // highlighted point.\n                res = chart.series[i].highlightNextValidPoint();\n                if (res) {\n                    break;\n                }\n            }\n            return res;\n        }\n        /**\n         * After drilling down/up, we need to set focus to the first point for\n         * screen readers and keyboard nav.\n         * @private\n         */\n        function updateChartFocusAfterDrilling(chart) {\n            const point = getFirstValidPointInChart(chart);\n            if (point) {\n                point.highlight(false); // Do not visually highlight\n            }\n        }\n        /**\n         * Highlight the first point in chart that is not a skip point\n         * @private\n         */\n        function highlightFirstValidPointInChart(chart) {\n            delete chart.highlightedPoint;\n            const point = getFirstValidPointInChart(chart);\n            return point ? point.highlight() : false;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.SeriesKeyboardNavigation\n         */\n        class SeriesKeyboardNavigation {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, keyCodes) {\n                this.keyCodes = keyCodes;\n                this.chart = chart;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the keyboard navigation\n             */\n            init() {\n                const keyboardNavigation = this, chart = this.chart, e = this.eventProvider = new EventProvider();\n                e.addEvent(Series, 'destroy', function () {\n                    return keyboardNavigation.onSeriesDestroy(this);\n                });\n                e.addEvent(chart, 'afterApplyDrilldown', function () {\n                    updateChartFocusAfterDrilling(this);\n                });\n                e.addEvent(chart, 'drilldown', function (e) {\n                    const point = e.point, series = point.series;\n                    keyboardNavigation.lastDrilledDownPoint = {\n                        x: point.x,\n                        y: point.y,\n                        seriesName: series ? series.name : ''\n                    };\n                });\n                e.addEvent(chart, 'drillupall', function () {\n                    setTimeout(function () {\n                        keyboardNavigation.onDrillupAll();\n                    }, 10);\n                });\n                // Heatmaps et al. alter z-index in setState, causing elements\n                // to lose focus\n                e.addEvent(Point, 'afterSetState', function () {\n                    const point = this;\n                    const pointEl = point.graphic && point.graphic.element;\n                    const focusedElement = doc.activeElement;\n                    // VO brings focus with it to container, causing series nav to run.\n                    // If then navigating with virtual cursor, it is possible to leave\n                    // keyboard nav module state on the data points and still activate\n                    // proxy buttons.\n                    const focusedElClassName = (focusedElement && focusedElement.getAttribute('class'));\n                    const isProxyFocused = focusedElClassName &&\n                        focusedElClassName.indexOf('highcharts-a11y-proxy-button') > -1;\n                    if (chart.highlightedPoint === point &&\n                        focusedElement !== pointEl &&\n                        !isProxyFocused &&\n                        pointEl &&\n                        pointEl.focus) {\n                        pointEl.focus();\n                    }\n                });\n            }\n            /**\n             * After drillup we want to find the point that was drilled down to and\n             * highlight it.\n             * @private\n             */\n            onDrillupAll() {\n                const last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName(chart, last.seriesName);\n                let point;\n                if (last && series && defined(last.x) && defined(last.y)) {\n                    point = getPointFromXY(series, last.x, last.y);\n                }\n                point = point || getFirstValidPointInChart(chart);\n                // Container focus can be lost on drillup due to deleted elements.\n                if (chart.container) {\n                    chart.container.focus();\n                }\n                if (point && point.highlight) {\n                    point.highlight(false); // Do not visually highlight\n                }\n            }\n            /**\n             * @private\n             */\n            getKeyboardNavigationHandler() {\n                const keyboardNavigation = this, keys = this.keyCodes, chart = this.chart, inverted = chart.inverted;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [inverted ? [keys.up, keys.down] : [keys.left, keys.right],\n                            function (keyCode) {\n                                return keyboardNavigation.onKbdSideways(this, keyCode);\n                            }],\n                        [inverted ? [keys.left, keys.right] : [keys.up, keys.down],\n                            function (keyCode) {\n                                return keyboardNavigation.onKbdVertical(this, keyCode);\n                            }],\n                        [[keys.enter, keys.space],\n                            function (keyCode, event) {\n                                const point = chart.highlightedPoint;\n                                if (point) {\n                                    event.point = point;\n                                    fireEvent(point.series, 'click', event);\n                                    point.firePointEvent('click');\n                                }\n                                return this.response.success;\n                            }],\n                        [[keys.home],\n                            function () {\n                                highlightFirstValidPointInChart(chart);\n                                return this.response.success;\n                            }],\n                        [[keys.end],\n                            function () {\n                                highlightLastValidPointInChart(chart);\n                                return this.response.success;\n                            }],\n                        [[keys.pageDown, keys.pageUp],\n                            function (keyCode) {\n                                chart.highlightAdjacentSeries(keyCode === keys.pageDown);\n                                return this.response.success;\n                            }]\n                    ],\n                    init: function () {\n                        return keyboardNavigation.onHandlerInit(this);\n                    },\n                    validate: function () {\n                        return !!getFirstValidPointInChart(chart);\n                    },\n                    terminate: function () {\n                        return keyboardNavigation.onHandlerTerminate();\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler\n             * @param {number} keyCode\n             * @return {number}\n             * response\n             */\n            onKbdSideways(handler, keyCode) {\n                const keys = this.keyCodes, isNext = keyCode === keys.right || keyCode === keys.down;\n                return this.attemptHighlightAdjacentPoint(handler, isNext);\n            }\n            /**\n             * When keyboard navigation inits.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler The handler object\n             * @return {number}\n             * response\n             */\n            onHandlerInit(handler) {\n                const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;\n                if (kbdNavOptions.seriesNavigation.rememberPointFocus &&\n                    chart.highlightedPoint) {\n                    chart.highlightedPoint.highlight();\n                }\n                else {\n                    highlightFirstValidPointInChart(chart);\n                }\n                return handler.response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler\n             * @param {number} keyCode\n             * @return {number}\n             * response\n             */\n            onKbdVertical(handler, keyCode) {\n                const chart = this.chart, keys = this.keyCodes, isNext = keyCode === keys.down || keyCode === keys.right, navOptions = chart.options.accessibility.keyboardNavigation\n                    .seriesNavigation;\n                // Handle serialized mode, act like left/right\n                if (navOptions.mode && navOptions.mode === 'serialize') {\n                    return this.attemptHighlightAdjacentPoint(handler, isNext);\n                }\n                // Normal mode, move between series\n                const highlightMethod = (chart.highlightedPoint &&\n                    chart.highlightedPoint.series.keyboardMoveVertical) ?\n                    'highlightAdjacentPointVertical' :\n                    'highlightAdjacentSeries';\n                chart[highlightMethod](isNext);\n                return handler.response.success;\n            }\n            /**\n             * @private\n             */\n            onHandlerTerminate() {\n                const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;\n                if (chart.tooltip) {\n                    chart.tooltip.hide(0);\n                }\n                const hoverSeries = (chart.highlightedPoint && chart.highlightedPoint.series);\n                if (hoverSeries && hoverSeries.onMouseOut) {\n                    hoverSeries.onMouseOut();\n                }\n                if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {\n                    chart.highlightedPoint.onMouseOut();\n                }\n                if (!kbdNavOptions.seriesNavigation.rememberPointFocus) {\n                    delete chart.highlightedPoint;\n                }\n            }\n            /**\n             * Function that attempts to highlight next/prev point. Handles wrap around.\n             * @private\n             */\n            attemptHighlightAdjacentPoint(handler, directionIsNext) {\n                const chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation\n                    .wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);\n                if (!highlightSuccessful) {\n                    if (wrapAround && (directionIsNext ?\n                        highlightFirstValidPointInChart(chart) :\n                        highlightLastValidPointInChart(chart))) {\n                        return handler.response.success;\n                    }\n                    return handler.response[directionIsNext ? 'next' : 'prev'];\n                }\n                return handler.response.success;\n            }\n            /**\n             * @private\n             */\n            onSeriesDestroy(series) {\n                const chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint &&\n                    chart.highlightedPoint.series === series;\n                if (currentHighlightedPointDestroyed) {\n                    delete chart.highlightedPoint;\n                    if (chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            destroy() {\n                this.eventProvider.removeAddedEvents();\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (SeriesKeyboardNavigation) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Function to highlight next/previous point in chart.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightAdjacentPoint\n             *\n             * @param {boolean} next\n             * Flag for the direction.\n             *\n             * @return {Highcharts.Point|boolean}\n             * Returns highlighted point on success, false on failure (no adjacent point\n             * to highlight in chosen direction).\n             */\n            function chartHighlightAdjacentPoint(next) {\n                const chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points || [], lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries &&\n                    lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1];\n                let newSeries, newPoint;\n                // If no points, return false\n                if (!series[0] || !series[0].points) {\n                    return false;\n                }\n                if (!curPoint) {\n                    // No point is highlighted yet. Try first/last point depending on\n                    // move direction\n                    newPoint = next ? series[0].points[0] : lastPoint;\n                }\n                else {\n                    // We have a highlighted point. Grab next/prev point & series.\n                    newSeries = series[curPoint.series.index + (next ? 1 : -1)];\n                    newPoint = curPoints[curPointIndex + (next ? 1 : -1)];\n                    if (!newPoint && newSeries) {\n                        // Done with this series, try next one\n                        newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];\n                    }\n                    // If there is no adjacent point, we return false\n                    if (!newPoint) {\n                        return false;\n                    }\n                }\n                // Recursively skip points\n                if (isSkipPoint(newPoint)) {\n                    // If we skip this whole series, move to the end of the series\n                    // before we recurse, just to optimize\n                    newSeries = newPoint.series;\n                    if (isSkipSeries(newSeries)) {\n                        chart.highlightedPoint = next ?\n                            newSeries.points[newSeries.points.length - 1] :\n                            newSeries.points[0];\n                    }\n                    else {\n                        // Otherwise, just move one point\n                        chart.highlightedPoint = newPoint;\n                    }\n                    // Retry\n                    return chart.highlightAdjacentPoint(next);\n                }\n                // There is an adjacent point, highlight it\n                return newPoint.highlight();\n            }\n            /**\n             * Highlight the closest point vertically.\n             * @private\n             */\n            function chartHighlightAdjacentPointVertical(down) {\n                const curPoint = this.highlightedPoint;\n                let minDistance = Infinity, bestPoint;\n                if (!defined(curPoint.plotX) || !defined(curPoint.plotY)) {\n                    return false;\n                }\n                this.series.forEach((series) => {\n                    if (isSkipSeries(series)) {\n                        return;\n                    }\n                    series.points.forEach((point) => {\n                        if (!defined(point.plotY) || !defined(point.plotX) ||\n                            point === curPoint) {\n                            return;\n                        }\n                        let yDistance = point.plotY - curPoint.plotY;\n                        const width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) +\n                            width * width * 4; // Weigh horizontal distance highly\n                        // Reverse distance number if axis is reversed\n                        if (series.yAxis && series.yAxis.reversed) {\n                            yDistance *= -1;\n                        }\n                        if (yDistance <= 0 && down || yDistance >= 0 && !down ||\n                            distance < 5 || // Points in same spot => infinite loop\n                            isSkipPoint(point)) {\n                            return;\n                        }\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            bestPoint = point;\n                        }\n                    });\n                });\n                return bestPoint ? bestPoint.highlight() : false;\n            }\n            /**\n             * Highlight next/previous series in chart. Returns false if no adjacent\n             * series in the direction, otherwise returns new highlighted point.\n             * @private\n             */\n            function chartHighlightAdjacentSeries(down) {\n                const chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1];\n                let newSeries, newPoint, adjacentNewPoint;\n                // If no point is highlighted, highlight the first/last point\n                if (!chart.highlightedPoint) {\n                    newSeries = down ? (chart.series && chart.series[0]) : lastSeries;\n                    newPoint = down ?\n                        (newSeries && newSeries.points && newSeries.points[0]) :\n                        lastPoint;\n                    return newPoint ? newPoint.highlight() : false;\n                }\n                newSeries = (chart.series[curPoint.series.index + (down ? -1 : 1)]);\n                if (!newSeries) {\n                    return false;\n                }\n                // We have a new series in this direction, find the right point\n                // Weigh xDistance as counting much higher than Y distance\n                newPoint = getClosestPoint(curPoint, newSeries, 4);\n                if (!newPoint) {\n                    return false;\n                }\n                // New series and point exists, but we might want to skip it\n                if (isSkipSeries(newSeries)) {\n                    // Skip the series\n                    newPoint.highlight();\n                    // Try recurse\n                    adjacentNewPoint = chart.highlightAdjacentSeries(down);\n                    if (!adjacentNewPoint) {\n                        // Recurse failed\n                        curPoint.highlight();\n                        return false;\n                    }\n                    // Recurse succeeded\n                    return adjacentNewPoint;\n                }\n                // Highlight the new point or any first valid point back or forwards\n                // from it\n                newPoint.highlight();\n                return newPoint.series.highlightNextValidPoint();\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, PointClass, SeriesClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightAdjacentPoint = chartHighlightAdjacentPoint;\n                    chartProto.highlightAdjacentPointVertical = (chartHighlightAdjacentPointVertical);\n                    chartProto.highlightAdjacentSeries = chartHighlightAdjacentSeries;\n                }\n                if (U.pushUnique(composedMembers, PointClass)) {\n                    const pointProto = PointClass.prototype;\n                    pointProto.highlight = pointHighlight;\n                }\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    const seriesProto = SeriesClass.prototype;\n                    /**\n                     * Set for which series types it makes sense to move to the closest\n                     * point with up/down arrows, and which series types should just\n                     * move to next series.\n                     * @private\n                     */\n                    seriesProto.keyboardMoveVertical = true;\n                    [\n                        'column',\n                        'gantt',\n                        'pie'\n                    ].forEach((type) => {\n                        if (seriesTypes[type]) {\n                            seriesTypes[type].prototype.keyboardMoveVertical = false;\n                        }\n                    });\n                    seriesProto.highlightNextValidPoint = (seriesHighlightNextValidPoint);\n                }\n            }\n            SeriesKeyboardNavigation.compose = compose;\n            /**\n             * Get the point in a series that is closest (in pixel distance) to a\n             * reference point. Optionally supply weight factors for x and y directions.\n             * @private\n             */\n            function getClosestPoint(point, series, xWeight, yWeight) {\n                let minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;\n                const hasUndefinedPosition = (point) => (!(defined(point.plotX) && defined(point.plotY)));\n                if (hasUndefinedPosition(point)) {\n                    return;\n                }\n                while (i--) {\n                    dPoint = series.points[i];\n                    if (hasUndefinedPosition(dPoint)) {\n                        continue;\n                    }\n                    distance = (point.plotX - dPoint.plotX) *\n                        (point.plotX - dPoint.plotX) *\n                        (xWeight || 1) +\n                        (point.plotY - dPoint.plotY) *\n                            (point.plotY - dPoint.plotY) *\n                            (yWeight || 1);\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        minIx = i;\n                    }\n                }\n                return defined(minIx) ? series.points[minIx] : void 0;\n            }\n            /**\n             * Highlights a point (show tooltip, display hover state, focus element).\n             *\n             * @private\n             * @function Highcharts.Point#highlight\n             *\n             * @return {Highcharts.Point}\n             *         This highlighted point.\n             */\n            function pointHighlight(highlightVisually = true) {\n                const chart = this.series.chart;\n                if (!this.isNull && highlightVisually) {\n                    this.onMouseOver(); // Show the hover marker and tooltip\n                }\n                else {\n                    if (chart.tooltip) {\n                        chart.tooltip.hide(0);\n                    }\n                    // Do not call blur on the element, as it messes up the focus of the\n                    // div element of the chart\n                }\n                scrollToPoint(this);\n                // We focus only after calling onMouseOver because the state change can\n                // change z-index and mess up the element.\n                if (this.graphic) {\n                    chart.setFocusToElement(this.graphic);\n                    if (!highlightVisually && chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                    }\n                }\n                chart.highlightedPoint = this;\n                return this;\n            }\n            /**\n             * Highlight first valid point in a series. Returns the point if\n             * successfully highlighted, otherwise false. If there is a highlighted\n             * point in the series, use that as starting point.\n             *\n             * @private\n             * @function Highcharts.Series#highlightNextValidPoint\n             */\n            function seriesHighlightNextValidPoint() {\n                const curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ?\n                    getPointIndex(curPoint) :\n                    0, points = this.points, len = points.length;\n                if (points && len) {\n                    for (let i = start; i < len; ++i) {\n                        if (!isSkipPoint(points[i])) {\n                            return points[i].highlight();\n                        }\n                    }\n                    for (let j = start; j >= 0; --j) {\n                        if (!isSkipPoint(points[j])) {\n                            return points[j].highlight();\n                        }\n                    }\n                }\n                return false;\n            }\n        })(SeriesKeyboardNavigation || (SeriesKeyboardNavigation = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SeriesKeyboardNavigation;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Components/SeriesComponent/ForcedMarkers.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js'], _modules['Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js']], function (AccessibilityComponent, ChartUtilities, ForcedMarkers, NewDataAnnouncer, SeriesDescriber, SeriesKeyboardNavigation) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for series and points.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { hideSeriesFromAT } = ChartUtilities;\n        const { describeSeries } = SeriesDescriber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The SeriesComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.SeriesComponent\n         */\n        class SeriesComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            static compose(ChartClass, PointClass, SeriesClass) {\n                NewDataAnnouncer.compose(SeriesClass);\n                ForcedMarkers.compose(SeriesClass);\n                SeriesKeyboardNavigation.compose(ChartClass, PointClass, SeriesClass);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Init the component.\n             */\n            init() {\n                this.newDataAnnouncer = new NewDataAnnouncer(this.chart);\n                this.newDataAnnouncer.init();\n                this.keyboardNavigation = new SeriesKeyboardNavigation(this.chart, this.keyCodes);\n                this.keyboardNavigation.init();\n                this.hideTooltipFromATWhenShown();\n                this.hideSeriesLabelsFromATWhenShown();\n            }\n            /**\n             * @private\n             */\n            hideTooltipFromATWhenShown() {\n                const component = this;\n                if (this.chart.tooltip) {\n                    this.addEvent(this.chart.tooltip.constructor, 'refresh', function () {\n                        if (this.chart === component.chart &&\n                            this.label &&\n                            this.label.element) {\n                            this.label.element.setAttribute('aria-hidden', true);\n                        }\n                    });\n                }\n            }\n            /**\n             * @private\n             */\n            hideSeriesLabelsFromATWhenShown() {\n                this.addEvent(this.chart, 'afterDrawSeriesLabels', function () {\n                    this.series.forEach(function (series) {\n                        if (series.labelBySeries) {\n                            series.labelBySeries.attr('aria-hidden', true);\n                        }\n                    });\n                });\n            }\n            /**\n             * Called on chart render. It is necessary to do this for render in case\n             * markers change on zoom/pixel density.\n             */\n            onChartRender() {\n                const chart = this.chart;\n                chart.series.forEach(function (series) {\n                    const shouldDescribeSeries = (series.options.accessibility &&\n                        series.options.accessibility.enabled) !== false &&\n                        series.visible;\n                    if (shouldDescribeSeries) {\n                        describeSeries(series);\n                    }\n                    else {\n                        hideSeriesFromAT(series);\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                return this.keyboardNavigation.getKeyboardNavigationHandler();\n            }\n            /**\n             * Remove traces\n             * @private\n             */\n            destroy() {\n                this.newDataAnnouncer.destroy();\n                this.keyboardNavigation.destroy();\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SeriesComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/ZoomComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function (AccessibilityComponent, CU, HU, KeyboardNavigationHandler, U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility component for chart zoom.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT } = CU;\n        const { getFakeMouseEvent } = HU;\n        const { attr, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function chartHasMapZoom(chart) {\n            return !!((chart.mapView) &&\n                chart.mapNavigation &&\n                chart.mapNavigation.navButtons.length);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The ZoomComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.ZoomComponent\n         */\n        class ZoomComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.focusedMapNavButtonIx = -1;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the component\n             */\n            init() {\n                const component = this, chart = this.chart;\n                this.proxyProvider.addGroup('zoom', 'div');\n                [\n                    'afterShowResetZoom', 'afterApplyDrilldown', 'drillupall'\n                ].forEach((eventType) => {\n                    component.addEvent(chart, eventType, function () {\n                        component.updateProxyOverlays();\n                    });\n                });\n            }\n            /**\n             * Called when chart is updated\n             */\n            onChartUpdate() {\n                const chart = this.chart, component = this;\n                // Make map zoom buttons accessible\n                if (chart.mapNavigation) {\n                    chart.mapNavigation.navButtons.forEach((button, i) => {\n                        unhideChartElementFromAT(chart, button.element);\n                        component.setMapNavButtonAttrs(button.element, 'accessibility.zoom.mapZoom' + (i ? 'Out' : 'In'));\n                    });\n                }\n            }\n            /**\n             * @private\n             * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} button\n             * @param {string} labelFormatKey\n             */\n            setMapNavButtonAttrs(button, labelFormatKey) {\n                const chart = this.chart, label = chart.langFormat(labelFormatKey, { chart: chart });\n                attr(button, {\n                    tabindex: -1,\n                    role: 'button',\n                    'aria-label': label\n                });\n            }\n            /**\n             * Update the proxy overlays on every new render to ensure positions are\n             * correct.\n             */\n            onChartRender() {\n                this.updateProxyOverlays();\n            }\n            /**\n             * Update proxy overlays, recreating the buttons.\n             */\n            updateProxyOverlays() {\n                const chart = this.chart;\n                // Always start with a clean slate\n                this.proxyProvider.clearGroup('zoom');\n                if (chart.resetZoomButton) {\n                    this.createZoomProxyButton(chart.resetZoomButton, 'resetZoomProxyButton', chart.langFormat('accessibility.zoom.resetZoomButton', { chart: chart }));\n                }\n                if (chart.drillUpButton &&\n                    chart.breadcrumbs &&\n                    chart.breadcrumbs.list) {\n                    const lastBreadcrumb = chart.breadcrumbs.list[chart.breadcrumbs.list.length - 1];\n                    this.createZoomProxyButton(chart.drillUpButton, 'drillUpProxyButton', chart.langFormat('accessibility.drillUpButton', {\n                        chart: chart,\n                        buttonText: chart.breadcrumbs.getButtonText(lastBreadcrumb)\n                    }));\n                }\n            }\n            /**\n             * @private\n             * @param {Highcharts.SVGElement} buttonEl\n             * @param {string} buttonProp\n             * @param {string} label\n             */\n            createZoomProxyButton(buttonEl, buttonProp, label) {\n                this[buttonProp] = this.proxyProvider.addProxyElement('zoom', {\n                    click: buttonEl\n                }, {\n                    'aria-label': label,\n                    tabindex: -1\n                });\n            }\n            /**\n             * Get keyboard navigation handler for map zoom.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler} The module object\n             */\n            getMapZoomNavigation() {\n                const keys = this.keyCodes, chart = this.chart, component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.up, keys.down, keys.left, keys.right],\n                            function (keyCode) {\n                                return component.onMapKbdArrow(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.tab],\n                            function (_keyCode, e) {\n                                return component.onMapKbdTab(this, e);\n                            }\n                        ],\n                        [\n                            [keys.space, keys.enter],\n                            function () {\n                                return component.onMapKbdClick(this);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return chartHasMapZoom(chart);\n                    },\n                    init: function (direction) {\n                        return component.onMapNavInit(direction);\n                    }\n                });\n            }\n            /**\n             * Arrow key panning for maps.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context.\n             * @param {number} keyCode Key pressed.\n             * @return {number} Response code\n             */\n            onMapKbdArrow(keyboardNavigationHandler, keyCode) {\n                const chart = this.chart, keys = this.keyCodes, target = chart.container, isY = keyCode === keys.up || keyCode === keys.down, stepDirection = (keyCode === keys.left || keyCode === keys.up) ?\n                    1 : -1, granularity = 10, diff = (isY ? chart.plotHeight : chart.plotWidth) /\n                    granularity * stepDirection, \n                // Randomize since same mousedown coords twice is ignored in MapView\n                r = Math.random() * 10, startPos = {\n                    x: target.offsetLeft + chart.plotLeft + chart.plotWidth / 2 + r,\n                    y: target.offsetTop + chart.plotTop + chart.plotHeight / 2 + r\n                }, endPos = isY ? { x: startPos.x, y: startPos.y + diff } :\n                    { x: startPos.x + diff, y: startPos.y };\n                [\n                    getFakeMouseEvent('mousedown', startPos),\n                    getFakeMouseEvent('mousemove', endPos),\n                    getFakeMouseEvent('mouseup', endPos)\n                ].forEach((e) => target.dispatchEvent(e));\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @param {global.KeyboardEvent} event\n             * @return {number} Response code\n             */\n            onMapKbdTab(keyboardNavigationHandler, event) {\n                const chart = this.chart;\n                const response = keyboardNavigationHandler.response;\n                const isBackwards = event.shiftKey;\n                const isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx ||\n                    !isBackwards && this.focusedMapNavButtonIx;\n                // Deselect old\n                chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);\n                if (isMoveOutOfRange) {\n                    if (chart.mapView) {\n                        chart.mapView.zoomBy(); // Reset zoom\n                    }\n                    return response[isBackwards ? 'prev' : 'next'];\n                }\n                // Select other button\n                this.focusedMapNavButtonIx += isBackwards ? -1 : 1;\n                const button = chart.mapNavigation.navButtons[this.focusedMapNavButtonIx];\n                chart.setFocusToElement(button.box, button.element);\n                button.setState(2);\n                return response.success;\n            }\n            /**\n             * Called on map button click.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context object\n             * @return {number} Response code\n             */\n            onMapKbdClick(keyboardNavigationHandler) {\n                const el = this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element;\n                this.fakeClickEvent(el);\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             * @param {number} direction\n             */\n            onMapNavInit(direction) {\n                const chart = this.chart, zoomIn = chart.mapNavigation.navButtons[0], zoomOut = chart.mapNavigation.navButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;\n                chart.setFocusToElement(initialButton.box, initialButton.element);\n                initialButton.setState(2);\n                this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;\n            }\n            /**\n             * Get keyboard navigation handler for a simple chart button. Provide the\n             * button reference for the chart, and a function to call on click.\n             *\n             * @private\n             * @param {string} buttonProp The property on chart referencing the button.\n             * @return {Highcharts.KeyboardNavigationHandler} The module object\n             */\n            simpleButtonNavigation(buttonProp, proxyProp, onClick) {\n                const keys = this.keyCodes, component = this, chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.tab, keys.up, keys.down, keys.left, keys.right],\n                            function (keyCode, e) {\n                                const isBackwards = (keyCode === keys.tab && e.shiftKey ||\n                                    keyCode === keys.left ||\n                                    keyCode === keys.up);\n                                // Arrow/tab => just move\n                                return this.response[isBackwards ? 'prev' : 'next'];\n                            }\n                        ],\n                        [\n                            [keys.space, keys.enter],\n                            function () {\n                                const res = onClick(this, chart);\n                                return pick(res, this.response.success);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        const hasButton = (chart[buttonProp] &&\n                            chart[buttonProp].box &&\n                            component[proxyProp].buttonElement);\n                        return hasButton;\n                    },\n                    init: function () {\n                        chart.setFocusToElement(chart[buttonProp].box, component[proxyProp].buttonElement);\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handlers for this component.\n             * @return {Array<Highcharts.KeyboardNavigationHandler>}\n             *         List of module objects\n             */\n            getKeyboardNavigation() {\n                return [\n                    this.simpleButtonNavigation('resetZoomButton', 'resetZoomProxyButton', function (_handler, chart) {\n                        chart.zoomOut();\n                    }),\n                    this.simpleButtonNavigation('drillUpButton', 'drillUpProxyButton', function (handler, chart) {\n                        chart.drillUp();\n                        return handler.response.prev;\n                    }),\n                    this.getMapZoomNavigation()\n                ];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ZoomComponent;\n    });\n    _registerModule(_modules, 'Accessibility/HighContrastMode.js', [_modules['Core/Globals.js']], function (H) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Handling for Windows High Contrast Mode.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, isMS, win } = H;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Detect WHCM in the browser.\n         *\n         * @function Highcharts#isHighContrastModeActive\n         * @private\n         * @return {boolean} Returns true if the browser is in High Contrast mode.\n         */\n        function isHighContrastModeActive() {\n            // Use media query on Edge, but not on IE\n            const isEdge = /(Edg)/.test(win.navigator.userAgent);\n            if (win.matchMedia && isEdge) {\n                return win.matchMedia('(-ms-high-contrast: active)').matches;\n            }\n            // Test BG image for IE\n            if (isMS && win.getComputedStyle) {\n                const testDiv = doc.createElement('div');\n                const imageSrc = 'data:image/gif;base64,' +\n                    'R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n                testDiv.style.backgroundImage = `url(${imageSrc})`; // #13071\n                doc.body.appendChild(testDiv);\n                const bi = (testDiv.currentStyle ||\n                    win.getComputedStyle(testDiv)).backgroundImage;\n                doc.body.removeChild(testDiv);\n                return bi === 'none';\n            }\n            // Other browsers use the forced-colors standard\n            return win.matchMedia && win.matchMedia('(forced-colors: active)').matches;\n        }\n        /**\n         * Force high contrast theme for the chart. The default theme is defined in\n         * a separate file.\n         *\n         * @function Highcharts#setHighContrastTheme\n         * @private\n         * @param {Highcharts.AccessibilityChart} chart The chart to set the theme of.\n         * @return {void}\n         */\n        function setHighContrastTheme(chart) {\n            // We might want to add additional functionality here in the future for\n            // storing the old state so that we can reset the theme if HC mode is\n            // disabled. For now, the user will have to reload the page.\n            chart.highContrastModeActive = true;\n            // Apply theme to chart\n            const theme = (chart.options.accessibility.highContrastTheme);\n            chart.update(theme, false);\n            // Force series colors (plotOptions is not enough)\n            chart.series.forEach(function (s) {\n                const plotOpts = theme.plotOptions[s.type] || {};\n                s.update({\n                    color: plotOpts.color || 'windowText',\n                    colors: [plotOpts.color || 'windowText'],\n                    borderColor: plotOpts.borderColor || 'window'\n                });\n                // Force point colors if existing\n                s.points.forEach(function (p) {\n                    if (p.options && p.options.color) {\n                        p.update({\n                            color: plotOpts.color || 'windowText',\n                            borderColor: plotOpts.borderColor || 'window'\n                        }, false);\n                    }\n                });\n            });\n            // The redraw for each series and after is required for 3D pie\n            // (workaround)\n            chart.redraw();\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const whcm = {\n            isHighContrastModeActive,\n            setHighContrastTheme\n        };\n\n        return whcm;\n    });\n    _registerModule(_modules, 'Accessibility/HighContrastTheme.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Default theme for Windows High Contrast Mode.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Theme\n         *\n         * */\n        const theme = {\n            chart: {\n                backgroundColor: 'window'\n            },\n            title: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            subtitle: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            colorAxis: {\n                minColor: 'windowText',\n                maxColor: 'windowText',\n                stops: []\n            },\n            colors: ['windowText'],\n            xAxis: {\n                gridLineColor: 'windowText',\n                labels: {\n                    style: {\n                        color: 'windowText'\n                    }\n                },\n                lineColor: 'windowText',\n                minorGridLineColor: 'windowText',\n                tickColor: 'windowText',\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            yAxis: {\n                gridLineColor: 'windowText',\n                labels: {\n                    style: {\n                        color: 'windowText'\n                    }\n                },\n                lineColor: 'windowText',\n                minorGridLineColor: 'windowText',\n                tickColor: 'windowText',\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            tooltip: {\n                backgroundColor: 'window',\n                borderColor: 'windowText',\n                style: {\n                    color: 'windowText'\n                }\n            },\n            plotOptions: {\n                series: {\n                    lineColor: 'windowText',\n                    fillColor: 'window',\n                    borderColor: 'windowText',\n                    edgeColor: 'windowText',\n                    borderWidth: 1,\n                    dataLabels: {\n                        connectorColor: 'windowText',\n                        color: 'windowText',\n                        style: {\n                            color: 'windowText',\n                            textOutline: 'none'\n                        }\n                    },\n                    marker: {\n                        lineColor: 'windowText',\n                        fillColor: 'windowText'\n                    }\n                },\n                pie: {\n                    color: 'window',\n                    colors: ['window'],\n                    borderColor: 'windowText',\n                    borderWidth: 1\n                },\n                boxplot: {\n                    fillColor: 'window'\n                },\n                candlestick: {\n                    lineColor: 'windowText',\n                    fillColor: 'window'\n                },\n                errorbar: {\n                    fillColor: 'window'\n                }\n            },\n            legend: {\n                backgroundColor: 'window',\n                itemStyle: {\n                    color: 'windowText'\n                },\n                itemHoverStyle: {\n                    color: 'windowText'\n                },\n                itemHiddenStyle: {\n                    color: '#555'\n                },\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            credits: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            drilldown: {\n                activeAxisLabelStyle: {\n                    color: 'windowText'\n                },\n                activeDataLabelStyle: {\n                    color: 'windowText'\n                }\n            },\n            navigation: {\n                buttonOptions: {\n                    symbolStroke: 'windowText',\n                    theme: {\n                        fill: 'window'\n                    }\n                }\n            },\n            rangeSelector: {\n                buttonTheme: {\n                    fill: 'window',\n                    stroke: 'windowText',\n                    style: {\n                        color: 'windowText'\n                    },\n                    states: {\n                        hover: {\n                            fill: 'window',\n                            stroke: 'windowText',\n                            style: {\n                                color: 'windowText'\n                            }\n                        },\n                        select: {\n                            fill: '#444',\n                            stroke: 'windowText',\n                            style: {\n                                color: 'windowText'\n                            }\n                        }\n                    }\n                },\n                inputBoxBorderColor: 'windowText',\n                inputStyle: {\n                    backgroundColor: 'window',\n                    color: 'windowText'\n                },\n                labelStyle: {\n                    color: 'windowText'\n                }\n            },\n            navigator: {\n                handles: {\n                    backgroundColor: 'window',\n                    borderColor: 'windowText'\n                },\n                outlineColor: 'windowText',\n                maskFill: 'transparent',\n                series: {\n                    color: 'windowText',\n                    lineColor: 'windowText'\n                },\n                xAxis: {\n                    gridLineColor: 'windowText'\n                }\n            },\n            scrollbar: {\n                barBackgroundColor: '#444',\n                barBorderColor: 'windowText',\n                buttonArrowColor: 'windowText',\n                buttonBackgroundColor: 'window',\n                buttonBorderColor: 'windowText',\n                rifleColor: 'windowText',\n                trackBackgroundColor: 'window',\n                trackBorderColor: 'windowText'\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return theme;\n    });\n    _registerModule(_modules, 'Accessibility/Options/A11yDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Default options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Formatter callback for the accessibility announcement.\n         *\n         * @callback Highcharts.AccessibilityAnnouncementFormatter\n         *\n         * @param {Array<Highcharts.Series>} updatedSeries\n         * Array of all series that received updates. If an announcement is already\n         * queued, the series that received updates for that announcement are also\n         * included in this array.\n         *\n         * @param {Highcharts.Series} [addedSeries]\n         * This is provided if {@link Highcharts.Chart#addSeries} was called, and there\n         * is a new series. In that case, this argument is a reference to the new\n         * series.\n         *\n         * @param {Highcharts.Point} [addedPoint]\n         * This is provided if {@link Highcharts.Series#addPoint} was called, and there\n         * is a new point. In that case, this argument is a reference to the new point.\n         *\n         * @return {false|string}\n         * The function should return a string with the text to announce to the user.\n         * Return empty string to not announce anything. Return `false` to use the\n         * default announcement format.\n         */\n        /**\n         * @interface Highcharts.PointAccessibilityOptionsObject\n         */ /**\n        * Provide a description of the data point, announced to screen readers.\n        * @name Highcharts.PointAccessibilityOptionsObject#description\n        * @type {string|undefined}\n        * @requires modules/accessibility\n        * @since 7.1.0\n        */ /**\n        * Enable or disable exposing the point to assistive technology\n        * @name Highcharts.PointAccessibilityOptionsObject#enabled\n        * @type {boolean|undefined}\n        * @requires modules/accessibility\n        * @since 9.0.1\n        */\n        /* *\n         * @interface Highcharts.PointOptionsObject in parts/Point.ts\n         */ /**\n        * @name Highcharts.PointOptionsObject#accessibility\n        * @type {Highcharts.PointAccessibilityOptionsObject|undefined}\n        * @requires modules/accessibility\n        * @since 7.1.0\n        */\n        /**\n         * @callback Highcharts.ScreenReaderClickCallbackFunction\n         *\n         * @param {global.MouseEvent} evt\n         *        Mouse click event\n         *\n         * @return {void}\n         */\n        /**\n         * Creates a formatted string for the screen reader module.\n         *\n         * @callback Highcharts.ScreenReaderFormatterCallbackFunction<T>\n         *\n         * @param {T} context\n         *        Context to format\n         *\n         * @return {string}\n         *         Formatted string for the screen reader module.\n         */\n        const Options = {\n            /**\n             * Options for configuring accessibility for the chart. Requires the\n             * [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n             * to be loaded. For a description of the module and information\n             * on its features, see\n             * [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).\n             *\n             * @since        5.0.0\n             * @requires     modules/accessibility\n             * @optionparent accessibility\n             */\n            accessibility: {\n                /**\n                 * Enable accessibility functionality for the chart. For more\n                 * information on how to include these features, and why this is\n                 * recommended, see [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).\n                 *\n                 * Highcharts will by default emit a warning to the console if\n                 * the [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n                 * is not loaded. Setting this option to `false` will override\n                 * and silence the warning.\n                 *\n                 * Once the module is loaded, setting this option to `false`\n                 * will disable the module for this chart.\n                 *\n                 * @since 5.0.0\n                 */\n                enabled: true,\n                /**\n                 * Accessibility options for the screen reader information sections\n                 * added before and after the chart.\n                 *\n                 * @since 8.0.0\n                 */\n                screenReaderSection: {\n                    /**\n                     * Function to run upon clicking the \"View as Data Table\" link in\n                     * the screen reader region.\n                     *\n                     * By default Highcharts will insert and set focus to a data table\n                     * representation of the chart.\n                     *\n                     * @type      {Highcharts.ScreenReaderClickCallbackFunction}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.onViewDataTableClick\n                     */\n                    /**\n                     * Function to run upon clicking the \"Play as sound\" button in\n                     * the screen reader region.\n                     *\n                     * By default Highcharts will call the `chart.sonify` function.\n                     *\n                     * @type      {Highcharts.ScreenReaderClickCallbackFunction}\n                     * @since 8.0.1\n                     * @apioption accessibility.screenReaderSection.onPlayAsSoundClick\n                     */\n                    /**\n                     * A formatter function to create the HTML contents of the hidden\n                     * screen reader information region before the chart. Receives one\n                     * argument, `chart`, referring to the chart object. Should return a\n                     * string with the HTML content of the region. By default this\n                     * returns an automatic description of the chart based on\n                     * [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.beforeChartFormatter\n                     */\n                    /**\n                     * Format for the screen reader information region before the chart.\n                     * Supported HTML tags are `<h1-6>`, `<p>`, `<div>`, `<a>`, `<ul>`,\n                     * `<ol>`, `<li>`, and `<button>`. Attributes are not supported,\n                     * except for id on `<div>`, `<a>`, and `<button>`. Id is required\n                     * on `<a>` and `<button>` in the format `<tag id=\"abcd\">`. Numbers,\n                     * lower- and uppercase letters, \"-\" and \"#\" are valid characters in\n                     * IDs.\n                     *\n                     * The headingTagName is an auto-detected heading (h1-h6) that\n                     * corresponds to the heading level below the previous heading in\n                     * the DOM.\n                     *\n                     * Set to empty string to remove the region altogether.\n                     *\n                     * @since 8.0.0\n                     */\n                    beforeChartFormat: '<{headingTagName}>{chartTitle}</{headingTagName}>' +\n                        '<div>{typeDescription}</div>' +\n                        '<div>{chartSubtitle}</div>' +\n                        '<div>{chartLongdesc}</div>' +\n                        '<div>{playAsSoundButton}</div>' +\n                        '<div>{viewTableButton}</div>' +\n                        '<div>{xAxisDescription}</div>' +\n                        '<div>{yAxisDescription}</div>' +\n                        '<div>{annotationsTitle}{annotationsList}</div>',\n                    /**\n                     * A formatter function to create the HTML contents of the hidden\n                     * screen reader information region after the chart. Analogous to\n                     * [beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.afterChartFormatter\n                     */\n                    /**\n                     * Format for the screen reader information region after the chart.\n                     * Analogous to [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).\n                     *\n                     * @since 8.0.0\n                     */\n                    afterChartFormat: '{endOfChartMarker}',\n                    /**\n                     * Date format to use to describe range of datetime axes.\n                     *\n                     * For an overview of the replacement codes, see\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [point.dateFormat](#accessibility.point.dateFormat)\n                     *\n                     * @since 8.0.0\n                     */\n                    axisRangeDateFormat: '%Y-%m-%d %H:%M:%S'\n                },\n                /**\n                 * Accessibility options global to all data series. Individual series\n                 * can also have specific [accessibility options](#plotOptions.series.accessibility)\n                 * set.\n                 *\n                 * @since 8.0.0\n                 */\n                series: {\n                    /**\n                     * Formatter function to use instead of the default for series\n                     * descriptions. Receives one argument, `series`, referring to the\n                     * series to describe. Should return a string with the description\n                     * of the series for a screen reader user. If `false` is returned,\n                     * the default formatter will be used for that series.\n                     *\n                     * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)\n                     * @see [series.description](#plotOptions.series.description)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Series>}\n                     * @since 8.0.0\n                     * @apioption accessibility.series.descriptionFormatter\n                     */\n                    /**\n                     * Format to use for describing the data series group to assistive\n                     * technology - including screen readers.\n                     *\n                     * The series context and its subproperties are available under the\n                     * variable `{series}`, for example `{series.name}` for the series\n                     * name, and `{series.points.length}` for the number of data points.\n                     *\n                     * The chart context and its subproperties are available under the\n                     * variable `{chart}`, for example `{chart.series.length}` for the\n                     * number of series in the chart.\n                     *\n                     * `{seriesDescription}` refers to the automatic description of the\n                     * series type and number of points added by Highcharts by default.\n                     * `{authorDescription}` refers to the description added in\n                     * [series.description](#plotOptions.series.description) if one is\n                     * present. `{axisDescription}` refers to the description added if\n                     * the chart has multiple X or Y axes.\n                     *\n                     * Note that if [series.descriptionFormatter](#accessibility.series.descriptionFormatter)\n                     * is declared it will take precedence, and this option will be\n                     * overridden.\n                     *\n                     * @sample highcharts/accessibility/advanced-accessible\n                     *  Accessible low-medium-high chart\n                     *\n                     * @type      {string}\n                     * @since 10.1.0\n                     */\n                    descriptionFormat: '{seriesDescription}{authorDescription}{axisDescription}',\n                    /**\n                     * Whether or not to add series descriptions to charts with a single\n                     * series.\n                     *\n                     * @since 8.0.0\n                     */\n                    describeSingleSeries: false,\n                    /**\n                     * When a series contains more points than this, we no longer expose\n                     * information about individual points to screen readers.\n                     *\n                     * Set to `false` to disable.\n                     *\n                     * @type  {boolean|number}\n                     * @since 8.0.0\n                     */\n                    pointDescriptionEnabledThreshold: 200\n                },\n                /**\n                 * Options for descriptions of individual data points.\n                 *\n                 * @since 8.0.0\n                 */\n                point: {\n                    /**\n                     * Date format to use for points on datetime axes when describing\n                     * them to screen reader users.\n                     *\n                     * Defaults to the same format as in tooltip.\n                     *\n                     * For an overview of the replacement codes, see\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [dateFormatter](#accessibility.point.dateFormatter)\n                     *\n                     * @type      {string}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.dateFormat\n                     */\n                    /**\n                     * Formatter function to determine the date/time format used with\n                     * points on datetime axes when describing them to screen reader\n                     * users. Receives one argument, `point`, referring to the point\n                     * to describe. Should return a date format string compatible with\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [dateFormat](#accessibility.point.dateFormat)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.dateFormatter\n                     */\n                    /**\n                     * Prefix to add to the values in the point descriptions. Uses\n                     * [tooltip.valuePrefix](#tooltip.valuePrefix) if not defined.\n                     *\n                     * @type        {string}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valuePrefix\n                     */\n                    /**\n                     * Suffix to add to the values in the point descriptions. Uses\n                     * [tooltip.valueSuffix](#tooltip.valueSuffix) if not defined.\n                     *\n                     * @type        {string}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valueSuffix\n                     */\n                    /**\n                     * Decimals to use for the values in the point descriptions. Uses\n                     * [tooltip.valueDecimals](#tooltip.valueDecimals) if not defined.\n                     *\n                     * @type        {number}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valueDecimals\n                     */\n                    /**\n                     * Formatter function to use instead of the default for point\n                     * descriptions.\n                     *\n                     * Receives one argument, `point`, referring to the point to\n                     * describe. Should return a string with the description of the\n                     * point for a screen reader user. If `false` is returned, the\n                     * default formatter will be used for that point.\n                     *\n                     * Note: Prefer using [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)\n                     * instead if possible, as default functionality such as describing\n                     * annotations will be preserved.\n                     *\n                     * @see [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)\n                     * @see [point.accessibility.description](#series.line.data.accessibility.description)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.descriptionFormatter\n                     */\n                    /**\n                     * Format to use for describing the values of data points\n                     * to assistive technology - including screen readers.\n                     * The point context is available as `{point}`.\n                     *\n                     * Other available context variables include `{index}`, `{value}`, and `{xDescription}`.\n                     *\n                     * Additionally, the series name, annotation info, and\n                     * description added in `point.accessibility.description`\n                     * is added by default if relevant. To override this, use the\n                     * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n                     * option.\n                     *\n                     * @see [point.accessibility.description](#series.line.data.accessibility.description)\n                     * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n                     *\n                     * @type      {string}\n                     * @since 8.0.1\n                     */\n                    valueDescriptionFormat: '{xDescription}{separator}{value}.',\n                    /**\n                     * Whether or not to describe points with the value `null` to\n                     * assistive technology, such as screen readers.\n                     *\n                     * @sample {highmaps} maps/demo/all-areas-as-null\n                     *         Accessible map with null points\n                     *\n                     * @type      {boolean}\n                     * @since 10.1.0\n                     */\n                    describeNull: true\n                },\n                /**\n                 * Amount of landmarks/regions to create for screen reader users. More\n                 * landmarks can make navigation with screen readers easier, but can\n                 * be distracting if there are lots of charts on the page. Three modes\n                 * are available:\n                 *  - `all`: Adds regions for all series, legend, information\n                 *      region.\n                 *  - `one`: Adds a single landmark per chart.\n                 *  - `disabled`: No landmarks are added.\n                 *\n                 * @since 7.1.0\n                 * @validvalue [\"all\", \"one\", \"disabled\"]\n                 */\n                landmarkVerbosity: 'all',\n                /**\n                 * Link the chart to an HTML element describing the contents of the\n                 * chart.\n                 *\n                 * It is always recommended to describe charts using visible text, to\n                 * improve SEO as well as accessibility for users with disabilities.\n                 * This option lets an HTML element with a description be linked to the\n                 * chart, so that screen reader users can connect the two.\n                 *\n                 * By setting this option to a string, Highcharts runs the string as an\n                 * HTML selector query on the entire document. If there is only a single\n                 * match, this element is linked to the chart. The content of the linked\n                 * element will be included in the chart description for screen reader\n                 * users.\n                 *\n                 * By default, the chart looks for an adjacent sibling element with the\n                 * `highcharts-description` class.\n                 *\n                 * The feature can be disabled by setting the option to an empty string,\n                 * or overridden by providing the\n                 * [accessibility.description](#accessibility.description) option.\n                 * Alternatively, the HTML element to link can be passed in directly as\n                 * an HTML node.\n                 *\n                 * If you need the description to be part of the exported image,\n                 * consider using the [caption](#caption) feature.\n                 *\n                 * If you need the description to be hidden visually, use the\n                 * [accessibility.description](#accessibility.description) option.\n                 *\n                 * @see [caption](#caption)\n                 * @see [description](#accessibility.description)\n                 * @see [typeDescription](#accessibility.typeDescription)\n                 *\n                 * @sample highcharts/accessibility/accessible-line\n                 *         Accessible line chart\n                 *\n                 * @type  {string|Highcharts.HTMLDOMElement}\n                 * @since 8.0.0\n                 */\n                linkedDescription: '*[data-highcharts-chart=\"{index}\"] + .highcharts-description',\n                /**\n                 * A hook for adding custom components to the accessibility module.\n                 * Should be an object mapping component names to instances of classes\n                 * inheriting from the Highcharts.AccessibilityComponent base class.\n                 * Remember to add the component to the\n                 * [keyboardNavigation.order](#accessibility.keyboardNavigation.order)\n                 * for the keyboard navigation to be usable.\n                 *\n                 * @sample highcharts/accessibility/custom-component\n                 *         Custom accessibility component\n                 *\n                 * @type      {*}\n                 * @since     7.1.0\n                 * @apioption accessibility.customComponents\n                 */\n                /**\n                 * Theme to apply to the chart when Windows High Contrast Mode is\n                 * detected. By default, a high contrast theme matching the high\n                 * contrast system system colors is used.\n                 *\n                 * @type      {*}\n                 * @since     7.1.3\n                 * @apioption accessibility.highContrastTheme\n                 */\n                /**\n                 * A text description of the chart.\n                 *\n                 * **Note: Prefer using [linkedDescription](#accessibility.linkedDescription)\n                 * or [caption](#caption.text) instead.**\n                 *\n                 * If the Accessibility module is loaded, this option is included by\n                 * default as a long description of the chart in the hidden screen\n                 * reader information region.\n                 *\n                 * Note: Since Highcharts now supports captions and linked descriptions,\n                 * it is preferred to define the description using those methods, as a\n                 * visible caption/description benefits all users. If the\n                 * `accessibility.description` option is defined, the linked description\n                 * is ignored, and the caption is hidden from screen reader users.\n                 *\n                 * @see [linkedDescription](#accessibility.linkedDescription)\n                 * @see [caption](#caption)\n                 * @see [typeDescription](#accessibility.typeDescription)\n                 *\n                 * @type      {string}\n                 * @since     5.0.0\n                 * @apioption accessibility.description\n                 */\n                /**\n                 * A text description of the chart type.\n                 *\n                 * If the Accessibility module is loaded, this will be included in the\n                 * description of the chart in the screen reader information region.\n                 *\n                 * Highcharts will by default attempt to guess the chart type, but for\n                 * more complex charts it is recommended to specify this property for\n                 * clarity.\n                 *\n                 * @type      {string}\n                 * @since     5.0.0\n                 * @apioption accessibility.typeDescription\n                 */\n                /**\n                 * Options for keyboard navigation.\n                 *\n                 * @declare Highcharts.KeyboardNavigationOptionsObject\n                 * @since   5.0.0\n                 */\n                keyboardNavigation: {\n                    /**\n                     * Enable keyboard navigation for the chart.\n                     *\n                     * @since 5.0.0\n                     */\n                    enabled: true,\n                    /**\n                     * Options for the focus border drawn around elements while\n                     * navigating through them.\n                     *\n                     * @sample highcharts/accessibility/custom-focus\n                     *         Custom focus ring\n                     *\n                     * @declare Highcharts.KeyboardNavigationFocusBorderOptionsObject\n                     * @since   6.0.3\n                     */\n                    focusBorder: {\n                        /**\n                         * Enable/disable focus border for chart.\n                         *\n                         * @since 6.0.3\n                         */\n                        enabled: true,\n                        /**\n                         * Hide the browser's default focus indicator.\n                         *\n                         * @since 6.0.4\n                         */\n                        hideBrowserFocusOutline: true,\n                        /**\n                         * Style options for the focus border drawn around elements\n                         * while navigating through them. Note that some browsers in\n                         * addition draw their own borders for focused elements. These\n                         * automatic borders cannot be styled by Highcharts.\n                         *\n                         * In styled mode, the border is given the\n                         * `.highcharts-focus-border` class.\n                         *\n                         * @type    {Highcharts.CSSObject}\n                         * @since   6.0.3\n                         */\n                        style: {\n                            /** @internal */\n                            color: \"#334eff\" /* Palette.highlightColor80 */,\n                            /** @internal */\n                            lineWidth: 2,\n                            /** @internal */\n                            borderRadius: 3\n                        },\n                        /**\n                         * Focus border margin around the elements.\n                         *\n                         * @since 6.0.3\n                         */\n                        margin: 2\n                    },\n                    /**\n                     * Order of tab navigation in the chart. Determines which elements\n                     * are tabbed to first. Available elements are: `series`, `zoom`,\n                     * `rangeSelector`, `chartMenu`, `legend` and `container`. In\n                     * addition, any custom components can be added here. Adding\n                     * `container` first in order will make the keyboard focus stop on\n                     * the chart container first, requiring the user to tab again to\n                     * enter the chart.\n                     *\n                     * @type  {Array<string>}\n                     * @since 7.1.0\n                     */\n                    order: ['series', 'zoom', 'rangeSelector', 'legend', 'chartMenu'],\n                    /**\n                     * Whether or not to wrap around when reaching the end of arrow-key\n                     * navigation for an element in the chart.\n                     * @since 7.1.0\n                     */\n                    wrapAround: true,\n                    /**\n                     * Options for the keyboard navigation of data points and series.\n                     *\n                     * @declare Highcharts.KeyboardNavigationSeriesNavigationOptionsObject\n                     * @since 8.0.0\n                     */\n                    seriesNavigation: {\n                        /**\n                         * Set the keyboard navigation mode for the chart. Can be\n                         * \"normal\" or \"serialize\". In normal mode, left/right arrow\n                         * keys move between points in a series, while up/down arrow\n                         * keys move between series. Up/down navigation acts\n                         * intelligently to figure out which series makes sense to move\n                         * to from any given point.\n                         *\n                         * In \"serialize\" mode, points are instead navigated as a single\n                         * list. Left/right behaves as in \"normal\" mode. Up/down arrow\n                         * keys will behave like left/right. This can be useful for\n                         * unifying navigation behavior with/without screen readers\n                         * enabled.\n                         *\n                         * @type       {string}\n                         * @default    normal\n                         * @since 8.0.0\n                         * @validvalue [\"normal\", \"serialize\"]\n                         * @apioption  accessibility.keyboardNavigation.seriesNavigation.mode\n                         */\n                        /**\n                         * Skip null points when navigating through points with the\n                         * keyboard.\n                         *\n                         * @since 8.0.0\n                         */\n                        skipNullPoints: true,\n                        /**\n                         * When a series contains more points than this, we no longer\n                         * allow keyboard navigation for it.\n                         *\n                         * Set to `false` to disable.\n                         *\n                         * @type  {boolean|number}\n                         * @since 8.0.0\n                         */\n                        pointNavigationEnabledThreshold: false,\n                        /**\n                         * Remember which point was focused even after navigating away\n                         * from the series, so that when navigating back to the series\n                         * you start at the last focused point.\n                         *\n                         * @type  {boolean}\n                         * @since 10.1.0\n                         */\n                        rememberPointFocus: false\n                    }\n                },\n                /**\n                 * Options for announcing new data to screen reader users. Useful\n                 * for dynamic data applications and drilldown.\n                 *\n                 * Keep in mind that frequent announcements will not be useful to\n                 * users, as they won't have time to explore the new data. For these\n                 * applications, consider making snapshots of the data accessible, and\n                 * do the announcements in batches.\n                 *\n                 * @declare Highcharts.AccessibilityAnnounceNewDataOptionsObject\n                 * @since   7.1.0\n                 */\n                announceNewData: {\n                    /**\n                     * Optional formatter callback for the announcement. Receives\n                     * up to three arguments. The first argument is always an array\n                     * of all series that received updates. If an announcement is\n                     * already queued, the series that received updates for that\n                     * announcement are also included in this array. The second\n                     * argument is provided if `chart.addSeries` was called, and\n                     * there is a new series. In that case, this argument is a\n                     * reference to the new series. The third argument, similarly,\n                     * is provided if `series.addPoint` was called, and there is a\n                     * new point. In that case, this argument is a reference to the\n                     * new point.\n                     *\n                     * The function should return a string with the text to announce\n                     * to the user. Return empty string to not announce anything.\n                     * Return `false` to use the default announcement format.\n                     *\n                     * @sample highcharts/accessibility/custom-dynamic\n                     *         High priority live alerts\n                     *\n                     * @type      {Highcharts.AccessibilityAnnouncementFormatter}\n                     * @apioption accessibility.announceNewData.announcementFormatter\n                     */\n                    /**\n                     * Enable announcing new data to screen reader users\n                     * @sample highcharts/accessibility/accessible-dynamic\n                     *         Dynamic data accessible\n                     */\n                    enabled: false,\n                    /**\n                     * Minimum interval between announcements in milliseconds. If\n                     * new data arrives before this amount of time has passed, it is\n                     * queued for announcement. If another new data event happens\n                     * while an announcement is queued, the queued announcement is\n                     * dropped, and the latest announcement is queued instead. Set\n                     * to 0 to allow all announcements, but be warned that frequent\n                     * announcements are disturbing to users.\n                     */\n                    minAnnounceInterval: 5000,\n                    /**\n                     * Choose whether or not the announcements should interrupt the\n                     * screen reader. If not enabled, the user will be notified once\n                     * idle. It is recommended not to enable this setting unless\n                     * there is a specific reason to do so.\n                     */\n                    interruptUser: false\n                }\n            },\n            /**\n             * Accessibility options for a data point.\n             *\n             * @declare   Highcharts.PointAccessibilityOptionsObject\n             * @since     7.1.0\n             * @apioption series.line.data.accessibility\n             */\n            /**\n             * Provide a description of the data point, announced to screen readers.\n             *\n             * @type      {string}\n             * @since     7.1.0\n             * @apioption series.line.data.accessibility.description\n             */\n            /**\n             * Set to false to disable accessibility functionality for a specific point.\n             * The point will not be included in keyboard navigation, and will not be\n             * exposed to assistive technology.\n             *\n             * @type      {boolean}\n             * @since 9.0.1\n             * @apioption series.line.data.accessibility.enabled\n             */\n            /**\n             * Accessibility options for a series.\n             *\n             * @declare    Highcharts.SeriesAccessibilityOptionsObject\n             * @since      7.1.0\n             * @requires   modules/accessibility\n             * @apioption  plotOptions.series.accessibility\n             */\n            /**\n             * Enable/disable accessibility functionality for a specific series.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.enabled\n             */\n            /**\n             * Provide a description of the series, announced to screen readers.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.description\n             */\n            /**\n             * Format to use for describing the data series group to assistive\n             * technology - including screen readers.\n             *\n             * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)\n             * @type       {string}\n             * @since 11.0.0\n             * @apioption  plotOptions.series.accessibility.descriptionFormat\n             */\n            /**\n             * Expose only the series element to screen readers, not its points.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.exposeAsGroupOnly\n             */\n            /**\n             * Point accessibility options for a series.\n             *\n             * @extends    accessibility.point\n             * @since 9.3.0\n             * @requires   modules/accessibility\n             * @apioption  plotOptions.series.accessibility.point\n             */\n            /**\n             * Formatter function to use instead of the default for point\n             * descriptions. Same as `accessibility.point.descriptionFormatter`, but\n             * applies to a series instead of the whole chart.\n             *\n             * Note: Prefer using [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)\n             * instead if possible, as default functionality such as describing\n             * annotations will be preserved.\n             *\n             * @see [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)\n             * @see [point.accessibility.description](#series.line.data.accessibility.description)\n             * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n             *\n             * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n             * @since 9.3.0\n             * @apioption plotOptions.series.accessibility.point.descriptionFormatter\n             */\n            /**\n             * Keyboard navigation for a series\n             *\n             * @declare    Highcharts.SeriesAccessibilityKeyboardNavigationOptionsObject\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.keyboardNavigation\n             */\n            /**\n             * Enable/disable keyboard navigation support for a specific series.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.keyboardNavigation.enabled\n             */\n            /**\n             * Accessibility options for an annotation label.\n             *\n             * @declare    Highcharts.AnnotationLabelAccessibilityOptionsObject\n             * @since 8.0.1\n             * @requires   modules/accessibility\n             * @apioption  annotations.labelOptions.accessibility\n             */\n            /**\n             * Description of an annotation label for screen readers and other assistive\n             * technology.\n             *\n             * @type       {string}\n             * @since 8.0.1\n             * @apioption  annotations.labelOptions.accessibility.description\n             */\n            /**\n             * Accessibility options for an axis. Requires the accessibility module.\n             *\n             * @declare    Highcharts.AxisAccessibilityOptionsObject\n             * @since      7.1.0\n             * @requires   modules/accessibility\n             * @apioption  xAxis.accessibility\n             */\n            /**\n             * Enable axis accessibility features, including axis information in the\n             * screen reader information region. If this is disabled on the xAxis, the\n             * x values are not exposed to screen readers for the individual data points\n             * by default.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.enabled\n             */\n            /**\n             * Description for an axis to expose to screen reader users.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.description\n             */\n            /**\n             * Range description for an axis. Overrides the default range description.\n             * Set to empty to disable range description for this axis.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.rangeDescription\n             */\n            /**\n             * @optionparent legend\n             */\n            legend: {\n                /**\n                 * Accessibility options for the legend. Requires the Accessibility\n                 * module.\n                 *\n                 * @since     7.1.0\n                 * @requires  modules/accessibility\n                 */\n                accessibility: {\n                    /**\n                     * Enable accessibility support for the legend.\n                     *\n                     * @since  7.1.0\n                     */\n                    enabled: true,\n                    /**\n                     * Options for keyboard navigation for the legend.\n                     *\n                     * @since     7.1.0\n                     * @requires  modules/accessibility\n                     */\n                    keyboardNavigation: {\n                        /**\n                         * Enable keyboard navigation for the legend.\n                         *\n                         * @see [accessibility.keyboardNavigation](#accessibility.keyboardNavigation.enabled)\n                         *\n                         * @since  7.1.0\n                         */\n                        enabled: true\n                    }\n                }\n            },\n            /**\n             * @optionparent exporting\n             */\n            exporting: {\n                /**\n                 * Accessibility options for the exporting menu. Requires the\n                 * Accessibility module.\n                 *\n                 * @since    7.1.0\n                 * @requires modules/accessibility\n                 */\n                accessibility: {\n                    /**\n                     * Enable accessibility support for the export menu.\n                     *\n                     * @since 7.1.0\n                     */\n                    enabled: true\n                }\n            }\n        };\n\n        return Options;\n    });\n    _registerModule(_modules, 'Accessibility/Options/LangDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Default lang/i18n options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        const langOptions = {\n            /**\n             * Configure the accessibility strings in the chart. Requires the\n             * [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n             * to be loaded. For a description of the module and information on its\n             * features, see\n             * [Highcharts Accessibility](https://www.highcharts.com/docs/chart-concepts/accessibility).\n             *\n             * The lang options use [Format Strings](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#format-strings)\n             * with variables that are replaced at run time. These variables should be\n             * used when available, to avoid duplicating text that is defined elsewhere.\n             *\n             * For more dynamic control over the accessibility functionality, see\n             * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter),\n             * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),\n             * and\n             * [accessibility.screenReaderSection.beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).\n             *\n             * @since        6.0.6\n             * @optionparent lang.accessibility\n             */\n            accessibility: {\n                /**\n                 * @deprecated 10.2.1\n                 * @type       {string}\n                 * @apioption  lang.accessibility.resetZoomButton\n                 */\n                /**\n                 * Default title of the chart for assistive technology, for charts\n                 * without a chart title.\n                 */\n                defaultChartTitle: 'Chart',\n                /**\n                 * Accessible label for the chart container HTML element.\n                 * `{title}` refers to the chart title.\n                 */\n                chartContainerLabel: '{title}. Highcharts interactive chart.',\n                /**\n                 * Accessible label for the chart SVG element.\n                 * `{chartTitle}` refers to the chart title.\n                 */\n                svgContainerLabel: 'Interactive chart',\n                /**\n                 * Accessible label for the drill-up button.\n                 * `{buttonText}` refers to the visual text on the button.\n                 */\n                drillUpButton: '{buttonText}',\n                /**\n                 * Accessible label for the chart credits.\n                 * `{creditsStr}` refers to the visual text in the credits.\n                 */\n                credits: 'Chart credits: {creditsStr}',\n                /**\n                 * Thousands separator to use when formatting numbers for screen\n                 * readers. Note that many screen readers will not handle space as a\n                 * thousands separator, and will consider \"11 700\" as two numbers.\n                 *\n                 * Set to `null` to use the separator defined in\n                 * [lang.thousandsSep](lang.thousandsSep).\n                 *\n                 * @since 7.1.0\n                 */\n                thousandsSep: ',',\n                /**\n                 * Title element text for the chart SVG element. Leave this\n                 * empty to disable adding the title element. Browsers will display\n                 * this content when hovering over elements in the chart. Assistive\n                 * technology may use this element to label the chart.\n                 *\n                 * @since 6.0.8\n                 */\n                svgContainerTitle: '',\n                /**\n                 * Set a label on the container wrapping the SVG.\n                 *\n                 * @see [chartContainerLabel](#lang.accessibility.chartContainerLabel)\n                 *\n                 * @since 8.0.0\n                 */\n                graphicContainerLabel: '',\n                /**\n                 * Language options for the screen reader information sections added\n                 * before and after the charts.\n                 *\n                 * @since 8.0.0\n                 */\n                screenReaderSection: {\n                    beforeRegionLabel: '',\n                    afterRegionLabel: '',\n                    /**\n                     * Language options for annotation descriptions.\n                     *\n                     * @since 8.0.1\n                     */\n                    annotations: {\n                        heading: 'Chart annotations summary',\n                        descriptionSinglePoint: ('{annotationText}. Related to {annotationPoint}'),\n                        descriptionMultiplePoints: ('{annotationText}. Related to {annotationPoint}' +\n                            '{ Also related to, #each(additionalAnnotationPoints)}'),\n                        descriptionNoPoints: '{annotationText}'\n                    },\n                    /**\n                     * Label for the end of the chart. Announced by screen readers.\n                     *\n                     * @since 8.0.0\n                     */\n                    endOfChartMarker: 'End of interactive chart.'\n                },\n                /**\n                 * Language options for sonification.\n                 *\n                 * @since 8.0.1\n                 */\n                sonification: {\n                    playAsSoundButtonText: 'Play as sound, {chartTitle}',\n                    playAsSoundClickAnnouncement: 'Play'\n                },\n                /**\n                 * Language options for accessibility of the legend.\n                 *\n                 * @since 8.0.0\n                 */\n                legend: {\n                    /**\n                     * Accessible label for the legend, for charts where there is no\n                     * legend title defined.\n                     */\n                    legendLabelNoTitle: 'Toggle series visibility, {chartTitle}',\n                    /**\n                     * Accessible label for the legend, for charts where there is a\n                     * legend title defined. `{legendTitle}` refers to the visual text\n                     * in the legend title.\n                     */\n                    legendLabel: 'Chart legend: {legendTitle}',\n                    /**\n                     * Accessible label for individual legend items. `{itemName}` refers\n                     * to the visual text in the legend for that item.\n                     */\n                    legendItem: 'Show {itemName}'\n                },\n                /**\n                 * Chart and map zoom accessibility language options.\n                 *\n                 * @since 8.0.0\n                 */\n                zoom: {\n                    mapZoomIn: 'Zoom chart',\n                    mapZoomOut: 'Zoom out chart',\n                    resetZoomButton: 'Reset zoom'\n                },\n                /**\n                 * Range selector language options for accessibility.\n                 *\n                 * @since 8.0.0\n                 */\n                rangeSelector: {\n                    dropdownLabel: '{rangeTitle}',\n                    minInputLabel: 'Select start date.',\n                    maxInputLabel: 'Select end date.',\n                    clickButtonAnnouncement: 'Viewing {axisRangeDescription}'\n                },\n                /**\n                 * Accessibility language options for the data table.\n                 *\n                 * @since 8.0.0\n                 */\n                table: {\n                    viewAsDataTableButtonText: 'View as data table, {chartTitle}',\n                    tableSummary: 'Table representation of chart.'\n                },\n                /**\n                 * Default announcement for new data in charts. If addPoint or\n                 * addSeries is used, and only one series/point is added, the\n                 * `newPointAnnounce` and `newSeriesAnnounce` strings are used.\n                 * The `...Single` versions will be used if there is only one chart\n                 * on the page, and the `...Multiple` versions will be used if there\n                 * are multiple charts on the page. For all other new data events,\n                 * the `newDataAnnounce` string will be used.\n                 *\n                 * @since 7.1.0\n                 */\n                announceNewData: {\n                    newDataAnnounce: 'Updated data for chart {chartTitle}',\n                    newSeriesAnnounceSingle: 'New data series: {seriesDesc}',\n                    newPointAnnounceSingle: 'New data point: {pointDesc}',\n                    newSeriesAnnounceMultiple: 'New data series in chart {chartTitle}: {seriesDesc}',\n                    newPointAnnounceMultiple: 'New data point in chart {chartTitle}: {pointDesc}'\n                },\n                /**\n                 * Descriptions of lesser known series types. The relevant\n                 * description is added to the screen reader information region\n                 * when these series types are used.\n                 *\n                 * @since 6.0.6\n                 */\n                seriesTypeDescriptions: {\n                    boxplot: 'Box plot charts are typically used to display ' +\n                        'groups of statistical data. Each data point in the ' +\n                        'chart can have up to 5 values: minimum, lower quartile, ' +\n                        'median, upper quartile, and maximum.',\n                    arearange: 'Arearange charts are line charts displaying a ' +\n                        'range between a lower and higher value for each point.',\n                    areasplinerange: 'These charts are line charts displaying a ' +\n                        'range between a lower and higher value for each point.',\n                    bubble: 'Bubble charts are scatter charts where each data ' +\n                        'point also has a size value.',\n                    columnrange: 'Columnrange charts are column charts ' +\n                        'displaying a range between a lower and higher value for ' +\n                        'each point.',\n                    errorbar: 'Errorbar series are used to display the ' +\n                        'variability of the data.',\n                    funnel: 'Funnel charts are used to display reduction of data ' +\n                        'in stages.',\n                    pyramid: 'Pyramid charts consist of a single pyramid with ' +\n                        'item heights corresponding to each point value.',\n                    waterfall: 'A waterfall chart is a column chart where each ' +\n                        'column contributes towards a total end value.'\n                },\n                /**\n                 * Chart type description strings. This is added to the chart\n                 * information region.\n                 *\n                 * If there is only a single series type used in the chart, we use\n                 * the format string for the series type, or default if missing.\n                 * There is one format string for cases where there is only a single\n                 * series in the chart, and one for multiple series of the same\n                 * type.\n                 *\n                 * @since 6.0.6\n                 */\n                chartTypes: {\n                    /* eslint-disable max-len */\n                    emptyChart: 'Empty chart',\n                    mapTypeDescription: 'Map of {mapTitle} with {numSeries} data series.',\n                    unknownMap: 'Map of unspecified region with {numSeries} data series.',\n                    combinationChart: 'Combination chart with {numSeries} data series.',\n                    defaultSingle: 'Chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                    defaultMultiple: 'Chart with {numSeries} data series.',\n                    splineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                    splineMultiple: 'Line chart with {numSeries} lines.',\n                    lineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                    lineMultiple: 'Line chart with {numSeries} lines.',\n                    columnSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    columnMultiple: 'Bar chart with {numSeries} data series.',\n                    barSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    barMultiple: 'Bar chart with {numSeries} data series.',\n                    pieSingle: 'Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.',\n                    pieMultiple: 'Pie chart with {numSeries} pies.',\n                    scatterSingle: 'Scatter chart with {numPoints} {#plural(numPoints, points, point)}.',\n                    scatterMultiple: 'Scatter chart with {numSeries} data series.',\n                    boxplotSingle: 'Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.',\n                    boxplotMultiple: 'Boxplot with {numSeries} data series.',\n                    bubbleSingle: 'Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.',\n                    bubbleMultiple: 'Bubble chart with {numSeries} data series.'\n                },\n                /**\n                 * Axis description format strings.\n                 *\n                 * @since 6.0.6\n                 */\n                axis: {\n                    /* eslint-disable max-len */\n                    xAxisDescriptionSingular: 'The chart has 1 X axis displaying {names[0]}. {ranges[0]}',\n                    xAxisDescriptionPlural: 'The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}.',\n                    yAxisDescriptionSingular: 'The chart has 1 Y axis displaying {names[0]}. {ranges[0]}',\n                    yAxisDescriptionPlural: 'The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}.',\n                    timeRangeDays: 'Data range: {range} days.',\n                    timeRangeHours: 'Data range: {range} hours.',\n                    timeRangeMinutes: 'Data range: {range} minutes.',\n                    timeRangeSeconds: 'Data range: {range} seconds.',\n                    rangeFromTo: 'Data ranges from {rangeFrom} to {rangeTo}.',\n                    rangeCategories: 'Data range: {numCategories} categories.'\n                },\n                /**\n                 * Exporting menu format strings for accessibility module.\n                 *\n                 * @since 6.0.6\n                 */\n                exporting: {\n                    chartMenuLabel: 'Chart menu',\n                    menuButtonLabel: 'View chart menu, {chartTitle}'\n                },\n                /**\n                 * Lang configuration for different series types. For more dynamic\n                 * control over the series element descriptions, see\n                 * [accessibility.seriesDescriptionFormatter](#accessibility.seriesDescriptionFormatter).\n                 *\n                 * @since 6.0.6\n                 */\n                series: {\n                    /**\n                     * Lang configuration for the series main summary. Each series\n                     * type has two modes:\n                     *\n                     * 1. This series type is the only series type used in the\n                     *    chart\n                     *\n                     * 2. This is a combination chart with multiple series types\n                     *\n                     * If a definition does not exist for the specific series type\n                     * and mode, the 'default' lang definitions are used.\n                     *\n                     * Chart and its subproperties can be accessed with the `{chart}` variable.\n                     * The series and its subproperties can be accessed with the `{series}` variable.\n                     *\n                     * The series index (starting from 1) can be accessed with the `{seriesNumber}` variable.\n                     *\n                     * @since 6.0.6\n                     */\n                    summary: {\n                        /* eslint-disable max-len */\n                        'default': '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        defaultCombination: '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        line: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        lineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        spline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        splineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        column: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bars, bar)}.',\n                        columnCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#plural(series.points.length, bars, bar)}.',\n                        bar: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bars, bar)}.',\n                        barCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#plural(series.points.length, bars, bar)}.',\n                        pie: '{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, slices, slice)}.',\n                        pieCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#plural(series.points.length, slices, slice)}.',\n                        scatter: '{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, points, point)}.',\n                        scatterCombination: '{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#plural(series.points.length, points, point)}.',\n                        boxplot: '{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, boxes, box)}.',\n                        boxplotCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#plural(series.points.length, boxes, box)}.',\n                        bubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.',\n                        bubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.',\n                        map: '{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, areas, area)}.',\n                        mapCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#plural(series.points.length, areas, area)}.',\n                        mapline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        maplineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.',\n                        mapbubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.',\n                        mapbubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.'\n                    },\n                    /**\n                     * User supplied description text. This is added in the point\n                     * comment description by default if present.\n                     *\n                     * `{description}` refers to the value given in\n                     * [point.accessibility.description](#series.line.data.accessibility.description).\n                     *\n                     * @since 6.0.6\n                     */\n                    description: '{description}',\n                    /**\n                     * xAxis description for series if there are multiple xAxes in\n                     * the chart.\n                     *\n                     * @since 6.0.6\n                     */\n                    xAxisDescription: 'X axis, {name}',\n                    /**\n                     * yAxis description for series if there are multiple yAxes in\n                     * the chart.\n                     *\n                     * @since 6.0.6\n                     */\n                    yAxisDescription: 'Y axis, {name}',\n                    /**\n                     * Description for the value of null points.\n                     *\n                     * @since 8.0.0\n                     */\n                    nullPointValue: 'No value',\n                    /**\n                     * Description for annotations on a point, as it is made available\n                     * to assistive technology.\n                     *\n                     * @since 8.0.1\n                     */\n                    pointAnnotationsDescription: '{Annotation: #each(annotations). }'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return langOptions;\n    });\n    _registerModule(_modules, 'Accessibility/Options/DeprecatedOptions.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Default options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* eslint-disable max-len */\n        /*\n         *  List of deprecated options:\n         *\n         *  chart.description -> accessibility.description\n         *  chart.typeDescription -> accessibility.typeDescription\n         *  series.description -> series.accessibility.description\n         *  series.exposeElementToA11y -> series.accessibility.exposeAsGroupOnly\n         *  series.pointDescriptionFormatter ->\n         *      series.accessibility.pointDescriptionFormatter\n         *  series.accessibility.pointDescriptionFormatter ->\n         *      series.accessibility.point.descriptionFormatter\n         *  series.skipKeyboardNavigation ->\n         *      series.accessibility.keyboardNavigation.enabled\n         *  point.description -> point.accessibility.description !!!! WARNING: No longer deprecated and handled, removed for HC8.\n         *  axis.description -> axis.accessibility.description\n         *\n         *  accessibility.pointDateFormat -> accessibility.point.dateFormat\n         *  accessibility.addTableShortcut -> Handled by screenReaderSection.beforeChartFormat\n         *  accessibility.pointDateFormatter -> accessibility.point.dateFormatter\n         *  accessibility.pointDescriptionFormatter -> accessibility.point.descriptionFormatter\n         *  accessibility.pointDescriptionThreshold -> accessibility.series.pointDescriptionEnabledThreshold\n         *  accessibility.pointNavigationThreshold -> accessibility.keyboardNavigation.seriesNavigation.pointNavigationEnabledThreshold\n         *  accessibility.pointValueDecimals -> accessibility.point.valueDecimals\n         *  accessibility.pointValuePrefix -> accessibility.point.valuePrefix\n         *  accessibility.pointValueSuffix -> accessibility.point.valueSuffix\n         *  accessibility.screenReaderSectionFormatter -> accessibility.screenReaderSection.beforeChartFormatter\n         *  accessibility.describeSingleSeries -> accessibility.series.describeSingleSeries\n         *  accessibility.seriesDescriptionFormatter -> accessibility.series.descriptionFormatter\n         *  accessibility.onTableAnchorClick -> accessibility.screenReaderSection.onViewDataTableClick\n         *  accessibility.axisRangeDateFormat -> accessibility.screenReaderSection.axisRangeDateFormat\n         *  accessibility.keyboardNavigation.skipNullPoints -> accessibility.keyboardNavigation.seriesNavigation.skipNullPoints\n         *  accessibility.keyboardNavigation.mode -> accessibility.keyboardNavigation.seriesNavigation.mode\n         *\n         *  lang.accessibility.chartHeading -> no longer used, remove\n         *  lang.accessibility.legendItem -> lang.accessibility.legend.legendItem\n         *  lang.accessibility.legendLabel -> lang.accessibility.legend.legendLabel\n         *  lang.accessibility.mapZoomIn -> lang.accessibility.zoom.mapZoomIn\n         *  lang.accessibility.mapZoomOut -> lang.accessibility.zoom.mapZoomOut\n         *  lang.accessibility.resetZoomButton -> lang.accessibility.zoom.resetZoomButton\n         *  lang.accessibility.screenReaderRegionLabel -> lang.accessibility.screenReaderSection.beforeRegionLabel\n         *  lang.accessibility.rangeSelectorButton -> lang.accessibility.rangeSelector.buttonText\n         *  lang.accessibility.rangeSelectorMaxInput -> lang.accessibility.rangeSelector.maxInputLabel\n         *  lang.accessibility.rangeSelectorMinInput -> lang.accessibility.rangeSelector.minInputLabel\n         *  lang.accessibility.svgContainerEnd -> lang.accessibility.screenReaderSection.endOfChartMarker\n         *  lang.accessibility.viewAsDataTable -> lang.accessibility.table.viewAsDataTableButtonText\n         *  lang.accessibility.tableSummary -> lang.accessibility.table.tableSummary\n         *\n         */\n        /* eslint-enable max-len */\n        const { error, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Set a new option on a root prop, where the option is defined as an array of\n         * suboptions.\n         * @private\n         * @param root\n         * @param {Array<string>} optionAsArray\n         * @param {*} val\n         * @return {void}\n         */\n        function traverseSetOption(root, optionAsArray, val) {\n            let opt = root, prop, i = 0;\n            for (; i < optionAsArray.length - 1; ++i) {\n                prop = optionAsArray[i];\n                opt = opt[prop] = pick(opt[prop], {});\n            }\n            opt[optionAsArray[optionAsArray.length - 1]] = val;\n        }\n        /**\n         * If we have a clear root option node for old and new options and a mapping\n         * between, we can use this generic function for the copy and warn logic.\n         */\n        function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {\n            /**\n             * @private\n             */\n            function getChildProp(root, propAsArray) {\n                return propAsArray.reduce(function (acc, cur) {\n                    return acc[cur];\n                }, root);\n            }\n            const rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);\n            Object.keys(mapToNewOptions).forEach(function (oldOptionKey) {\n                const val = rootOld[oldOptionKey];\n                if (typeof val !== 'undefined') {\n                    traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);\n                    error(32, false, chart, {\n                        [rootOldAsArray.join('.') + '.' + oldOptionKey]: (rootNewAsArray.join('.') + '.' +\n                            mapToNewOptions[oldOptionKey].join('.'))\n                    });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedChartOptions(chart) {\n            const chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};\n            ['description', 'typeDescription'].forEach(function (prop) {\n                if (chartOptions[prop]) {\n                    a11yOptions[prop] = chartOptions[prop];\n                    error(32, false, chart, { [`chart.${prop}`]: `use accessibility.${prop}` });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedAxisOptions(chart) {\n            chart.axes.forEach(function (axis) {\n                const opts = axis.options;\n                if (opts && opts.description) {\n                    opts.accessibility = opts.accessibility || {};\n                    opts.accessibility.description = opts.description;\n                    error(32, false, chart, {\n                        'axis.description': 'use axis.accessibility.description'\n                    });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedSeriesOptions(chart) {\n            // Map of deprecated series options. New options are defined as\n            // arrays of paths under series.options.\n            const oldToNewSeriesOptions = {\n                description: ['accessibility', 'description'],\n                exposeElementToA11y: ['accessibility', 'exposeAsGroupOnly'],\n                pointDescriptionFormatter: [\n                    'accessibility', 'point', 'descriptionFormatter'\n                ],\n                skipKeyboardNavigation: [\n                    'accessibility', 'keyboardNavigation', 'enabled'\n                ],\n                'accessibility.pointDescriptionFormatter': [\n                    'accessibility', 'point', 'descriptionFormatter'\n                ]\n            };\n            chart.series.forEach(function (series) {\n                // Handle series wide options\n                Object.keys(oldToNewSeriesOptions).forEach(function (oldOption) {\n                    let optionVal = series.options[oldOption];\n                    // Special case\n                    if (oldOption === 'accessibility.pointDescriptionFormatter') {\n                        optionVal = (series.options.accessibility &&\n                            series.options.accessibility\n                                .pointDescriptionFormatter);\n                    }\n                    if (typeof optionVal !== 'undefined') {\n                        // Set the new option\n                        traverseSetOption(series.options, oldToNewSeriesOptions[oldOption], \n                        // Note that skipKeyboardNavigation has inverted option\n                        // value, since we set enabled rather than disabled\n                        oldOption === 'skipKeyboardNavigation' ?\n                            !optionVal : optionVal);\n                        error(32, false, chart, {\n                            [`series.${oldOption}`]: ('series.' +\n                                oldToNewSeriesOptions[oldOption].join('.'))\n                        });\n                    }\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedTopLevelAccessibilityOptions(chart) {\n            deprecateFromOptionsMap(chart, ['accessibility'], ['accessibility'], {\n                pointDateFormat: ['point', 'dateFormat'],\n                pointDateFormatter: ['point', 'dateFormatter'],\n                pointDescriptionFormatter: ['point', 'descriptionFormatter'],\n                pointDescriptionThreshold: ['series',\n                    'pointDescriptionEnabledThreshold'],\n                pointNavigationThreshold: ['keyboardNavigation', 'seriesNavigation',\n                    'pointNavigationEnabledThreshold'],\n                pointValueDecimals: ['point', 'valueDecimals'],\n                pointValuePrefix: ['point', 'valuePrefix'],\n                pointValueSuffix: ['point', 'valueSuffix'],\n                screenReaderSectionFormatter: ['screenReaderSection',\n                    'beforeChartFormatter'],\n                describeSingleSeries: ['series', 'describeSingleSeries'],\n                seriesDescriptionFormatter: ['series', 'descriptionFormatter'],\n                onTableAnchorClick: ['screenReaderSection', 'onViewDataTableClick'],\n                axisRangeDateFormat: ['screenReaderSection', 'axisRangeDateFormat']\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedKeyboardNavigationOptions(chart) {\n            deprecateFromOptionsMap(chart, ['accessibility', 'keyboardNavigation'], ['accessibility', 'keyboardNavigation', 'seriesNavigation'], {\n                skipNullPoints: ['skipNullPoints'],\n                mode: ['mode']\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedLangOptions(chart) {\n            deprecateFromOptionsMap(chart, ['lang', 'accessibility'], ['lang', 'accessibility'], {\n                legendItem: ['legend', 'legendItem'],\n                legendLabel: ['legend', 'legendLabel'],\n                mapZoomIn: ['zoom', 'mapZoomIn'],\n                mapZoomOut: ['zoom', 'mapZoomOut'],\n                resetZoomButton: ['zoom', 'resetZoomButton'],\n                screenReaderRegionLabel: ['screenReaderSection',\n                    'beforeRegionLabel'],\n                rangeSelectorButton: ['rangeSelector', 'buttonText'],\n                rangeSelectorMaxInput: ['rangeSelector', 'maxInputLabel'],\n                rangeSelectorMinInput: ['rangeSelector', 'minInputLabel'],\n                svgContainerEnd: ['screenReaderSection', 'endOfChartMarker'],\n                viewAsDataTable: ['table', 'viewAsDataTableButtonText'],\n                tableSummary: ['table', 'tableSummary']\n            });\n        }\n        /**\n         * Copy options that are deprecated over to new options. Logs warnings to\n         * console if deprecated options are used.\n         *\n         * @private\n         */\n        function copyDeprecatedOptions(chart) {\n            copyDeprecatedChartOptions(chart);\n            copyDeprecatedAxisOptions(chart);\n            if (chart.series) {\n                copyDeprecatedSeriesOptions(chart);\n            }\n            copyDeprecatedTopLevelAccessibilityOptions(chart);\n            copyDeprecatedKeyboardNavigationOptions(chart);\n            copyDeprecatedLangOptions(chart);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return copyDeprecatedOptions;\n    });\n    _registerModule(_modules, 'Accessibility/Accessibility.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/A11yI18n.js'], _modules['Accessibility/Components/ContainerComponent.js'], _modules['Accessibility/FocusBorder.js'], _modules['Accessibility/Components/InfoRegionsComponent.js'], _modules['Accessibility/KeyboardNavigation.js'], _modules['Accessibility/Components/LegendComponent.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/ProxyProvider.js'], _modules['Accessibility/Components/RangeSelectorComponent.js'], _modules['Accessibility/Components/SeriesComponent/SeriesComponent.js'], _modules['Accessibility/Components/ZoomComponent.js'], _modules['Accessibility/HighContrastMode.js'], _modules['Accessibility/HighContrastTheme.js'], _modules['Accessibility/Options/A11yDefaults.js'], _modules['Accessibility/Options/LangDefaults.js'], _modules['Accessibility/Options/DeprecatedOptions.js']], function (D, H, U, HU, A11yI18n, ContainerComponent, FocusBorder, InfoRegionsComponent, KeyboardNavigation, LegendComponent, MenuComponent, NewDataAnnouncer, ProxyProvider, RangeSelectorComponent, SeriesComponent, ZoomComponent, whcm, highContrastTheme, defaultOptionsA11Y, defaultLangOptions, copyDeprecatedOptions) {\n        /* *\n         *\n         *  (c) 2009-2021 ystein Moseng\n         *\n         *  Accessibility module for Highcharts\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { doc } = H;\n        const { addEvent, extend, fireEvent, merge } = U;\n        const { removeElement } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Accessibility class\n         *\n         * @private\n         * @requires module:modules/accessibility\n         *\n         * @class\n         * @name Highcharts.Accessibility\n         *\n         * @param {Highcharts.Chart} chart\n         * Chart object\n         */\n        class Accessibility {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.components = void 0;\n                this.keyboardNavigation = void 0;\n                this.proxyProvider = void 0;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the accessibility class\n             * @private\n             * @param {Highcharts.Chart} chart\n             *        Chart object\n             */\n            init(chart) {\n                this.chart = chart;\n                // Abort on old browsers\n                if (!doc.addEventListener) {\n                    this.zombie = true;\n                    this.components = {};\n                    chart.renderTo.setAttribute('aria-hidden', true);\n                    return;\n                }\n                // Copy over any deprecated options that are used. We could do this on\n                // every update, but it is probably not needed.\n                copyDeprecatedOptions(chart);\n                this.proxyProvider = new ProxyProvider(this.chart);\n                this.initComponents();\n                this.keyboardNavigation = new KeyboardNavigation(chart, this.components);\n            }\n            /**\n             * @private\n             */\n            initComponents() {\n                const chart = this.chart;\n                const proxyProvider = this.proxyProvider;\n                const a11yOptions = chart.options.accessibility;\n                this.components = {\n                    container: new ContainerComponent(),\n                    infoRegions: new InfoRegionsComponent(),\n                    legend: new LegendComponent(),\n                    chartMenu: new MenuComponent(),\n                    rangeSelector: new RangeSelectorComponent(),\n                    series: new SeriesComponent(),\n                    zoom: new ZoomComponent()\n                };\n                if (a11yOptions.customComponents) {\n                    extend(this.components, a11yOptions.customComponents);\n                }\n                const components = this.components;\n                this.getComponentOrder().forEach(function (componentName) {\n                    components[componentName].initBase(chart, proxyProvider);\n                    components[componentName].init();\n                });\n            }\n            /**\n             * Get order to update components in.\n             * @private\n             */\n            getComponentOrder() {\n                if (!this.components) {\n                    return []; // For zombie accessibility object on old browsers\n                }\n                if (!this.components.series) {\n                    return Object.keys(this.components);\n                }\n                const componentsExceptSeries = Object.keys(this.components)\n                    .filter((c) => c !== 'series');\n                // Update series first, so that other components can read accessibility\n                // info on points.\n                return ['series'].concat(componentsExceptSeries);\n            }\n            /**\n             * Update all components.\n             */\n            update() {\n                const components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;\n                fireEvent(chart, 'beforeA11yUpdate');\n                // Update the chart type list as this is used by multiple modules\n                chart.types = this.getChartTypes();\n                // Update proxies. We don't update proxy positions since most likely we\n                // need to recreate the proxies on update.\n                const kbdNavOrder = a11yOptions.keyboardNavigation.order;\n                this.proxyProvider.updateGroupOrder(kbdNavOrder);\n                // Update markup\n                this.getComponentOrder().forEach(function (componentName) {\n                    components[componentName].onChartUpdate();\n                    fireEvent(chart, 'afterA11yComponentUpdate', {\n                        name: componentName,\n                        component: components[componentName]\n                    });\n                });\n                // Update keyboard navigation\n                this.keyboardNavigation.update(kbdNavOrder);\n                // Handle high contrast mode\n                if (!chart.highContrastModeActive && // Only do this once\n                    whcm.isHighContrastModeActive()) {\n                    whcm.setHighContrastTheme(chart);\n                }\n                fireEvent(chart, 'afterA11yUpdate', {\n                    accessibility: this\n                });\n            }\n            /**\n             * Destroy all elements.\n             */\n            destroy() {\n                const chart = this.chart || {};\n                // Destroy components\n                const components = this.components;\n                Object.keys(components).forEach(function (componentName) {\n                    components[componentName].destroy();\n                    components[componentName].destroyBase();\n                });\n                // Destroy proxy provider\n                if (this.proxyProvider) {\n                    this.proxyProvider.destroy();\n                }\n                // Remove announcer container\n                if (chart.announcerContainer) {\n                    removeElement(chart.announcerContainer);\n                }\n                // Kill keyboard nav\n                if (this.keyboardNavigation) {\n                    this.keyboardNavigation.destroy();\n                }\n                // Hide container from screen readers if it exists\n                if (chart.renderTo) {\n                    chart.renderTo.setAttribute('aria-hidden', true);\n                }\n                // Remove focus border if it exists\n                if (chart.focusElement) {\n                    chart.focusElement.removeFocusBorder();\n                }\n            }\n            /**\n             * Return a list of the types of series we have in the chart.\n             * @private\n             */\n            getChartTypes() {\n                const types = {};\n                this.chart.series.forEach(function (series) {\n                    types[series.type] = 1;\n                });\n                return Object.keys(types);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (Accessibility) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            Accessibility.i18nFormat = A11yI18n.i18nFormat;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Destroy with chart.\n             * @private\n             */\n            function chartOnDestroy() {\n                if (this.accessibility) {\n                    this.accessibility.destroy();\n                }\n            }\n            /**\n             * Handle updates to the module and send render updates to components.\n             * @private\n             */\n            function chartOnRender() {\n                // Update/destroy\n                if (this.a11yDirty && this.renderTo) {\n                    delete this.a11yDirty;\n                    this.updateA11yEnabled();\n                }\n                const a11y = this.accessibility;\n                if (a11y && !a11y.zombie) {\n                    a11y.proxyProvider.updateProxyElementPositions();\n                    a11y.getComponentOrder().forEach(function (componentName) {\n                        a11y.components[componentName].onChartRender();\n                    });\n                }\n            }\n            /**\n             * Update with chart/series/point updates.\n             * @private\n             */\n            function chartOnUpdate(e) {\n                // Merge new options\n                const newOptions = e.options.accessibility;\n                if (newOptions) {\n                    // Handle custom component updating specifically\n                    if (newOptions.customComponents) {\n                        this.options.accessibility.customComponents =\n                            newOptions.customComponents;\n                        delete newOptions.customComponents;\n                    }\n                    merge(true, this.options.accessibility, newOptions);\n                    // Recreate from scratch\n                    if (this.accessibility && this.accessibility.destroy) {\n                        this.accessibility.destroy();\n                        delete this.accessibility;\n                    }\n                }\n                // Mark dirty for update\n                this.a11yDirty = true;\n            }\n            /**\n             * @private\n             */\n            function chartUpdateA11yEnabled() {\n                let a11y = this.accessibility;\n                const accessibilityOptions = this.options.accessibility;\n                if (accessibilityOptions && accessibilityOptions.enabled) {\n                    if (a11y && !a11y.zombie) {\n                        a11y.update();\n                    }\n                    else {\n                        this.accessibility = a11y = new Accessibility(this);\n                        if (a11y && !a11y.zombie) {\n                            a11y.update();\n                        }\n                    }\n                }\n                else if (a11y) {\n                    // Destroy if after update we have a11y and it is disabled\n                    if (a11y.destroy) {\n                        a11y.destroy();\n                    }\n                    delete this.accessibility;\n                }\n                else {\n                    // Just hide container\n                    this.renderTo.setAttribute('aria-hidden', true);\n                }\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, LegendClass, PointClass, SeriesClass, SVGElementClass, RangeSelectorClass) {\n                // ordered:\n                KeyboardNavigation.compose(ChartClass);\n                NewDataAnnouncer.compose(SeriesClass);\n                LegendComponent.compose(ChartClass, LegendClass);\n                MenuComponent.compose(ChartClass);\n                SeriesComponent.compose(ChartClass, PointClass, SeriesClass);\n                // RangeSelector\n                A11yI18n.compose(ChartClass);\n                FocusBorder.compose(ChartClass, SVGElementClass);\n                if (RangeSelectorClass) {\n                    RangeSelectorComponent.compose(ChartClass, RangeSelectorClass);\n                }\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.updateA11yEnabled = chartUpdateA11yEnabled;\n                    addEvent(ChartClass, 'destroy', chartOnDestroy);\n                    addEvent(ChartClass, 'render', chartOnRender);\n                    addEvent(ChartClass, 'update', chartOnUpdate);\n                    // Mark dirty for update\n                    ['addSeries', 'init'].forEach((event) => {\n                        addEvent(ChartClass, event, function () {\n                            this.a11yDirty = true;\n                        });\n                    });\n                    // Direct updates (events happen after render)\n                    ['afterApplyDrilldown', 'drillupall'].forEach((event) => {\n                        addEvent(ChartClass, event, function chartOnAfterDrilldown() {\n                            const a11y = this.accessibility;\n                            if (a11y && !a11y.zombie) {\n                                a11y.update();\n                            }\n                        });\n                    });\n                }\n                if (U.pushUnique(composedMembers, PointClass)) {\n                    addEvent(PointClass, 'update', pointOnUpdate);\n                }\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    // Mark dirty for update\n                    ['update', 'updatedData', 'remove'].forEach((event) => {\n                        addEvent(SeriesClass, event, function () {\n                            if (this.chart.accessibility) {\n                                this.chart.a11yDirty = true;\n                            }\n                        });\n                    });\n                }\n            }\n            Accessibility.compose = compose;\n            /**\n             * Mark dirty for update.\n             * @private\n             */\n            function pointOnUpdate() {\n                if (this.series.chart.accessibility) {\n                    this.series.chart.a11yDirty = true;\n                }\n            }\n        })(Accessibility || (Accessibility = {}));\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // Add default options\n        merge(true, defaultOptions, defaultOptionsA11Y, {\n            accessibility: {\n                highContrastTheme: highContrastTheme\n            },\n            lang: defaultLangOptions\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Accessibility;\n    });\n    _registerModule(_modules, 'masters/modules/accessibility.src.js', [_modules['Core/Globals.js'], _modules['Accessibility/Accessibility.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function (Highcharts, Accessibility, AccessibilityComponent, ChartUtilities, HTMLUtilities, KeyboardNavigationHandler, SeriesDescriber) {\n\n        const G = Highcharts;\n        G.i18nFormat = Accessibility.i18nFormat;\n        G.A11yChartUtilities = ChartUtilities;\n        G.A11yHTMLUtilities = HTMLUtilities;\n        G.AccessibilityComponent = AccessibilityComponent;\n        G.KeyboardNavigationHandler = KeyboardNavigationHandler;\n        G.SeriesAccessibilityDescriber = SeriesDescriber;\n        Accessibility.compose(G.Chart, G.Legend, G.Point, G.Series, G.SVGElement, G.RangeSelector);\n\n    });\n}));"],"names":["b","x","r","n","q","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","path","module","_modules","w","MouseEvent","type","m","createEvent","l","initMouseEvent","bubbles","cancelable","view","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","g","h","y","composed","buttons","doc","win","css","v","EventTarget","addClass","classList","add","className","indexOf","cloneMouseEvent","cloneTouchEvent","a","c","length","d","item","push","TouchEvent","touches","targetTouches","changedTouches","defaultPrevented","preventDefault","escapeStringForHTML","replace","getElement","getElementById","getFakeMouseEvent","getHeadingTagNameForElement","parseInt","slice","Math","min","previousSibling","tagName","test","parentElement","removeChildNodes","lastChild","removeChild","removeClass","remove","RegExp","removeElement","parentNode","reverseChildNodes","childNodes","appendChild","simulatedEventTarget","stripHTMLTagsFromString","visuallyHideElement","position","width","height","overflow","whiteSpace","clip","marginTop","filter","opacity","format","getNestedProperty","pick","e","getFirstBracketStatement","f","statement","substring","begin","end","A","value","forEach","split","Number","isNaN","trim","reduce","this","options","lang","compose","pushUnique","prototype","langFormat","i18nFormat","points","graphic","element","graph","group","defined","find","fireEvent","fireEventOnWrappedOrUnwrappedElement","hcEvents","getChartTitle","title","text","chart","getAxisDescription","userOptions","accessibility","description","axisTitle","textStr","id","categories","dateTime","getAxisRangeDescription","rangeDescription","dataMax","dataMin","axis","numCategories","screenReaderSection","axisRangeDateFormat","max","time","dateFormat","toString","rangeFrom","rangeTo","Seconds","Minutes","Hours","Days","toFixed","range","getPointFromXY","getSeriesFirstPointElement","getSeriesFromName","series","name","getSeriesA11yElement","unhideChartElementFromAT","setAttribute","renderTo","body","Array","call","hasAttribute","hideSeriesFromAT","scrollToPoint","xAxis","yAxis","scrollbar","to","from","toPixels","coll","updatePosition","trigger","DOMEvent","constructor","elements","createElement","arguments","destroyCreatedElements","addEvent","eventRemovers","removeAddedEvents","extend","proxyProvider","keyCodes","eventProvider","domElementProvider","initBase","left","right","up","down","enter","space","esc","tab","pageUp","pageDown","home","fakeClickEvent","destroyBase","init","getKeyboardNavigation","onChartUpdate","onChartRender","destroy","keyCodeMap","validate","terminate","response","success","prev","next","noHandler","fail","run","which","keyCode","handleSVGTitleElement","setSVGContainerLabel","setGraphicContainerAttrs","setRenderToAttrs","makeCreditsAccessible","index","chartTitle","svgTitleElement","createElementNS","textContent","insertBefore","firstChild","renderer","box","container","landmarkVerbosity","credits","creditsStr","keyboardNavigation","tabindexContainer","focus","focusElement","focusBorder","removeFocusBorder","enabled","addFocusBorder","margin","stroke","style","color","strokeWidth","lineWidth","borderRadius","focusin","hideBrowserFocusOutline","outline","renderFocusBorder","getBBox","parentGroup","B","scaleX","scaleY","abs","translateX","translateY","z","u","k","t","nodeName","rotation","p","E","attr","rect","zIndex","styledMode","focusBorderDestroyHook","_len","_key","focusBorderUpdateHooks","_defaultSetter","Object","keys","setFocusToElement","announceRegion","addAnnounceRegion","announce","setElementHTML","clearAnnouncementRegionTimer","clearTimeout","setTimeout","innerHTML","emptyHTML","announcerContainer","createAnnouncerContainer","annotations","visible","concat","labels","map","valueDescription","getAttribute","annotationText","annotation","numPoints","annotationPoint","additionalAnnotationPoints","getAnnotationsInfoHTML","join","getAnnotationLabelDescription","getAnnotationListItems","getPointAnnotationTexts","L","K","D","super","announcer","screenReaderSections","initRegionsDefinitions","onDataTableCreated","wasHidden","dataTableDiv","focusDataTable","before","buildContent","beforeChartFormatter","defaultBeforeChartFormatter","insertIntoDOM","afterInserted","sonifyButtonId","initSonifyButton","dataTableButtonId","initDataTableButton","after","afterChartFormatter","defaultAfterChartFormatter","nextSibling","updateExitAnchor","linkedDescriptionElement","getLinkedDescriptionElement","setLinkedDescriptionAttrs","updateScreenReaderSection","linkedDescription","querySelectorAll","setScreenReaderSectionAttribs","beforeChartFormat","getAxesDescription","sonify","sonification","headingTagName","typeDescription","getTypeDescriptionText","chartSubtitle","getSubtitleText","chartLongdesc","getLongdescText","xAxisDescription","yAxisDescription","playAsSoundButton","getSonifyButtonText","viewTableButton","getCSV","getDataTableButtonText","annotationsTitle","annotationsList","afterChartFormat","endOfChartMarker","getEndOfChartMarkerText","getLinkedDescription","caption","types","numSeries","mapTitle","mapView","geoMap","subtitle","viewDataTableButton","tree","attributes","tabindex","summary","getElementsByTagName","sonifyButton","stopPropagation","removeAttribute","onclick","onPlayAsSoundClick","onViewDataTableClick","viewData","hasCartesianSeries","angular","getAxisDescriptionText","names","ranges","numAxes","onMenuShown","onMenuHidden","createProxyGroup","exportContextMenu","setExportButtonExpandedState","addAccessibleContextMenuAttribs","exportButtonProxy","buttonElement","clearGroup","proxyMenuButton","exportingGroup","exportSVGElements","exporting","addProxyElement","click","contextButtonTitle","addGroup","exportDivElements","children","role","onKbdPrevious","onKbdNext","onKbdClick","hideExportMenu","highlightedExportItemIx","highlightExportItem","wrapAround","highlightLastExportItem","openMenu","onmouseout","hideMenu","onmouseover","showExportMenu","components","currentModuleIx","NaN","exitAnchor","modules","update","onKeydown","onFocus","onMouseUp","isClickingChart","updateContainerTabindex","removeExitAnchor","makeElementAnExitAnchor","createExitAnchor","move","exiting","contains","tabbingInBackwards","getFirstValidModuleIx","keyboardReset","target","event","addExitAnchorEventsToEl","tooltip","hide","charts","dismissPopupContent","legend","allItems","colorAxis","some","dataClasses","legendItem","setState","animObject","isNumber","syncTimeout","H","F","highlightedLegendItemIx","proxyGroup","recreateProxies","updateGroupProxyElementPositions","updateLegendItemProxyVisibility","highlightLegendItem","updateProxyPositionForItem","globalAnimation","duration","currentPage","clipHeight","a11yProxyElement","pages","G","pageIx","label","round","visibility","removeProxies","highlightAdjacentLegendPage","refreshPosition","activeElement","addLegendProxyGroup","proxyLegendItems","updateLegendTitle","removeGroup","legendTitle","updateGroupAttrs","proxyLegendItem","itemName","visual","div","onKbdArrowKey","shouldHaveLegendNavigation","J","display","scroll","data","pointDescriptionEnabledThreshold","point","tooltipOptions","valueDecimals","decimalPoint","thousandsSep","valueDescriptionFormat","getXDateFormat","dateTimeLabelFormats","dateFormatter","category","valuePrefix","valueSuffix","isNull","pointArrayMap","xDescription","separator","exposeAsGroupOnly","seriesNavigation","pointNavigationEnabledThreshold","describeNull","is","plotX","plotY","fill","hasMockGraphic","descriptionFormatter","seriesNumber","descriptionFormat","seriesDescription","authorDescription","axisDescription","numberFormat","defaultPointDescriptionFormatter","defaultSeriesDescriptionFormatter","describeSeries","is3d","describeSingleSeries","options3d","dirty","allSeries","lastAnnouncementTime","announceNewData","interruptUser","addEventListeners","onSeriesAdded","announceDirtyData","hasDirty","newSeries","newPoint","queueAnnouncement","Date","minAnnounceInterval","queuedAnnouncement","buildAnnouncementMessage","queuedAnnouncementTimer","message","announcementFormatter","seriesDesc","pointDesc","newDataAnnouncer","composedMembers","merge","groupType","hideButtonVisually","listStyle","updateTarget","getTargetPosition","updateCSSClassName","getTargetAttr","addProxyEventsToButton","top","passive","borderWidth","backgroundColor","cursor","padding","getBoundingClientRect","pointer","getChartPosition","bottom","groups","groupOrder","beforeChartProxyPosContainer","createProxyPosContainer","afterChartProxyPosContainer","Error","proxyContainerElement","proxyElements","groupElement","updateGroupOrder","isDOMOrderGroupOrder","updatePosContainerPositions","updateProxyElementPositions","bind","getCurrentGroupOrderInDOM","forExport","rangeSelectorZoom","rangeSelectorFrom","rangeSelectorTo","rangeSelector","allButtonsEnabled","buttonSpacing","dropdown","verticalAlign","buttonTheme","floating","inputBoxBorderColor","inputBoxHeight","inputBoxWidth","inputDateFormat","inputDateParser","inputEditDateFormat","inputEnabled","inputPosition","align","inputSpacing","selected","buttonPosition","inputStyle","fontSize","labelStyle","get","set","getTime","count","fixedRange","MIN_VALUE","newMax","MAX_VALUE","_offsetMin","axes","deferredYTDClick","clickButton","updateNames","setScale","getAxisMargins","render","extraBottomMargin","extraTopMargin","redraw","getExtremes","spacingBox","layout","plotTop","getHeight","placed","splice","marginBottom","isDirtyBox","defaultOptions","setOptions","minFromRange","callbacks","destroyObjectProperties","discardElement","objectEach","pad","pInt","splat","buttonOptions","defaultButtons","initialButtonGroupWidth","scroller","getUnionExtremes","dataGrouping","I","C","_range","setSelected","forcedDataGrouping","setDataGrouping","frozenStates","preserveDataGrouping","xData","getYTDExtremes","useUTC","navigator","baseSeries","_offsetMax","selectedIndex","setExtremes","rangeSelectorButton","minInput","maxInput","blur","eventsToUnbind","computeButtonRange","updateButtonStates","hasVisibleSeries","M","N","minRange","month","year","state","disabled","millisecond","second","minute","hour","day","week","offsetMin","offsetMax","getInputValue","defaultInputDateParser","setInputValue","minDateBox","maxDateBox","inputTypeFormats","setInputExtremes","showInput","inputGroup","border","offsetWidth","chartWidth","offsetHeight","hideInput","isSafari","lastIndexOf","getTimezoneOffset","parse","UTC","drawInput","on","boxShadow","textAlign","fontFamily","onfocus","onblur","onchange","onkeypress","onkeydown","onkeyup","dateBox","input","getPosition","buttonTop","axisOffset","inputTop","rendered","renderButtons","minLabel","maxLabel","alignElements","states","buttonGroup","isMS","_ref","currentButtonIndex","zoomText","paddingLeft","paddingRight","events","isActive","hover","select","navigation","getXOffsetForExportButton","titleCollision","spacing","plotLeft","positionButtons","alignButtonGroup","hasLoaded","handleCollision","alignAttr","legendHeight","titleOffset","translate","floor","maxButtonWidth","alignOptions","moveInputsDown","collapseButtons","expandButtons","plotWidth","show","showDropdown","hideDropdown","hasVisibleDropdown","HTMLElement","date","updateSelectorVisibility","setDropdownAttrs","setRangeButtonAttrs","setRangeInputAttrs","rangeTitle","onButtonNavKbdArrowKey","highlightRangeSelectorButton","highlightedRangeSelectorItemIx","onButtonNavKbdClick","oldRangeSelectorItemState","onAfterBtnClick","axisRangeDescription","onInputKbdMove","highlightedInputRangeIx","onInputNavInit","removeInputKeydownHandler","onInputNavTerminate","initDropdownNav","removeDropdownKeydownHandler","getRangeSelectorButtonNavigation","getRangeSelectorInputNavigation","marker","normal","markerGroup","a11yMarkersForced","_hasPointMarkers","hasForcedA11yMarker","resetA11yMarkerOptions","enableMouseTracking","skipNullPoints","isInside","highlightedPoint","highlightNextValidPoint","highlight","seriesTypes","onSeriesDestroy","lastDrilledDownPoint","seriesName","onDrillupAll","getKeyboardNavigationHandler","inverted","onKbdSideways","onKbdVertical","firePointEvent","highlightAdjacentSeries","onHandlerInit","onHandlerTerminate","attemptHighlightAdjacentPoint","rememberPointFocus","mode","keyboardMoveVertical","onMouseOut","highlightAdjacentPoint","Infinity","reversed","undefined","onMouseOver","highlightAdjacentPointVertical","hideTooltipFromATWhenShown","hideSeriesLabelsFromATWhenShown","labelBySeries","focusedMapNavButtonIx","updateProxyOverlays","mapNavigation","navButtons","setMapNavButtonAttrs","resetZoomButton","createZoomProxyButton","drillUpButton","breadcrumbs","list","buttonText","getButtonText","getMapZoomNavigation","onMapKbdArrow","onMapKbdTab","onMapKbdClick","onMapNavInit","plotHeight","random","offsetLeft","offsetTop","zoomBy","simpleButtonNavigation","zoomOut","drillUp","isHighContrastModeActive","userAgent","matchMedia","matches","getComputedStyle","backgroundImage","currentStyle","setHighContrastTheme","highContrastModeActive","highContrastTheme","plotOptions","colors","borderColor","minColor","maxColor","stops","gridLineColor","lineColor","minorGridLineColor","tickColor","fillColor","edgeColor","dataLabels","connectorColor","textOutline","pie","boxplot","candlestick","errorbar","itemStyle","itemHoverStyle","itemHiddenStyle","drilldown","activeAxisLabelStyle","activeDataLabelStyle","symbolStroke","theme","handles","outlineColor","maskFill","barBackgroundColor","barBorderColor","buttonArrowColor","buttonBackgroundColor","buttonBorderColor","rifleColor","trackBackgroundColor","trackBorderColor","order","defaultChartTitle","chartContainerLabel","svgContainerLabel","svgContainerTitle","graphicContainerLabel","beforeRegionLabel","afterRegionLabel","heading","descriptionSinglePoint","descriptionMultiplePoints","descriptionNoPoints","playAsSoundButtonText","playAsSoundClickAnnouncement","legendLabelNoTitle","legendLabel","zoom","mapZoomIn","mapZoomOut","dropdownLabel","minInputLabel","maxInputLabel","clickButtonAnnouncement","table","viewAsDataTableButtonText","tableSummary","newDataAnnounce","newSeriesAnnounceSingle","newPointAnnounceSingle","newSeriesAnnounceMultiple","newPointAnnounceMultiple","seriesTypeDescriptions","arearange","areasplinerange","bubble","columnrange","funnel","pyramid","waterfall","chartTypes","emptyChart","mapTypeDescription","unknownMap","combinationChart","defaultSingle","defaultMultiple","splineSingle","splineMultiple","lineSingle","lineMultiple","columnSingle","columnMultiple","barSingle","barMultiple","pieSingle","pieMultiple","scatterSingle","scatterMultiple","boxplotSingle","boxplotMultiple","bubbleSingle","bubbleMultiple","xAxisDescriptionSingular","xAxisDescriptionPlural","yAxisDescriptionSingular","yAxisDescriptionPlural","timeRangeDays","timeRangeHours","timeRangeMinutes","timeRangeSeconds","rangeFromTo","rangeCategories","chartMenuLabel","menuButtonLabel","defaultCombination","line","lineCombination","spline","splineCombination","column","columnCombination","bar","barCombination","pieCombination","scatter","scatterCombination","boxplotCombination","bubbleCombination","mapCombination","mapline","maplineCombination","mapbubble","mapbubbleCombination","nullPointValue","pointAnnotationsDescription","error","exposeElementToA11y","pointDescriptionFormatter","skipKeyboardNavigation","pointDateFormat","pointDateFormatter","pointDescriptionThreshold","pointNavigationThreshold","pointValueDecimals","pointValuePrefix","pointValueSuffix","screenReaderSectionFormatter","seriesDescriptionFormatter","onTableAnchorClick","screenReaderRegionLabel","rangeSelectorMaxInput","rangeSelectorMinInput","svgContainerEnd","viewAsDataTable","addEventListener","initComponents","zombie","infoRegions","chartMenu","customComponents","getComponentOrder","getChartTypes","component","a11yDirty","updateA11yEnabled","A11yChartUtilities","A11yHTMLUtilities","AccessibilityComponent","KeyboardNavigationHandler","SeriesAccessibilityDescriber","Chart","Legend","Point","Series","SVGElement","RangeSelector","exports","define","Highcharts"],"sourceRoot":""}